module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Acceptance {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type AcceptanceConnection {
  pageInfo: PageInfo!
  edges: [AcceptanceEdge]!
  aggregate: AggregateAcceptance!
}

input AcceptanceCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AcceptanceCreateManyInput {
  create: [AcceptanceCreateInput!]
  connect: [AcceptanceWhereUniqueInput!]
}

type AcceptanceEdge {
  node: Acceptance!
  cursor: String!
}

enum AcceptanceOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type AcceptancePreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AcceptanceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [AcceptanceScalarWhereInput!]
  OR: [AcceptanceScalarWhereInput!]
  NOT: [AcceptanceScalarWhereInput!]
}

type AcceptanceSubscriptionPayload {
  mutation: MutationType!
  node: Acceptance
  updatedFields: [String!]
  previousValues: AcceptancePreviousValues
}

input AcceptanceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AcceptanceWhereInput
  AND: [AcceptanceSubscriptionWhereInput!]
  OR: [AcceptanceSubscriptionWhereInput!]
  NOT: [AcceptanceSubscriptionWhereInput!]
}

input AcceptanceUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AcceptanceUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AcceptanceUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AcceptanceUpdateManyInput {
  create: [AcceptanceCreateInput!]
  update: [AcceptanceUpdateWithWhereUniqueNestedInput!]
  upsert: [AcceptanceUpsertWithWhereUniqueNestedInput!]
  delete: [AcceptanceWhereUniqueInput!]
  connect: [AcceptanceWhereUniqueInput!]
  set: [AcceptanceWhereUniqueInput!]
  disconnect: [AcceptanceWhereUniqueInput!]
  deleteMany: [AcceptanceScalarWhereInput!]
  updateMany: [AcceptanceUpdateManyWithWhereNestedInput!]
}

input AcceptanceUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AcceptanceUpdateManyWithWhereNestedInput {
  where: AcceptanceScalarWhereInput!
  data: AcceptanceUpdateManyDataInput!
}

input AcceptanceUpdateWithWhereUniqueNestedInput {
  where: AcceptanceWhereUniqueInput!
  data: AcceptanceUpdateDataInput!
}

input AcceptanceUpsertWithWhereUniqueNestedInput {
  where: AcceptanceWhereUniqueInput!
  update: AcceptanceUpdateDataInput!
  create: AcceptanceCreateInput!
}

input AcceptanceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [AcceptanceWhereInput!]
  OR: [AcceptanceWhereInput!]
  NOT: [AcceptanceWhereInput!]
}

input AcceptanceWhereUniqueInput {
  id: ID
}

type Act {
  id: ID!
  service(where: ServiceWhereInput, orderBy: ServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Service!]
  support(where: SupportWhereInput, orderBy: SupportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Support!]
  sacrifice(where: SacrificeWhereInput, orderBy: SacrificeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sacrifice!]
}

type ActConnection {
  pageInfo: PageInfo!
  edges: [ActEdge]!
  aggregate: AggregateAct!
}

input ActCreateInput {
  id: ID
  service: ServiceCreateManyInput
  support: SupportCreateManyInput
  sacrifice: SacrificeCreateManyInput
}

input ActCreateManyInput {
  create: [ActCreateInput!]
  connect: [ActWhereUniqueInput!]
}

input ActCreateOneInput {
  create: ActCreateInput
  connect: ActWhereUniqueInput
}

type ActEdge {
  node: Act!
  cursor: String!
}

enum ActOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ActPreviousValues {
  id: ID!
}

input ActScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ActScalarWhereInput!]
  OR: [ActScalarWhereInput!]
  NOT: [ActScalarWhereInput!]
}

type ActSubscriptionPayload {
  mutation: MutationType!
  node: Act
  updatedFields: [String!]
  previousValues: ActPreviousValues
}

input ActSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ActWhereInput
  AND: [ActSubscriptionWhereInput!]
  OR: [ActSubscriptionWhereInput!]
  NOT: [ActSubscriptionWhereInput!]
}

input ActUpdateDataInput {
  service: ServiceUpdateManyInput
  support: SupportUpdateManyInput
  sacrifice: SacrificeUpdateManyInput
}

input ActUpdateInput {
  service: ServiceUpdateManyInput
  support: SupportUpdateManyInput
  sacrifice: SacrificeUpdateManyInput
}

input ActUpdateManyInput {
  create: [ActCreateInput!]
  update: [ActUpdateWithWhereUniqueNestedInput!]
  upsert: [ActUpsertWithWhereUniqueNestedInput!]
  delete: [ActWhereUniqueInput!]
  connect: [ActWhereUniqueInput!]
  set: [ActWhereUniqueInput!]
  disconnect: [ActWhereUniqueInput!]
  deleteMany: [ActScalarWhereInput!]
}

input ActUpdateOneInput {
  create: ActCreateInput
  update: ActUpdateDataInput
  upsert: ActUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ActWhereUniqueInput
}

input ActUpdateWithWhereUniqueNestedInput {
  where: ActWhereUniqueInput!
  data: ActUpdateDataInput!
}

input ActUpsertNestedInput {
  update: ActUpdateDataInput!
  create: ActCreateInput!
}

input ActUpsertWithWhereUniqueNestedInput {
  where: ActWhereUniqueInput!
  update: ActUpdateDataInput!
  create: ActCreateInput!
}

input ActWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  service_every: ServiceWhereInput
  service_some: ServiceWhereInput
  service_none: ServiceWhereInput
  support_every: SupportWhereInput
  support_some: SupportWhereInput
  support_none: SupportWhereInput
  sacrifice_every: SacrificeWhereInput
  sacrifice_some: SacrificeWhereInput
  sacrifice_none: SacrificeWhereInput
  AND: [ActWhereInput!]
  OR: [ActWhereInput!]
  NOT: [ActWhereInput!]
}

input ActWhereUniqueInput {
  id: ID
}

type Affliction {
  id: ID!
  scar(where: ScarWhereInput, orderBy: ScarOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Scar!]
  gash(where: GashWhereInput, orderBy: GashOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gash!]
  infection(where: InfectionWhereInput, orderBy: InfectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Infection!]
  tremor(where: TremorWhereInput, orderBy: TremorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tremor!]
  nightmare(where: NightmareWhereInput, orderBy: NightmareOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Nightmare!]
  delirium(where: DeliriumWhereInput, orderBy: DeliriumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Delirium!]
}

type AfflictionConnection {
  pageInfo: PageInfo!
  edges: [AfflictionEdge]!
  aggregate: AggregateAffliction!
}

input AfflictionCreateInput {
  id: ID
  scar: ScarCreateManyInput
  gash: GashCreateManyInput
  infection: InfectionCreateManyInput
  tremor: TremorCreateManyInput
  nightmare: NightmareCreateManyInput
  delirium: DeliriumCreateManyInput
}

input AfflictionCreateManyInput {
  create: [AfflictionCreateInput!]
  connect: [AfflictionWhereUniqueInput!]
}

input AfflictionCreateOneInput {
  create: AfflictionCreateInput
  connect: AfflictionWhereUniqueInput
}

type AfflictionEdge {
  node: Affliction!
  cursor: String!
}

enum AfflictionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AfflictionPreviousValues {
  id: ID!
}

input AfflictionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [AfflictionScalarWhereInput!]
  OR: [AfflictionScalarWhereInput!]
  NOT: [AfflictionScalarWhereInput!]
}

type AfflictionSubscriptionPayload {
  mutation: MutationType!
  node: Affliction
  updatedFields: [String!]
  previousValues: AfflictionPreviousValues
}

input AfflictionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AfflictionWhereInput
  AND: [AfflictionSubscriptionWhereInput!]
  OR: [AfflictionSubscriptionWhereInput!]
  NOT: [AfflictionSubscriptionWhereInput!]
}

input AfflictionUpdateDataInput {
  scar: ScarUpdateManyInput
  gash: GashUpdateManyInput
  infection: InfectionUpdateManyInput
  tremor: TremorUpdateManyInput
  nightmare: NightmareUpdateManyInput
  delirium: DeliriumUpdateManyInput
}

input AfflictionUpdateInput {
  scar: ScarUpdateManyInput
  gash: GashUpdateManyInput
  infection: InfectionUpdateManyInput
  tremor: TremorUpdateManyInput
  nightmare: NightmareUpdateManyInput
  delirium: DeliriumUpdateManyInput
}

input AfflictionUpdateManyInput {
  create: [AfflictionCreateInput!]
  update: [AfflictionUpdateWithWhereUniqueNestedInput!]
  upsert: [AfflictionUpsertWithWhereUniqueNestedInput!]
  delete: [AfflictionWhereUniqueInput!]
  connect: [AfflictionWhereUniqueInput!]
  set: [AfflictionWhereUniqueInput!]
  disconnect: [AfflictionWhereUniqueInput!]
  deleteMany: [AfflictionScalarWhereInput!]
}

input AfflictionUpdateOneInput {
  create: AfflictionCreateInput
  update: AfflictionUpdateDataInput
  upsert: AfflictionUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: AfflictionWhereUniqueInput
}

input AfflictionUpdateWithWhereUniqueNestedInput {
  where: AfflictionWhereUniqueInput!
  data: AfflictionUpdateDataInput!
}

input AfflictionUpsertNestedInput {
  update: AfflictionUpdateDataInput!
  create: AfflictionCreateInput!
}

input AfflictionUpsertWithWhereUniqueNestedInput {
  where: AfflictionWhereUniqueInput!
  update: AfflictionUpdateDataInput!
  create: AfflictionCreateInput!
}

input AfflictionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  scar_every: ScarWhereInput
  scar_some: ScarWhereInput
  scar_none: ScarWhereInput
  gash_every: GashWhereInput
  gash_some: GashWhereInput
  gash_none: GashWhereInput
  infection_every: InfectionWhereInput
  infection_some: InfectionWhereInput
  infection_none: InfectionWhereInput
  tremor_every: TremorWhereInput
  tremor_some: TremorWhereInput
  tremor_none: TremorWhereInput
  nightmare_every: NightmareWhereInput
  nightmare_some: NightmareWhereInput
  nightmare_none: NightmareWhereInput
  delirium_every: DeliriumWhereInput
  delirium_some: DeliriumWhereInput
  delirium_none: DeliriumWhereInput
  AND: [AfflictionWhereInput!]
  OR: [AfflictionWhereInput!]
  NOT: [AfflictionWhereInput!]
}

input AfflictionWhereUniqueInput {
  id: ID
}

type AggregateAcceptance {
  count: Int!
}

type AggregateAct {
  count: Int!
}

type AggregateAffliction {
  count: Int!
}

type AggregateAnger {
  count: Int!
}

type AggregateArmor {
  count: Int!
}

type AggregateBody {
  count: Int!
}

type AggregateBoundary {
  count: Int!
}

type AggregateBrain {
  count: Int!
}

type AggregateCampaign {
  count: Int!
}

type AggregateCharacters {
  count: Int!
}

type AggregateCompassion {
  count: Int!
}

type AggregateConfusion {
  count: Int!
}

type AggregateCongregant {
  count: Int!
}

type AggregateConstruct {
  count: Int!
}

type AggregateCourage {
  count: Int!
}

type AggregateCross {
  count: Int!
}

type AggregateCrown {
  count: Int!
}

type AggregateCrusade {
  count: Int!
}

type AggregateDefect {
  count: Int!
}

type AggregateDelirium {
  count: Int!
}

type AggregateDenial {
  count: Int!
}

type AggregateDiscontent {
  count: Int!
}

type AggregateDream {
  count: Int!
}

type AggregateExperience {
  count: Int!
}

type AggregateFace {
  count: Int!
}

type AggregateFear {
  count: Int!
}

type AggregateFeeling {
  count: Int!
}

type AggregateFun {
  count: Int!
}

type AggregateGash {
  count: Int!
}

type AggregateGate {
  count: Int!
}

type AggregateGenie {
  count: Int!
}

type AggregateGratitude {
  count: Int!
}

type AggregateGuardian {
  count: Int!
}

type AggregateGut {
  count: Int!
}

type AggregateHas {
  count: Int!
}

type AggregateHeart {
  count: Int!
}

type AggregateHigherPower {
  count: Int!
}

type AggregateHonor {
  count: Int!
}

type AggregateHope {
  count: Int!
}

type AggregateImpatience {
  count: Int!
}

type AggregateInfection {
  count: Int!
}

type AggregateInventory {
  count: Int!
}

type AggregateIrritability {
  count: Int!
}

type AggregateJoy {
  count: Int!
}

type AggregateLove {
  count: Int!
}

type AggregateLoyalty {
  count: Int!
}

type AggregateMartyr {
  count: Int!
}

type AggregateMind {
  count: Int!
}

type AggregateMouth {
  count: Int!
}

type AggregateNail {
  count: Int!
}

type AggregateNightmare {
  count: Int!
}

type AggregateOath {
  count: Int!
}

type AggregateObsession {
  count: Int!
}

type AggregatePaladin {
  count: Int!
}

type AggregatePath {
  count: Int!
}

type AggregatePledge {
  count: Int!
}

type AggregatePrayer {
  count: Int!
}

type AggregatePride {
  count: Int!
}

type AggregateProcess {
  count: Int!
}

type AggregateResentment {
  count: Int!
}

type AggregateSacrifice {
  count: Int!
}

type AggregateSalvation {
  count: Int!
}

type AggregateSarcasm {
  count: Int!
}

type AggregateScar {
  count: Int!
}

type AggregateSeeker {
  count: Int!
}

type AggregateSelf {
  count: Int!
}

type AggregateSelfPity {
  count: Int!
}

type AggregateService {
  count: Int!
}

type AggregateShield {
  count: Int!
}

type AggregateSilence {
  count: Int!
}

type AggregateSkin {
  count: Int!
}

type AggregateSmith {
  count: Int!
}

type AggregateSoul {
  count: Int!
}

type AggregateSternum {
  count: Int!
}

type AggregateStigmata {
  count: Int!
}

type AggregateStrength {
  count: Int!
}

type AggregateSuffering {
  count: Int!
}

type AggregateSummoner {
  count: Int!
}

type AggregateSupport {
  count: Int!
}

type AggregateTower {
  count: Int!
}

type AggregateToxicity {
  count: Int!
}

type AggregateTrauma {
  count: Int!
}

type AggregateTremor {
  count: Int!
}

type AggregateVictim {
  count: Int!
}

type AggregateVirtue {
  count: Int!
}

type AggregateVolunteer {
  count: Int!
}

type AggregateVulnerability {
  count: Int!
}

type AggregateWall {
  count: Int!
}

type AggregateWish {
  count: Int!
}

type Anger {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type AngerConnection {
  pageInfo: PageInfo!
  edges: [AngerEdge]!
  aggregate: AggregateAnger!
}

input AngerCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AngerCreateManyInput {
  create: [AngerCreateInput!]
  connect: [AngerWhereUniqueInput!]
}

type AngerEdge {
  node: Anger!
  cursor: String!
}

enum AngerOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type AngerPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AngerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [AngerScalarWhereInput!]
  OR: [AngerScalarWhereInput!]
  NOT: [AngerScalarWhereInput!]
}

type AngerSubscriptionPayload {
  mutation: MutationType!
  node: Anger
  updatedFields: [String!]
  previousValues: AngerPreviousValues
}

input AngerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AngerWhereInput
  AND: [AngerSubscriptionWhereInput!]
  OR: [AngerSubscriptionWhereInput!]
  NOT: [AngerSubscriptionWhereInput!]
}

input AngerUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AngerUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AngerUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AngerUpdateManyInput {
  create: [AngerCreateInput!]
  update: [AngerUpdateWithWhereUniqueNestedInput!]
  upsert: [AngerUpsertWithWhereUniqueNestedInput!]
  delete: [AngerWhereUniqueInput!]
  connect: [AngerWhereUniqueInput!]
  set: [AngerWhereUniqueInput!]
  disconnect: [AngerWhereUniqueInput!]
  deleteMany: [AngerScalarWhereInput!]
  updateMany: [AngerUpdateManyWithWhereNestedInput!]
}

input AngerUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AngerUpdateManyWithWhereNestedInput {
  where: AngerScalarWhereInput!
  data: AngerUpdateManyDataInput!
}

input AngerUpdateWithWhereUniqueNestedInput {
  where: AngerWhereUniqueInput!
  data: AngerUpdateDataInput!
}

input AngerUpsertWithWhereUniqueNestedInput {
  where: AngerWhereUniqueInput!
  update: AngerUpdateDataInput!
  create: AngerCreateInput!
}

input AngerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [AngerWhereInput!]
  OR: [AngerWhereInput!]
  NOT: [AngerWhereInput!]
}

input AngerWhereUniqueInput {
  id: ID
}

type Armor {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type ArmorConnection {
  pageInfo: PageInfo!
  edges: [ArmorEdge]!
  aggregate: AggregateArmor!
}

input ArmorCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ArmorCreateManyInput {
  create: [ArmorCreateInput!]
  connect: [ArmorWhereUniqueInput!]
}

type ArmorEdge {
  node: Armor!
  cursor: String!
}

enum ArmorOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type ArmorPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ArmorScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [ArmorScalarWhereInput!]
  OR: [ArmorScalarWhereInput!]
  NOT: [ArmorScalarWhereInput!]
}

type ArmorSubscriptionPayload {
  mutation: MutationType!
  node: Armor
  updatedFields: [String!]
  previousValues: ArmorPreviousValues
}

input ArmorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ArmorWhereInput
  AND: [ArmorSubscriptionWhereInput!]
  OR: [ArmorSubscriptionWhereInput!]
  NOT: [ArmorSubscriptionWhereInput!]
}

input ArmorUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ArmorUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ArmorUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ArmorUpdateManyInput {
  create: [ArmorCreateInput!]
  update: [ArmorUpdateWithWhereUniqueNestedInput!]
  upsert: [ArmorUpsertWithWhereUniqueNestedInput!]
  delete: [ArmorWhereUniqueInput!]
  connect: [ArmorWhereUniqueInput!]
  set: [ArmorWhereUniqueInput!]
  disconnect: [ArmorWhereUniqueInput!]
  deleteMany: [ArmorScalarWhereInput!]
  updateMany: [ArmorUpdateManyWithWhereNestedInput!]
}

input ArmorUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ArmorUpdateManyWithWhereNestedInput {
  where: ArmorScalarWhereInput!
  data: ArmorUpdateManyDataInput!
}

input ArmorUpdateWithWhereUniqueNestedInput {
  where: ArmorWhereUniqueInput!
  data: ArmorUpdateDataInput!
}

input ArmorUpsertWithWhereUniqueNestedInput {
  where: ArmorWhereUniqueInput!
  update: ArmorUpdateDataInput!
  create: ArmorCreateInput!
}

input ArmorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [ArmorWhereInput!]
  OR: [ArmorWhereInput!]
  NOT: [ArmorWhereInput!]
}

input ArmorWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Body {
  id: ID!
  brain(where: BrainWhereInput, orderBy: BrainOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Brain!]
  face(where: FaceWhereInput, orderBy: FaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Face!]
  mouth(where: MouthWhereInput, orderBy: MouthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mouth!]
  soul(where: SoulWhereInput, orderBy: SoulOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Soul!]
  heart(where: HeartWhereInput, orderBy: HeartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Heart!]
  sternum(where: SternumWhereInput, orderBy: SternumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sternum!]
  gut(where: GutWhereInput, orderBy: GutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gut!]
}

type BodyConnection {
  pageInfo: PageInfo!
  edges: [BodyEdge]!
  aggregate: AggregateBody!
}

input BodyCreateInput {
  id: ID
  brain: BrainCreateManyInput
  face: FaceCreateManyInput
  mouth: MouthCreateManyInput
  soul: SoulCreateManyInput
  heart: HeartCreateManyInput
  sternum: SternumCreateManyInput
  gut: GutCreateManyInput
}

input BodyCreateManyInput {
  create: [BodyCreateInput!]
  connect: [BodyWhereUniqueInput!]
}

input BodyCreateOneInput {
  create: BodyCreateInput
  connect: BodyWhereUniqueInput
}

type BodyEdge {
  node: Body!
  cursor: String!
}

enum BodyOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BodyPreviousValues {
  id: ID!
}

input BodyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [BodyScalarWhereInput!]
  OR: [BodyScalarWhereInput!]
  NOT: [BodyScalarWhereInput!]
}

type BodySubscriptionPayload {
  mutation: MutationType!
  node: Body
  updatedFields: [String!]
  previousValues: BodyPreviousValues
}

input BodySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BodyWhereInput
  AND: [BodySubscriptionWhereInput!]
  OR: [BodySubscriptionWhereInput!]
  NOT: [BodySubscriptionWhereInput!]
}

input BodyUpdateDataInput {
  brain: BrainUpdateManyInput
  face: FaceUpdateManyInput
  mouth: MouthUpdateManyInput
  soul: SoulUpdateManyInput
  heart: HeartUpdateManyInput
  sternum: SternumUpdateManyInput
  gut: GutUpdateManyInput
}

input BodyUpdateInput {
  brain: BrainUpdateManyInput
  face: FaceUpdateManyInput
  mouth: MouthUpdateManyInput
  soul: SoulUpdateManyInput
  heart: HeartUpdateManyInput
  sternum: SternumUpdateManyInput
  gut: GutUpdateManyInput
}

input BodyUpdateManyInput {
  create: [BodyCreateInput!]
  update: [BodyUpdateWithWhereUniqueNestedInput!]
  upsert: [BodyUpsertWithWhereUniqueNestedInput!]
  delete: [BodyWhereUniqueInput!]
  connect: [BodyWhereUniqueInput!]
  set: [BodyWhereUniqueInput!]
  disconnect: [BodyWhereUniqueInput!]
  deleteMany: [BodyScalarWhereInput!]
}

input BodyUpdateOneInput {
  create: BodyCreateInput
  update: BodyUpdateDataInput
  upsert: BodyUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: BodyWhereUniqueInput
}

input BodyUpdateWithWhereUniqueNestedInput {
  where: BodyWhereUniqueInput!
  data: BodyUpdateDataInput!
}

input BodyUpsertNestedInput {
  update: BodyUpdateDataInput!
  create: BodyCreateInput!
}

input BodyUpsertWithWhereUniqueNestedInput {
  where: BodyWhereUniqueInput!
  update: BodyUpdateDataInput!
  create: BodyCreateInput!
}

input BodyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  brain_every: BrainWhereInput
  brain_some: BrainWhereInput
  brain_none: BrainWhereInput
  face_every: FaceWhereInput
  face_some: FaceWhereInput
  face_none: FaceWhereInput
  mouth_every: MouthWhereInput
  mouth_some: MouthWhereInput
  mouth_none: MouthWhereInput
  soul_every: SoulWhereInput
  soul_some: SoulWhereInput
  soul_none: SoulWhereInput
  heart_every: HeartWhereInput
  heart_some: HeartWhereInput
  heart_none: HeartWhereInput
  sternum_every: SternumWhereInput
  sternum_some: SternumWhereInput
  sternum_none: SternumWhereInput
  gut_every: GutWhereInput
  gut_some: GutWhereInput
  gut_none: GutWhereInput
  AND: [BodyWhereInput!]
  OR: [BodyWhereInput!]
  NOT: [BodyWhereInput!]
}

input BodyWhereUniqueInput {
  id: ID
}

type Boundary {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type BoundaryConnection {
  pageInfo: PageInfo!
  edges: [BoundaryEdge]!
  aggregate: AggregateBoundary!
}

input BoundaryCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input BoundaryCreateManyInput {
  create: [BoundaryCreateInput!]
  connect: [BoundaryWhereUniqueInput!]
}

type BoundaryEdge {
  node: Boundary!
  cursor: String!
}

enum BoundaryOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type BoundaryPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input BoundaryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [BoundaryScalarWhereInput!]
  OR: [BoundaryScalarWhereInput!]
  NOT: [BoundaryScalarWhereInput!]
}

type BoundarySubscriptionPayload {
  mutation: MutationType!
  node: Boundary
  updatedFields: [String!]
  previousValues: BoundaryPreviousValues
}

input BoundarySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BoundaryWhereInput
  AND: [BoundarySubscriptionWhereInput!]
  OR: [BoundarySubscriptionWhereInput!]
  NOT: [BoundarySubscriptionWhereInput!]
}

input BoundaryUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input BoundaryUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input BoundaryUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input BoundaryUpdateManyInput {
  create: [BoundaryCreateInput!]
  update: [BoundaryUpdateWithWhereUniqueNestedInput!]
  upsert: [BoundaryUpsertWithWhereUniqueNestedInput!]
  delete: [BoundaryWhereUniqueInput!]
  connect: [BoundaryWhereUniqueInput!]
  set: [BoundaryWhereUniqueInput!]
  disconnect: [BoundaryWhereUniqueInput!]
  deleteMany: [BoundaryScalarWhereInput!]
  updateMany: [BoundaryUpdateManyWithWhereNestedInput!]
}

input BoundaryUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input BoundaryUpdateManyWithWhereNestedInput {
  where: BoundaryScalarWhereInput!
  data: BoundaryUpdateManyDataInput!
}

input BoundaryUpdateWithWhereUniqueNestedInput {
  where: BoundaryWhereUniqueInput!
  data: BoundaryUpdateDataInput!
}

input BoundaryUpsertWithWhereUniqueNestedInput {
  where: BoundaryWhereUniqueInput!
  update: BoundaryUpdateDataInput!
  create: BoundaryCreateInput!
}

input BoundaryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [BoundaryWhereInput!]
  OR: [BoundaryWhereInput!]
  NOT: [BoundaryWhereInput!]
}

input BoundaryWhereUniqueInput {
  id: ID
}

type Brain {
  id: ID!
  anger(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger!]
  fear(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear!]
  pride(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride!]
  selfPity(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity!]
}

type BrainConnection {
  pageInfo: PageInfo!
  edges: [BrainEdge]!
  aggregate: AggregateBrain!
}

input BrainCreateInput {
  id: ID
  anger: AngerCreateManyInput
  fear: FearCreateManyInput
  pride: PrideCreateManyInput
  selfPity: SelfPityCreateManyInput
}

input BrainCreateManyInput {
  create: [BrainCreateInput!]
  connect: [BrainWhereUniqueInput!]
}

type BrainEdge {
  node: Brain!
  cursor: String!
}

enum BrainOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BrainPreviousValues {
  id: ID!
}

input BrainScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [BrainScalarWhereInput!]
  OR: [BrainScalarWhereInput!]
  NOT: [BrainScalarWhereInput!]
}

type BrainSubscriptionPayload {
  mutation: MutationType!
  node: Brain
  updatedFields: [String!]
  previousValues: BrainPreviousValues
}

input BrainSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BrainWhereInput
  AND: [BrainSubscriptionWhereInput!]
  OR: [BrainSubscriptionWhereInput!]
  NOT: [BrainSubscriptionWhereInput!]
}

input BrainUpdateDataInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input BrainUpdateInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input BrainUpdateManyInput {
  create: [BrainCreateInput!]
  update: [BrainUpdateWithWhereUniqueNestedInput!]
  upsert: [BrainUpsertWithWhereUniqueNestedInput!]
  delete: [BrainWhereUniqueInput!]
  connect: [BrainWhereUniqueInput!]
  set: [BrainWhereUniqueInput!]
  disconnect: [BrainWhereUniqueInput!]
  deleteMany: [BrainScalarWhereInput!]
}

input BrainUpdateWithWhereUniqueNestedInput {
  where: BrainWhereUniqueInput!
  data: BrainUpdateDataInput!
}

input BrainUpsertWithWhereUniqueNestedInput {
  where: BrainWhereUniqueInput!
  update: BrainUpdateDataInput!
  create: BrainCreateInput!
}

input BrainWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  anger_every: AngerWhereInput
  anger_some: AngerWhereInput
  anger_none: AngerWhereInput
  fear_every: FearWhereInput
  fear_some: FearWhereInput
  fear_none: FearWhereInput
  pride_every: PrideWhereInput
  pride_some: PrideWhereInput
  pride_none: PrideWhereInput
  selfPity_every: SelfPityWhereInput
  selfPity_some: SelfPityWhereInput
  selfPity_none: SelfPityWhereInput
  AND: [BrainWhereInput!]
  OR: [BrainWhereInput!]
  NOT: [BrainWhereInput!]
}

input BrainWhereUniqueInput {
  id: ID
}

type Campaign {
  id: ID!
  loyalty(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Loyalty!]
  honor(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Honor!]
}

type CampaignConnection {
  pageInfo: PageInfo!
  edges: [CampaignEdge]!
  aggregate: AggregateCampaign!
}

input CampaignCreateInput {
  id: ID
  loyalty: LoyaltyCreateManyInput
  honor: HonorCreateManyInput
}

input CampaignCreateManyInput {
  create: [CampaignCreateInput!]
  connect: [CampaignWhereUniqueInput!]
}

type CampaignEdge {
  node: Campaign!
  cursor: String!
}

enum CampaignOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CampaignPreviousValues {
  id: ID!
}

input CampaignScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [CampaignScalarWhereInput!]
  OR: [CampaignScalarWhereInput!]
  NOT: [CampaignScalarWhereInput!]
}

type CampaignSubscriptionPayload {
  mutation: MutationType!
  node: Campaign
  updatedFields: [String!]
  previousValues: CampaignPreviousValues
}

input CampaignSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CampaignWhereInput
  AND: [CampaignSubscriptionWhereInput!]
  OR: [CampaignSubscriptionWhereInput!]
  NOT: [CampaignSubscriptionWhereInput!]
}

input CampaignUpdateDataInput {
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
}

input CampaignUpdateInput {
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
}

input CampaignUpdateManyInput {
  create: [CampaignCreateInput!]
  update: [CampaignUpdateWithWhereUniqueNestedInput!]
  upsert: [CampaignUpsertWithWhereUniqueNestedInput!]
  delete: [CampaignWhereUniqueInput!]
  connect: [CampaignWhereUniqueInput!]
  set: [CampaignWhereUniqueInput!]
  disconnect: [CampaignWhereUniqueInput!]
  deleteMany: [CampaignScalarWhereInput!]
}

input CampaignUpdateWithWhereUniqueNestedInput {
  where: CampaignWhereUniqueInput!
  data: CampaignUpdateDataInput!
}

input CampaignUpsertWithWhereUniqueNestedInput {
  where: CampaignWhereUniqueInput!
  update: CampaignUpdateDataInput!
  create: CampaignCreateInput!
}

input CampaignWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  loyalty_every: LoyaltyWhereInput
  loyalty_some: LoyaltyWhereInput
  loyalty_none: LoyaltyWhereInput
  honor_every: HonorWhereInput
  honor_some: HonorWhereInput
  honor_none: HonorWhereInput
  AND: [CampaignWhereInput!]
  OR: [CampaignWhereInput!]
  NOT: [CampaignWhereInput!]
}

input CampaignWhereUniqueInput {
  id: ID
}

type Characters {
  id: ID!
  congregant: Congregant
  genie: Genie
  guardian: Guardian
  martyr: Martyr
  paladin: Paladin
  seeker: Seeker
  self: Self
  smith: Smith
  summoner: Summoner
  victim: Victim
  volunteer: Volunteer
}

type CharactersConnection {
  pageInfo: PageInfo!
  edges: [CharactersEdge]!
  aggregate: AggregateCharacters!
}

input CharactersCreateInput {
  id: ID
  congregant: CongregantCreateOneInput
  genie: GenieCreateOneInput
  guardian: GuardianCreateOneInput
  martyr: MartyrCreateOneInput
  paladin: PaladinCreateOneInput
  seeker: SeekerCreateOneInput
  self: SelfCreateOneInput
  smith: SmithCreateOneInput
  summoner: SummonerCreateOneInput
  victim: VictimCreateOneInput
  volunteer: VolunteerCreateOneInput
}

input CharactersCreateOneInput {
  create: CharactersCreateInput
  connect: CharactersWhereUniqueInput
}

type CharactersEdge {
  node: Characters!
  cursor: String!
}

enum CharactersOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CharactersPreviousValues {
  id: ID!
}

type CharactersSubscriptionPayload {
  mutation: MutationType!
  node: Characters
  updatedFields: [String!]
  previousValues: CharactersPreviousValues
}

input CharactersSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CharactersWhereInput
  AND: [CharactersSubscriptionWhereInput!]
  OR: [CharactersSubscriptionWhereInput!]
  NOT: [CharactersSubscriptionWhereInput!]
}

input CharactersUpdateDataInput {
  congregant: CongregantUpdateOneInput
  genie: GenieUpdateOneInput
  guardian: GuardianUpdateOneInput
  martyr: MartyrUpdateOneInput
  paladin: PaladinUpdateOneInput
  seeker: SeekerUpdateOneInput
  self: SelfUpdateOneInput
  smith: SmithUpdateOneInput
  summoner: SummonerUpdateOneInput
  victim: VictimUpdateOneInput
  volunteer: VolunteerUpdateOneInput
}

input CharactersUpdateInput {
  congregant: CongregantUpdateOneInput
  genie: GenieUpdateOneInput
  guardian: GuardianUpdateOneInput
  martyr: MartyrUpdateOneInput
  paladin: PaladinUpdateOneInput
  seeker: SeekerUpdateOneInput
  self: SelfUpdateOneInput
  smith: SmithUpdateOneInput
  summoner: SummonerUpdateOneInput
  victim: VictimUpdateOneInput
  volunteer: VolunteerUpdateOneInput
}

input CharactersUpdateOneInput {
  create: CharactersCreateInput
  update: CharactersUpdateDataInput
  upsert: CharactersUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CharactersWhereUniqueInput
}

input CharactersUpsertNestedInput {
  update: CharactersUpdateDataInput!
  create: CharactersCreateInput!
}

input CharactersWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  congregant: CongregantWhereInput
  genie: GenieWhereInput
  guardian: GuardianWhereInput
  martyr: MartyrWhereInput
  paladin: PaladinWhereInput
  seeker: SeekerWhereInput
  self: SelfWhereInput
  smith: SmithWhereInput
  summoner: SummonerWhereInput
  victim: VictimWhereInput
  volunteer: VolunteerWhereInput
  AND: [CharactersWhereInput!]
  OR: [CharactersWhereInput!]
  NOT: [CharactersWhereInput!]
}

input CharactersWhereUniqueInput {
  id: ID
}

type Compassion {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type CompassionConnection {
  pageInfo: PageInfo!
  edges: [CompassionEdge]!
  aggregate: AggregateCompassion!
}

input CompassionCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CompassionCreateManyInput {
  create: [CompassionCreateInput!]
  connect: [CompassionWhereUniqueInput!]
}

type CompassionEdge {
  node: Compassion!
  cursor: String!
}

enum CompassionOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type CompassionPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CompassionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [CompassionScalarWhereInput!]
  OR: [CompassionScalarWhereInput!]
  NOT: [CompassionScalarWhereInput!]
}

type CompassionSubscriptionPayload {
  mutation: MutationType!
  node: Compassion
  updatedFields: [String!]
  previousValues: CompassionPreviousValues
}

input CompassionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompassionWhereInput
  AND: [CompassionSubscriptionWhereInput!]
  OR: [CompassionSubscriptionWhereInput!]
  NOT: [CompassionSubscriptionWhereInput!]
}

input CompassionUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CompassionUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CompassionUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CompassionUpdateManyInput {
  create: [CompassionCreateInput!]
  update: [CompassionUpdateWithWhereUniqueNestedInput!]
  upsert: [CompassionUpsertWithWhereUniqueNestedInput!]
  delete: [CompassionWhereUniqueInput!]
  connect: [CompassionWhereUniqueInput!]
  set: [CompassionWhereUniqueInput!]
  disconnect: [CompassionWhereUniqueInput!]
  deleteMany: [CompassionScalarWhereInput!]
  updateMany: [CompassionUpdateManyWithWhereNestedInput!]
}

input CompassionUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CompassionUpdateManyWithWhereNestedInput {
  where: CompassionScalarWhereInput!
  data: CompassionUpdateManyDataInput!
}

input CompassionUpdateWithWhereUniqueNestedInput {
  where: CompassionWhereUniqueInput!
  data: CompassionUpdateDataInput!
}

input CompassionUpsertWithWhereUniqueNestedInput {
  where: CompassionWhereUniqueInput!
  update: CompassionUpdateDataInput!
  create: CompassionCreateInput!
}

input CompassionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [CompassionWhereInput!]
  OR: [CompassionWhereInput!]
  NOT: [CompassionWhereInput!]
}

input CompassionWhereUniqueInput {
  id: ID
}

type Confusion {
  id: ID!
  armor(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Armor!]
}

type ConfusionConnection {
  pageInfo: PageInfo!
  edges: [ConfusionEdge]!
  aggregate: AggregateConfusion!
}

input ConfusionCreateInput {
  id: ID
  armor: ArmorCreateManyInput
}

input ConfusionCreateManyInput {
  create: [ConfusionCreateInput!]
  connect: [ConfusionWhereUniqueInput!]
}

type ConfusionEdge {
  node: Confusion!
  cursor: String!
}

enum ConfusionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ConfusionPreviousValues {
  id: ID!
}

input ConfusionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ConfusionScalarWhereInput!]
  OR: [ConfusionScalarWhereInput!]
  NOT: [ConfusionScalarWhereInput!]
}

type ConfusionSubscriptionPayload {
  mutation: MutationType!
  node: Confusion
  updatedFields: [String!]
  previousValues: ConfusionPreviousValues
}

input ConfusionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConfusionWhereInput
  AND: [ConfusionSubscriptionWhereInput!]
  OR: [ConfusionSubscriptionWhereInput!]
  NOT: [ConfusionSubscriptionWhereInput!]
}

input ConfusionUpdateDataInput {
  armor: ArmorUpdateManyInput
}

input ConfusionUpdateInput {
  armor: ArmorUpdateManyInput
}

input ConfusionUpdateManyInput {
  create: [ConfusionCreateInput!]
  update: [ConfusionUpdateWithWhereUniqueNestedInput!]
  upsert: [ConfusionUpsertWithWhereUniqueNestedInput!]
  delete: [ConfusionWhereUniqueInput!]
  connect: [ConfusionWhereUniqueInput!]
  set: [ConfusionWhereUniqueInput!]
  disconnect: [ConfusionWhereUniqueInput!]
  deleteMany: [ConfusionScalarWhereInput!]
}

input ConfusionUpdateWithWhereUniqueNestedInput {
  where: ConfusionWhereUniqueInput!
  data: ConfusionUpdateDataInput!
}

input ConfusionUpsertWithWhereUniqueNestedInput {
  where: ConfusionWhereUniqueInput!
  update: ConfusionUpdateDataInput!
  create: ConfusionCreateInput!
}

input ConfusionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  armor_every: ArmorWhereInput
  armor_some: ArmorWhereInput
  armor_none: ArmorWhereInput
  AND: [ConfusionWhereInput!]
  OR: [ConfusionWhereInput!]
  NOT: [ConfusionWhereInput!]
}

input ConfusionWhereUniqueInput {
  id: ID
}

type Congregant {
  id: ID!
}

type CongregantConnection {
  pageInfo: PageInfo!
  edges: [CongregantEdge]!
  aggregate: AggregateCongregant!
}

input CongregantCreateInput {
  id: ID
}

input CongregantCreateOneInput {
  create: CongregantCreateInput
  connect: CongregantWhereUniqueInput
}

type CongregantEdge {
  node: Congregant!
  cursor: String!
}

enum CongregantOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CongregantPreviousValues {
  id: ID!
}

type CongregantSubscriptionPayload {
  mutation: MutationType!
  node: Congregant
  updatedFields: [String!]
  previousValues: CongregantPreviousValues
}

input CongregantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CongregantWhereInput
  AND: [CongregantSubscriptionWhereInput!]
  OR: [CongregantSubscriptionWhereInput!]
  NOT: [CongregantSubscriptionWhereInput!]
}

input CongregantUpdateOneInput {
  create: CongregantCreateInput
  delete: Boolean
  disconnect: Boolean
  connect: CongregantWhereUniqueInput
}

input CongregantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [CongregantWhereInput!]
  OR: [CongregantWhereInput!]
  NOT: [CongregantWhereInput!]
}

input CongregantWhereUniqueInput {
  id: ID
}

type Construct {
  id: ID!
  gate(where: GateWhereInput, orderBy: GateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gate!]
  tower(where: TowerWhereInput, orderBy: TowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tower!]
  wall(where: WallWhereInput, orderBy: WallOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Wall!]
}

type ConstructConnection {
  pageInfo: PageInfo!
  edges: [ConstructEdge]!
  aggregate: AggregateConstruct!
}

input ConstructCreateInput {
  id: ID
  gate: GateCreateManyInput
  tower: TowerCreateManyInput
  wall: WallCreateManyInput
}

input ConstructCreateManyInput {
  create: [ConstructCreateInput!]
  connect: [ConstructWhereUniqueInput!]
}

input ConstructCreateOneInput {
  create: ConstructCreateInput
  connect: ConstructWhereUniqueInput
}

type ConstructEdge {
  node: Construct!
  cursor: String!
}

enum ConstructOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ConstructPreviousValues {
  id: ID!
}

input ConstructScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ConstructScalarWhereInput!]
  OR: [ConstructScalarWhereInput!]
  NOT: [ConstructScalarWhereInput!]
}

type ConstructSubscriptionPayload {
  mutation: MutationType!
  node: Construct
  updatedFields: [String!]
  previousValues: ConstructPreviousValues
}

input ConstructSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ConstructWhereInput
  AND: [ConstructSubscriptionWhereInput!]
  OR: [ConstructSubscriptionWhereInput!]
  NOT: [ConstructSubscriptionWhereInput!]
}

input ConstructUpdateDataInput {
  gate: GateUpdateManyInput
  tower: TowerUpdateManyInput
  wall: WallUpdateManyInput
}

input ConstructUpdateInput {
  gate: GateUpdateManyInput
  tower: TowerUpdateManyInput
  wall: WallUpdateManyInput
}

input ConstructUpdateManyInput {
  create: [ConstructCreateInput!]
  update: [ConstructUpdateWithWhereUniqueNestedInput!]
  upsert: [ConstructUpsertWithWhereUniqueNestedInput!]
  delete: [ConstructWhereUniqueInput!]
  connect: [ConstructWhereUniqueInput!]
  set: [ConstructWhereUniqueInput!]
  disconnect: [ConstructWhereUniqueInput!]
  deleteMany: [ConstructScalarWhereInput!]
}

input ConstructUpdateOneInput {
  create: ConstructCreateInput
  update: ConstructUpdateDataInput
  upsert: ConstructUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ConstructWhereUniqueInput
}

input ConstructUpdateWithWhereUniqueNestedInput {
  where: ConstructWhereUniqueInput!
  data: ConstructUpdateDataInput!
}

input ConstructUpsertNestedInput {
  update: ConstructUpdateDataInput!
  create: ConstructCreateInput!
}

input ConstructUpsertWithWhereUniqueNestedInput {
  where: ConstructWhereUniqueInput!
  update: ConstructUpdateDataInput!
  create: ConstructCreateInput!
}

input ConstructWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  gate_every: GateWhereInput
  gate_some: GateWhereInput
  gate_none: GateWhereInput
  tower_every: TowerWhereInput
  tower_some: TowerWhereInput
  tower_none: TowerWhereInput
  wall_every: WallWhereInput
  wall_some: WallWhereInput
  wall_none: WallWhereInput
  AND: [ConstructWhereInput!]
  OR: [ConstructWhereInput!]
  NOT: [ConstructWhereInput!]
}

input ConstructWhereUniqueInput {
  id: ID
}

type Courage {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type CourageConnection {
  pageInfo: PageInfo!
  edges: [CourageEdge]!
  aggregate: AggregateCourage!
}

input CourageCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CourageCreateManyInput {
  create: [CourageCreateInput!]
  connect: [CourageWhereUniqueInput!]
}

type CourageEdge {
  node: Courage!
  cursor: String!
}

enum CourageOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type CouragePreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CourageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [CourageScalarWhereInput!]
  OR: [CourageScalarWhereInput!]
  NOT: [CourageScalarWhereInput!]
}

type CourageSubscriptionPayload {
  mutation: MutationType!
  node: Courage
  updatedFields: [String!]
  previousValues: CouragePreviousValues
}

input CourageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourageWhereInput
  AND: [CourageSubscriptionWhereInput!]
  OR: [CourageSubscriptionWhereInput!]
  NOT: [CourageSubscriptionWhereInput!]
}

input CourageUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CourageUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CourageUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CourageUpdateManyInput {
  create: [CourageCreateInput!]
  update: [CourageUpdateWithWhereUniqueNestedInput!]
  upsert: [CourageUpsertWithWhereUniqueNestedInput!]
  delete: [CourageWhereUniqueInput!]
  connect: [CourageWhereUniqueInput!]
  set: [CourageWhereUniqueInput!]
  disconnect: [CourageWhereUniqueInput!]
  deleteMany: [CourageScalarWhereInput!]
  updateMany: [CourageUpdateManyWithWhereNestedInput!]
}

input CourageUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CourageUpdateManyWithWhereNestedInput {
  where: CourageScalarWhereInput!
  data: CourageUpdateManyDataInput!
}

input CourageUpdateWithWhereUniqueNestedInput {
  where: CourageWhereUniqueInput!
  data: CourageUpdateDataInput!
}

input CourageUpsertWithWhereUniqueNestedInput {
  where: CourageWhereUniqueInput!
  update: CourageUpdateDataInput!
  create: CourageCreateInput!
}

input CourageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [CourageWhereInput!]
  OR: [CourageWhereInput!]
  NOT: [CourageWhereInput!]
}

input CourageWhereUniqueInput {
  id: ID
}

type Cross {
  id: ID!
  suffering(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering!]
}

type CrossConnection {
  pageInfo: PageInfo!
  edges: [CrossEdge]!
  aggregate: AggregateCross!
}

input CrossCreateInput {
  id: ID
  suffering: SufferingCreateManyInput
}

input CrossCreateManyInput {
  create: [CrossCreateInput!]
  connect: [CrossWhereUniqueInput!]
}

type CrossEdge {
  node: Cross!
  cursor: String!
}

enum CrossOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CrossPreviousValues {
  id: ID!
}

input CrossScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [CrossScalarWhereInput!]
  OR: [CrossScalarWhereInput!]
  NOT: [CrossScalarWhereInput!]
}

type CrossSubscriptionPayload {
  mutation: MutationType!
  node: Cross
  updatedFields: [String!]
  previousValues: CrossPreviousValues
}

input CrossSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CrossWhereInput
  AND: [CrossSubscriptionWhereInput!]
  OR: [CrossSubscriptionWhereInput!]
  NOT: [CrossSubscriptionWhereInput!]
}

input CrossUpdateDataInput {
  suffering: SufferingUpdateManyInput
}

input CrossUpdateInput {
  suffering: SufferingUpdateManyInput
}

input CrossUpdateManyInput {
  create: [CrossCreateInput!]
  update: [CrossUpdateWithWhereUniqueNestedInput!]
  upsert: [CrossUpsertWithWhereUniqueNestedInput!]
  delete: [CrossWhereUniqueInput!]
  connect: [CrossWhereUniqueInput!]
  set: [CrossWhereUniqueInput!]
  disconnect: [CrossWhereUniqueInput!]
  deleteMany: [CrossScalarWhereInput!]
}

input CrossUpdateWithWhereUniqueNestedInput {
  where: CrossWhereUniqueInput!
  data: CrossUpdateDataInput!
}

input CrossUpsertWithWhereUniqueNestedInput {
  where: CrossWhereUniqueInput!
  update: CrossUpdateDataInput!
  create: CrossCreateInput!
}

input CrossWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  suffering_every: SufferingWhereInput
  suffering_some: SufferingWhereInput
  suffering_none: SufferingWhereInput
  AND: [CrossWhereInput!]
  OR: [CrossWhereInput!]
  NOT: [CrossWhereInput!]
}

input CrossWhereUniqueInput {
  id: ID
}

type Crown {
  id: ID!
  suffering(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering!]
}

type CrownConnection {
  pageInfo: PageInfo!
  edges: [CrownEdge]!
  aggregate: AggregateCrown!
}

input CrownCreateInput {
  id: ID
  suffering: SufferingCreateManyInput
}

input CrownCreateManyInput {
  create: [CrownCreateInput!]
  connect: [CrownWhereUniqueInput!]
}

type CrownEdge {
  node: Crown!
  cursor: String!
}

enum CrownOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CrownPreviousValues {
  id: ID!
}

input CrownScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [CrownScalarWhereInput!]
  OR: [CrownScalarWhereInput!]
  NOT: [CrownScalarWhereInput!]
}

type CrownSubscriptionPayload {
  mutation: MutationType!
  node: Crown
  updatedFields: [String!]
  previousValues: CrownPreviousValues
}

input CrownSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CrownWhereInput
  AND: [CrownSubscriptionWhereInput!]
  OR: [CrownSubscriptionWhereInput!]
  NOT: [CrownSubscriptionWhereInput!]
}

input CrownUpdateDataInput {
  suffering: SufferingUpdateManyInput
}

input CrownUpdateInput {
  suffering: SufferingUpdateManyInput
}

input CrownUpdateManyInput {
  create: [CrownCreateInput!]
  update: [CrownUpdateWithWhereUniqueNestedInput!]
  upsert: [CrownUpsertWithWhereUniqueNestedInput!]
  delete: [CrownWhereUniqueInput!]
  connect: [CrownWhereUniqueInput!]
  set: [CrownWhereUniqueInput!]
  disconnect: [CrownWhereUniqueInput!]
  deleteMany: [CrownScalarWhereInput!]
}

input CrownUpdateWithWhereUniqueNestedInput {
  where: CrownWhereUniqueInput!
  data: CrownUpdateDataInput!
}

input CrownUpsertWithWhereUniqueNestedInput {
  where: CrownWhereUniqueInput!
  update: CrownUpdateDataInput!
  create: CrownCreateInput!
}

input CrownWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  suffering_every: SufferingWhereInput
  suffering_some: SufferingWhereInput
  suffering_none: SufferingWhereInput
  AND: [CrownWhereInput!]
  OR: [CrownWhereInput!]
  NOT: [CrownWhereInput!]
}

input CrownWhereUniqueInput {
  id: ID
}

type Crusade {
  id: ID!
  loyalty(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Loyalty!]
  honor(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Honor!]
}

type CrusadeConnection {
  pageInfo: PageInfo!
  edges: [CrusadeEdge]!
  aggregate: AggregateCrusade!
}

input CrusadeCreateInput {
  id: ID
  loyalty: LoyaltyCreateManyInput
  honor: HonorCreateManyInput
}

input CrusadeCreateManyInput {
  create: [CrusadeCreateInput!]
  connect: [CrusadeWhereUniqueInput!]
}

type CrusadeEdge {
  node: Crusade!
  cursor: String!
}

enum CrusadeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CrusadePreviousValues {
  id: ID!
}

input CrusadeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [CrusadeScalarWhereInput!]
  OR: [CrusadeScalarWhereInput!]
  NOT: [CrusadeScalarWhereInput!]
}

type CrusadeSubscriptionPayload {
  mutation: MutationType!
  node: Crusade
  updatedFields: [String!]
  previousValues: CrusadePreviousValues
}

input CrusadeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CrusadeWhereInput
  AND: [CrusadeSubscriptionWhereInput!]
  OR: [CrusadeSubscriptionWhereInput!]
  NOT: [CrusadeSubscriptionWhereInput!]
}

input CrusadeUpdateDataInput {
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
}

input CrusadeUpdateInput {
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
}

input CrusadeUpdateManyInput {
  create: [CrusadeCreateInput!]
  update: [CrusadeUpdateWithWhereUniqueNestedInput!]
  upsert: [CrusadeUpsertWithWhereUniqueNestedInput!]
  delete: [CrusadeWhereUniqueInput!]
  connect: [CrusadeWhereUniqueInput!]
  set: [CrusadeWhereUniqueInput!]
  disconnect: [CrusadeWhereUniqueInput!]
  deleteMany: [CrusadeScalarWhereInput!]
}

input CrusadeUpdateWithWhereUniqueNestedInput {
  where: CrusadeWhereUniqueInput!
  data: CrusadeUpdateDataInput!
}

input CrusadeUpsertWithWhereUniqueNestedInput {
  where: CrusadeWhereUniqueInput!
  update: CrusadeUpdateDataInput!
  create: CrusadeCreateInput!
}

input CrusadeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  loyalty_every: LoyaltyWhereInput
  loyalty_some: LoyaltyWhereInput
  loyalty_none: LoyaltyWhereInput
  honor_every: HonorWhereInput
  honor_some: HonorWhereInput
  honor_none: HonorWhereInput
  AND: [CrusadeWhereInput!]
  OR: [CrusadeWhereInput!]
  NOT: [CrusadeWhereInput!]
}

input CrusadeWhereUniqueInput {
  id: ID
}

scalar DateTime

type Defect {
  id: ID!
  trauma(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma!]
  toxicity(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity!]
  suffering(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering!]
}

type DefectConnection {
  pageInfo: PageInfo!
  edges: [DefectEdge]!
  aggregate: AggregateDefect!
}

input DefectCreateInput {
  id: ID
  trauma: TraumaCreateManyInput
  toxicity: ToxicityCreateManyInput
  suffering: SufferingCreateManyInput
}

input DefectCreateManyInput {
  create: [DefectCreateInput!]
  connect: [DefectWhereUniqueInput!]
}

input DefectCreateOneInput {
  create: DefectCreateInput
  connect: DefectWhereUniqueInput
}

type DefectEdge {
  node: Defect!
  cursor: String!
}

enum DefectOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DefectPreviousValues {
  id: ID!
}

input DefectScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [DefectScalarWhereInput!]
  OR: [DefectScalarWhereInput!]
  NOT: [DefectScalarWhereInput!]
}

type DefectSubscriptionPayload {
  mutation: MutationType!
  node: Defect
  updatedFields: [String!]
  previousValues: DefectPreviousValues
}

input DefectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DefectWhereInput
  AND: [DefectSubscriptionWhereInput!]
  OR: [DefectSubscriptionWhereInput!]
  NOT: [DefectSubscriptionWhereInput!]
}

input DefectUpdateDataInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
  suffering: SufferingUpdateManyInput
}

input DefectUpdateInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
  suffering: SufferingUpdateManyInput
}

input DefectUpdateManyInput {
  create: [DefectCreateInput!]
  update: [DefectUpdateWithWhereUniqueNestedInput!]
  upsert: [DefectUpsertWithWhereUniqueNestedInput!]
  delete: [DefectWhereUniqueInput!]
  connect: [DefectWhereUniqueInput!]
  set: [DefectWhereUniqueInput!]
  disconnect: [DefectWhereUniqueInput!]
  deleteMany: [DefectScalarWhereInput!]
}

input DefectUpdateOneInput {
  create: DefectCreateInput
  update: DefectUpdateDataInput
  upsert: DefectUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DefectWhereUniqueInput
}

input DefectUpdateWithWhereUniqueNestedInput {
  where: DefectWhereUniqueInput!
  data: DefectUpdateDataInput!
}

input DefectUpsertNestedInput {
  update: DefectUpdateDataInput!
  create: DefectCreateInput!
}

input DefectUpsertWithWhereUniqueNestedInput {
  where: DefectWhereUniqueInput!
  update: DefectUpdateDataInput!
  create: DefectCreateInput!
}

input DefectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  trauma_every: TraumaWhereInput
  trauma_some: TraumaWhereInput
  trauma_none: TraumaWhereInput
  toxicity_every: ToxicityWhereInput
  toxicity_some: ToxicityWhereInput
  toxicity_none: ToxicityWhereInput
  suffering_every: SufferingWhereInput
  suffering_some: SufferingWhereInput
  suffering_none: SufferingWhereInput
  AND: [DefectWhereInput!]
  OR: [DefectWhereInput!]
  NOT: [DefectWhereInput!]
}

input DefectWhereUniqueInput {
  id: ID
}

type Delirium {
  id: ID!
  trauma(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma!]
  toxicity(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity!]
}

type DeliriumConnection {
  pageInfo: PageInfo!
  edges: [DeliriumEdge]!
  aggregate: AggregateDelirium!
}

input DeliriumCreateInput {
  id: ID
  trauma: TraumaCreateManyInput
  toxicity: ToxicityCreateManyInput
}

input DeliriumCreateManyInput {
  create: [DeliriumCreateInput!]
  connect: [DeliriumWhereUniqueInput!]
}

type DeliriumEdge {
  node: Delirium!
  cursor: String!
}

enum DeliriumOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DeliriumPreviousValues {
  id: ID!
}

input DeliriumScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [DeliriumScalarWhereInput!]
  OR: [DeliriumScalarWhereInput!]
  NOT: [DeliriumScalarWhereInput!]
}

type DeliriumSubscriptionPayload {
  mutation: MutationType!
  node: Delirium
  updatedFields: [String!]
  previousValues: DeliriumPreviousValues
}

input DeliriumSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DeliriumWhereInput
  AND: [DeliriumSubscriptionWhereInput!]
  OR: [DeliriumSubscriptionWhereInput!]
  NOT: [DeliriumSubscriptionWhereInput!]
}

input DeliriumUpdateDataInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input DeliriumUpdateInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input DeliriumUpdateManyInput {
  create: [DeliriumCreateInput!]
  update: [DeliriumUpdateWithWhereUniqueNestedInput!]
  upsert: [DeliriumUpsertWithWhereUniqueNestedInput!]
  delete: [DeliriumWhereUniqueInput!]
  connect: [DeliriumWhereUniqueInput!]
  set: [DeliriumWhereUniqueInput!]
  disconnect: [DeliriumWhereUniqueInput!]
  deleteMany: [DeliriumScalarWhereInput!]
}

input DeliriumUpdateWithWhereUniqueNestedInput {
  where: DeliriumWhereUniqueInput!
  data: DeliriumUpdateDataInput!
}

input DeliriumUpsertWithWhereUniqueNestedInput {
  where: DeliriumWhereUniqueInput!
  update: DeliriumUpdateDataInput!
  create: DeliriumCreateInput!
}

input DeliriumWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  trauma_every: TraumaWhereInput
  trauma_some: TraumaWhereInput
  trauma_none: TraumaWhereInput
  toxicity_every: ToxicityWhereInput
  toxicity_some: ToxicityWhereInput
  toxicity_none: ToxicityWhereInput
  AND: [DeliriumWhereInput!]
  OR: [DeliriumWhereInput!]
  NOT: [DeliriumWhereInput!]
}

input DeliriumWhereUniqueInput {
  id: ID
}

type Denial {
  id: ID!
  armor(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Armor!]
}

type DenialConnection {
  pageInfo: PageInfo!
  edges: [DenialEdge]!
  aggregate: AggregateDenial!
}

input DenialCreateInput {
  id: ID
  armor: ArmorCreateManyInput
}

input DenialCreateManyInput {
  create: [DenialCreateInput!]
  connect: [DenialWhereUniqueInput!]
}

type DenialEdge {
  node: Denial!
  cursor: String!
}

enum DenialOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DenialPreviousValues {
  id: ID!
}

input DenialScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [DenialScalarWhereInput!]
  OR: [DenialScalarWhereInput!]
  NOT: [DenialScalarWhereInput!]
}

type DenialSubscriptionPayload {
  mutation: MutationType!
  node: Denial
  updatedFields: [String!]
  previousValues: DenialPreviousValues
}

input DenialSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DenialWhereInput
  AND: [DenialSubscriptionWhereInput!]
  OR: [DenialSubscriptionWhereInput!]
  NOT: [DenialSubscriptionWhereInput!]
}

input DenialUpdateDataInput {
  armor: ArmorUpdateManyInput
}

input DenialUpdateInput {
  armor: ArmorUpdateManyInput
}

input DenialUpdateManyInput {
  create: [DenialCreateInput!]
  update: [DenialUpdateWithWhereUniqueNestedInput!]
  upsert: [DenialUpsertWithWhereUniqueNestedInput!]
  delete: [DenialWhereUniqueInput!]
  connect: [DenialWhereUniqueInput!]
  set: [DenialWhereUniqueInput!]
  disconnect: [DenialWhereUniqueInput!]
  deleteMany: [DenialScalarWhereInput!]
}

input DenialUpdateWithWhereUniqueNestedInput {
  where: DenialWhereUniqueInput!
  data: DenialUpdateDataInput!
}

input DenialUpsertWithWhereUniqueNestedInput {
  where: DenialWhereUniqueInput!
  update: DenialUpdateDataInput!
  create: DenialCreateInput!
}

input DenialWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  armor_every: ArmorWhereInput
  armor_some: ArmorWhereInput
  armor_none: ArmorWhereInput
  AND: [DenialWhereInput!]
  OR: [DenialWhereInput!]
  NOT: [DenialWhereInput!]
}

input DenialWhereUniqueInput {
  id: ID
}

type Discontent {
  id: ID!
  irritability(where: IrritabilityWhereInput, orderBy: IrritabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Irritability!]
  impatience(where: ImpatienceWhereInput, orderBy: ImpatienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Impatience!]
}

type DiscontentConnection {
  pageInfo: PageInfo!
  edges: [DiscontentEdge]!
  aggregate: AggregateDiscontent!
}

input DiscontentCreateInput {
  id: ID
  irritability: IrritabilityCreateManyInput
  impatience: ImpatienceCreateManyInput
}

input DiscontentCreateManyInput {
  create: [DiscontentCreateInput!]
  connect: [DiscontentWhereUniqueInput!]
}

input DiscontentCreateOneInput {
  create: DiscontentCreateInput
  connect: DiscontentWhereUniqueInput
}

type DiscontentEdge {
  node: Discontent!
  cursor: String!
}

enum DiscontentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DiscontentPreviousValues {
  id: ID!
}

input DiscontentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [DiscontentScalarWhereInput!]
  OR: [DiscontentScalarWhereInput!]
  NOT: [DiscontentScalarWhereInput!]
}

type DiscontentSubscriptionPayload {
  mutation: MutationType!
  node: Discontent
  updatedFields: [String!]
  previousValues: DiscontentPreviousValues
}

input DiscontentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DiscontentWhereInput
  AND: [DiscontentSubscriptionWhereInput!]
  OR: [DiscontentSubscriptionWhereInput!]
  NOT: [DiscontentSubscriptionWhereInput!]
}

input DiscontentUpdateDataInput {
  irritability: IrritabilityUpdateManyInput
  impatience: ImpatienceUpdateManyInput
}

input DiscontentUpdateInput {
  irritability: IrritabilityUpdateManyInput
  impatience: ImpatienceUpdateManyInput
}

input DiscontentUpdateManyInput {
  create: [DiscontentCreateInput!]
  update: [DiscontentUpdateWithWhereUniqueNestedInput!]
  upsert: [DiscontentUpsertWithWhereUniqueNestedInput!]
  delete: [DiscontentWhereUniqueInput!]
  connect: [DiscontentWhereUniqueInput!]
  set: [DiscontentWhereUniqueInput!]
  disconnect: [DiscontentWhereUniqueInput!]
  deleteMany: [DiscontentScalarWhereInput!]
}

input DiscontentUpdateOneInput {
  create: DiscontentCreateInput
  update: DiscontentUpdateDataInput
  upsert: DiscontentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DiscontentWhereUniqueInput
}

input DiscontentUpdateWithWhereUniqueNestedInput {
  where: DiscontentWhereUniqueInput!
  data: DiscontentUpdateDataInput!
}

input DiscontentUpsertNestedInput {
  update: DiscontentUpdateDataInput!
  create: DiscontentCreateInput!
}

input DiscontentUpsertWithWhereUniqueNestedInput {
  where: DiscontentWhereUniqueInput!
  update: DiscontentUpdateDataInput!
  create: DiscontentCreateInput!
}

input DiscontentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  irritability_every: IrritabilityWhereInput
  irritability_some: IrritabilityWhereInput
  irritability_none: IrritabilityWhereInput
  impatience_every: ImpatienceWhereInput
  impatience_some: ImpatienceWhereInput
  impatience_none: ImpatienceWhereInput
  AND: [DiscontentWhereInput!]
  OR: [DiscontentWhereInput!]
  NOT: [DiscontentWhereInput!]
}

input DiscontentWhereUniqueInput {
  id: ID
}

type Dream {
  id: ID!
  salvation(where: SalvationWhereInput, orderBy: SalvationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Salvation!]
}

type DreamConnection {
  pageInfo: PageInfo!
  edges: [DreamEdge]!
  aggregate: AggregateDream!
}

input DreamCreateInput {
  id: ID
  salvation: SalvationCreateManyInput
}

input DreamCreateManyInput {
  create: [DreamCreateInput!]
  connect: [DreamWhereUniqueInput!]
}

type DreamEdge {
  node: Dream!
  cursor: String!
}

enum DreamOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DreamPreviousValues {
  id: ID!
}

input DreamScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [DreamScalarWhereInput!]
  OR: [DreamScalarWhereInput!]
  NOT: [DreamScalarWhereInput!]
}

type DreamSubscriptionPayload {
  mutation: MutationType!
  node: Dream
  updatedFields: [String!]
  previousValues: DreamPreviousValues
}

input DreamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DreamWhereInput
  AND: [DreamSubscriptionWhereInput!]
  OR: [DreamSubscriptionWhereInput!]
  NOT: [DreamSubscriptionWhereInput!]
}

input DreamUpdateDataInput {
  salvation: SalvationUpdateManyInput
}

input DreamUpdateInput {
  salvation: SalvationUpdateManyInput
}

input DreamUpdateManyInput {
  create: [DreamCreateInput!]
  update: [DreamUpdateWithWhereUniqueNestedInput!]
  upsert: [DreamUpsertWithWhereUniqueNestedInput!]
  delete: [DreamWhereUniqueInput!]
  connect: [DreamWhereUniqueInput!]
  set: [DreamWhereUniqueInput!]
  disconnect: [DreamWhereUniqueInput!]
  deleteMany: [DreamScalarWhereInput!]
}

input DreamUpdateWithWhereUniqueNestedInput {
  where: DreamWhereUniqueInput!
  data: DreamUpdateDataInput!
}

input DreamUpsertWithWhereUniqueNestedInput {
  where: DreamWhereUniqueInput!
  update: DreamUpdateDataInput!
  create: DreamCreateInput!
}

input DreamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  salvation_every: SalvationWhereInput
  salvation_some: SalvationWhereInput
  salvation_none: SalvationWhereInput
  AND: [DreamWhereInput!]
  OR: [DreamWhereInput!]
  NOT: [DreamWhereInput!]
}

input DreamWhereUniqueInput {
  id: ID
}

type Experience {
  id: ID!
  compassion(where: CompassionWhereInput, orderBy: CompassionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Compassion!]
  courage(where: CourageWhereInput, orderBy: CourageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Courage!]
  acceptance(where: AcceptanceWhereInput, orderBy: AcceptanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Acceptance!]
  vulnerability(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vulnerability!]
  gratitude(where: GratitudeWhereInput, orderBy: GratitudeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gratitude!]
  suffering(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering!]
}

type ExperienceConnection {
  pageInfo: PageInfo!
  edges: [ExperienceEdge]!
  aggregate: AggregateExperience!
}

input ExperienceCreateInput {
  id: ID
  compassion: CompassionCreateManyInput
  courage: CourageCreateManyInput
  acceptance: AcceptanceCreateManyInput
  vulnerability: VulnerabilityCreateManyInput
  gratitude: GratitudeCreateManyInput
  suffering: SufferingCreateManyInput
}

input ExperienceCreateManyInput {
  create: [ExperienceCreateInput!]
  connect: [ExperienceWhereUniqueInput!]
}

input ExperienceCreateOneInput {
  create: ExperienceCreateInput
  connect: ExperienceWhereUniqueInput
}

type ExperienceEdge {
  node: Experience!
  cursor: String!
}

enum ExperienceOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExperiencePreviousValues {
  id: ID!
}

input ExperienceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ExperienceScalarWhereInput!]
  OR: [ExperienceScalarWhereInput!]
  NOT: [ExperienceScalarWhereInput!]
}

type ExperienceSubscriptionPayload {
  mutation: MutationType!
  node: Experience
  updatedFields: [String!]
  previousValues: ExperiencePreviousValues
}

input ExperienceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExperienceWhereInput
  AND: [ExperienceSubscriptionWhereInput!]
  OR: [ExperienceSubscriptionWhereInput!]
  NOT: [ExperienceSubscriptionWhereInput!]
}

input ExperienceUpdateDataInput {
  compassion: CompassionUpdateManyInput
  courage: CourageUpdateManyInput
  acceptance: AcceptanceUpdateManyInput
  vulnerability: VulnerabilityUpdateManyInput
  gratitude: GratitudeUpdateManyInput
  suffering: SufferingUpdateManyInput
}

input ExperienceUpdateInput {
  compassion: CompassionUpdateManyInput
  courage: CourageUpdateManyInput
  acceptance: AcceptanceUpdateManyInput
  vulnerability: VulnerabilityUpdateManyInput
  gratitude: GratitudeUpdateManyInput
  suffering: SufferingUpdateManyInput
}

input ExperienceUpdateManyInput {
  create: [ExperienceCreateInput!]
  update: [ExperienceUpdateWithWhereUniqueNestedInput!]
  upsert: [ExperienceUpsertWithWhereUniqueNestedInput!]
  delete: [ExperienceWhereUniqueInput!]
  connect: [ExperienceWhereUniqueInput!]
  set: [ExperienceWhereUniqueInput!]
  disconnect: [ExperienceWhereUniqueInput!]
  deleteMany: [ExperienceScalarWhereInput!]
}

input ExperienceUpdateOneInput {
  create: ExperienceCreateInput
  update: ExperienceUpdateDataInput
  upsert: ExperienceUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ExperienceWhereUniqueInput
}

input ExperienceUpdateWithWhereUniqueNestedInput {
  where: ExperienceWhereUniqueInput!
  data: ExperienceUpdateDataInput!
}

input ExperienceUpsertNestedInput {
  update: ExperienceUpdateDataInput!
  create: ExperienceCreateInput!
}

input ExperienceUpsertWithWhereUniqueNestedInput {
  where: ExperienceWhereUniqueInput!
  update: ExperienceUpdateDataInput!
  create: ExperienceCreateInput!
}

input ExperienceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  compassion_every: CompassionWhereInput
  compassion_some: CompassionWhereInput
  compassion_none: CompassionWhereInput
  courage_every: CourageWhereInput
  courage_some: CourageWhereInput
  courage_none: CourageWhereInput
  acceptance_every: AcceptanceWhereInput
  acceptance_some: AcceptanceWhereInput
  acceptance_none: AcceptanceWhereInput
  vulnerability_every: VulnerabilityWhereInput
  vulnerability_some: VulnerabilityWhereInput
  vulnerability_none: VulnerabilityWhereInput
  gratitude_every: GratitudeWhereInput
  gratitude_some: GratitudeWhereInput
  gratitude_none: GratitudeWhereInput
  suffering_every: SufferingWhereInput
  suffering_some: SufferingWhereInput
  suffering_none: SufferingWhereInput
  AND: [ExperienceWhereInput!]
  OR: [ExperienceWhereInput!]
  NOT: [ExperienceWhereInput!]
}

input ExperienceWhereUniqueInput {
  id: ID
}

type Face {
  id: ID!
  anger(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger!]
  fear(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear!]
  pride(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride!]
  selfPity(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity!]
}

type FaceConnection {
  pageInfo: PageInfo!
  edges: [FaceEdge]!
  aggregate: AggregateFace!
}

input FaceCreateInput {
  id: ID
  anger: AngerCreateManyInput
  fear: FearCreateManyInput
  pride: PrideCreateManyInput
  selfPity: SelfPityCreateManyInput
}

input FaceCreateManyInput {
  create: [FaceCreateInput!]
  connect: [FaceWhereUniqueInput!]
}

type FaceEdge {
  node: Face!
  cursor: String!
}

enum FaceOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FacePreviousValues {
  id: ID!
}

input FaceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [FaceScalarWhereInput!]
  OR: [FaceScalarWhereInput!]
  NOT: [FaceScalarWhereInput!]
}

type FaceSubscriptionPayload {
  mutation: MutationType!
  node: Face
  updatedFields: [String!]
  previousValues: FacePreviousValues
}

input FaceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FaceWhereInput
  AND: [FaceSubscriptionWhereInput!]
  OR: [FaceSubscriptionWhereInput!]
  NOT: [FaceSubscriptionWhereInput!]
}

input FaceUpdateDataInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input FaceUpdateInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input FaceUpdateManyInput {
  create: [FaceCreateInput!]
  update: [FaceUpdateWithWhereUniqueNestedInput!]
  upsert: [FaceUpsertWithWhereUniqueNestedInput!]
  delete: [FaceWhereUniqueInput!]
  connect: [FaceWhereUniqueInput!]
  set: [FaceWhereUniqueInput!]
  disconnect: [FaceWhereUniqueInput!]
  deleteMany: [FaceScalarWhereInput!]
}

input FaceUpdateWithWhereUniqueNestedInput {
  where: FaceWhereUniqueInput!
  data: FaceUpdateDataInput!
}

input FaceUpsertWithWhereUniqueNestedInput {
  where: FaceWhereUniqueInput!
  update: FaceUpdateDataInput!
  create: FaceCreateInput!
}

input FaceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  anger_every: AngerWhereInput
  anger_some: AngerWhereInput
  anger_none: AngerWhereInput
  fear_every: FearWhereInput
  fear_some: FearWhereInput
  fear_none: FearWhereInput
  pride_every: PrideWhereInput
  pride_some: PrideWhereInput
  pride_none: PrideWhereInput
  selfPity_every: SelfPityWhereInput
  selfPity_some: SelfPityWhereInput
  selfPity_none: SelfPityWhereInput
  AND: [FaceWhereInput!]
  OR: [FaceWhereInput!]
  NOT: [FaceWhereInput!]
}

input FaceWhereUniqueInput {
  id: ID
}

type Fear {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type FearConnection {
  pageInfo: PageInfo!
  edges: [FearEdge]!
  aggregate: AggregateFear!
}

input FearCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FearCreateManyInput {
  create: [FearCreateInput!]
  connect: [FearWhereUniqueInput!]
}

type FearEdge {
  node: Fear!
  cursor: String!
}

enum FearOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type FearPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FearScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [FearScalarWhereInput!]
  OR: [FearScalarWhereInput!]
  NOT: [FearScalarWhereInput!]
}

type FearSubscriptionPayload {
  mutation: MutationType!
  node: Fear
  updatedFields: [String!]
  previousValues: FearPreviousValues
}

input FearSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FearWhereInput
  AND: [FearSubscriptionWhereInput!]
  OR: [FearSubscriptionWhereInput!]
  NOT: [FearSubscriptionWhereInput!]
}

input FearUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FearUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FearUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FearUpdateManyInput {
  create: [FearCreateInput!]
  update: [FearUpdateWithWhereUniqueNestedInput!]
  upsert: [FearUpsertWithWhereUniqueNestedInput!]
  delete: [FearWhereUniqueInput!]
  connect: [FearWhereUniqueInput!]
  set: [FearWhereUniqueInput!]
  disconnect: [FearWhereUniqueInput!]
  deleteMany: [FearScalarWhereInput!]
  updateMany: [FearUpdateManyWithWhereNestedInput!]
}

input FearUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FearUpdateManyWithWhereNestedInput {
  where: FearScalarWhereInput!
  data: FearUpdateManyDataInput!
}

input FearUpdateWithWhereUniqueNestedInput {
  where: FearWhereUniqueInput!
  data: FearUpdateDataInput!
}

input FearUpsertWithWhereUniqueNestedInput {
  where: FearWhereUniqueInput!
  update: FearUpdateDataInput!
  create: FearCreateInput!
}

input FearWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [FearWhereInput!]
  OR: [FearWhereInput!]
  NOT: [FearWhereInput!]
}

input FearWhereUniqueInput {
  id: ID
}

type Feeling {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type FeelingConnection {
  pageInfo: PageInfo!
  edges: [FeelingEdge]!
  aggregate: AggregateFeeling!
}

input FeelingCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FeelingCreateManyInput {
  create: [FeelingCreateInput!]
  connect: [FeelingWhereUniqueInput!]
}

type FeelingEdge {
  node: Feeling!
  cursor: String!
}

enum FeelingOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type FeelingPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FeelingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [FeelingScalarWhereInput!]
  OR: [FeelingScalarWhereInput!]
  NOT: [FeelingScalarWhereInput!]
}

type FeelingSubscriptionPayload {
  mutation: MutationType!
  node: Feeling
  updatedFields: [String!]
  previousValues: FeelingPreviousValues
}

input FeelingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FeelingWhereInput
  AND: [FeelingSubscriptionWhereInput!]
  OR: [FeelingSubscriptionWhereInput!]
  NOT: [FeelingSubscriptionWhereInput!]
}

input FeelingUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FeelingUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FeelingUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FeelingUpdateManyInput {
  create: [FeelingCreateInput!]
  update: [FeelingUpdateWithWhereUniqueNestedInput!]
  upsert: [FeelingUpsertWithWhereUniqueNestedInput!]
  delete: [FeelingWhereUniqueInput!]
  connect: [FeelingWhereUniqueInput!]
  set: [FeelingWhereUniqueInput!]
  disconnect: [FeelingWhereUniqueInput!]
  deleteMany: [FeelingScalarWhereInput!]
  updateMany: [FeelingUpdateManyWithWhereNestedInput!]
}

input FeelingUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FeelingUpdateManyWithWhereNestedInput {
  where: FeelingScalarWhereInput!
  data: FeelingUpdateManyDataInput!
}

input FeelingUpdateWithWhereUniqueNestedInput {
  where: FeelingWhereUniqueInput!
  data: FeelingUpdateDataInput!
}

input FeelingUpsertWithWhereUniqueNestedInput {
  where: FeelingWhereUniqueInput!
  update: FeelingUpdateDataInput!
  create: FeelingCreateInput!
}

input FeelingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [FeelingWhereInput!]
  OR: [FeelingWhereInput!]
  NOT: [FeelingWhereInput!]
}

input FeelingWhereUniqueInput {
  id: ID
}

type Fun {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

type FunConnection {
  pageInfo: PageInfo!
  edges: [FunEdge]!
  aggregate: AggregateFun!
}

input FunCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input FunCreateManyInput {
  create: [FunCreateInput!]
  connect: [FunWhereUniqueInput!]
}

type FunEdge {
  node: Fun!
  cursor: String!
}

enum FunOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolveAt_ASC
  resolveAt_DESC
}

type FunPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input FunScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolveAt: DateTime
  resolveAt_not: DateTime
  resolveAt_in: [DateTime!]
  resolveAt_not_in: [DateTime!]
  resolveAt_lt: DateTime
  resolveAt_lte: DateTime
  resolveAt_gt: DateTime
  resolveAt_gte: DateTime
  AND: [FunScalarWhereInput!]
  OR: [FunScalarWhereInput!]
  NOT: [FunScalarWhereInput!]
}

type FunSubscriptionPayload {
  mutation: MutationType!
  node: Fun
  updatedFields: [String!]
  previousValues: FunPreviousValues
}

input FunSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FunWhereInput
  AND: [FunSubscriptionWhereInput!]
  OR: [FunSubscriptionWhereInput!]
  NOT: [FunSubscriptionWhereInput!]
}

input FunUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input FunUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input FunUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input FunUpdateManyInput {
  create: [FunCreateInput!]
  update: [FunUpdateWithWhereUniqueNestedInput!]
  upsert: [FunUpsertWithWhereUniqueNestedInput!]
  delete: [FunWhereUniqueInput!]
  connect: [FunWhereUniqueInput!]
  set: [FunWhereUniqueInput!]
  disconnect: [FunWhereUniqueInput!]
  deleteMany: [FunScalarWhereInput!]
  updateMany: [FunUpdateManyWithWhereNestedInput!]
}

input FunUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input FunUpdateManyWithWhereNestedInput {
  where: FunScalarWhereInput!
  data: FunUpdateManyDataInput!
}

input FunUpdateWithWhereUniqueNestedInput {
  where: FunWhereUniqueInput!
  data: FunUpdateDataInput!
}

input FunUpsertWithWhereUniqueNestedInput {
  where: FunWhereUniqueInput!
  update: FunUpdateDataInput!
  create: FunCreateInput!
}

input FunWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolveAt: DateTime
  resolveAt_not: DateTime
  resolveAt_in: [DateTime!]
  resolveAt_not_in: [DateTime!]
  resolveAt_lt: DateTime
  resolveAt_lte: DateTime
  resolveAt_gt: DateTime
  resolveAt_gte: DateTime
  AND: [FunWhereInput!]
  OR: [FunWhereInput!]
  NOT: [FunWhereInput!]
}

input FunWhereUniqueInput {
  id: ID
}

type Gash {
  id: ID!
  trauma(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma!]
  toxicity(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity!]
}

type GashConnection {
  pageInfo: PageInfo!
  edges: [GashEdge]!
  aggregate: AggregateGash!
}

input GashCreateInput {
  id: ID
  trauma: TraumaCreateManyInput
  toxicity: ToxicityCreateManyInput
}

input GashCreateManyInput {
  create: [GashCreateInput!]
  connect: [GashWhereUniqueInput!]
}

type GashEdge {
  node: Gash!
  cursor: String!
}

enum GashOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GashPreviousValues {
  id: ID!
}

input GashScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [GashScalarWhereInput!]
  OR: [GashScalarWhereInput!]
  NOT: [GashScalarWhereInput!]
}

type GashSubscriptionPayload {
  mutation: MutationType!
  node: Gash
  updatedFields: [String!]
  previousValues: GashPreviousValues
}

input GashSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GashWhereInput
  AND: [GashSubscriptionWhereInput!]
  OR: [GashSubscriptionWhereInput!]
  NOT: [GashSubscriptionWhereInput!]
}

input GashUpdateDataInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input GashUpdateInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input GashUpdateManyInput {
  create: [GashCreateInput!]
  update: [GashUpdateWithWhereUniqueNestedInput!]
  upsert: [GashUpsertWithWhereUniqueNestedInput!]
  delete: [GashWhereUniqueInput!]
  connect: [GashWhereUniqueInput!]
  set: [GashWhereUniqueInput!]
  disconnect: [GashWhereUniqueInput!]
  deleteMany: [GashScalarWhereInput!]
}

input GashUpdateWithWhereUniqueNestedInput {
  where: GashWhereUniqueInput!
  data: GashUpdateDataInput!
}

input GashUpsertWithWhereUniqueNestedInput {
  where: GashWhereUniqueInput!
  update: GashUpdateDataInput!
  create: GashCreateInput!
}

input GashWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  trauma_every: TraumaWhereInput
  trauma_some: TraumaWhereInput
  trauma_none: TraumaWhereInput
  toxicity_every: ToxicityWhereInput
  toxicity_some: ToxicityWhereInput
  toxicity_none: ToxicityWhereInput
  AND: [GashWhereInput!]
  OR: [GashWhereInput!]
  NOT: [GashWhereInput!]
}

input GashWhereUniqueInput {
  id: ID
}

type Gate {
  id: ID!
  boundary(where: BoundaryWhereInput, orderBy: BoundaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boundary!]
}

type GateConnection {
  pageInfo: PageInfo!
  edges: [GateEdge]!
  aggregate: AggregateGate!
}

input GateCreateInput {
  id: ID
  boundary: BoundaryCreateManyInput
}

input GateCreateManyInput {
  create: [GateCreateInput!]
  connect: [GateWhereUniqueInput!]
}

type GateEdge {
  node: Gate!
  cursor: String!
}

enum GateOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GatePreviousValues {
  id: ID!
}

input GateScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [GateScalarWhereInput!]
  OR: [GateScalarWhereInput!]
  NOT: [GateScalarWhereInput!]
}

type GateSubscriptionPayload {
  mutation: MutationType!
  node: Gate
  updatedFields: [String!]
  previousValues: GatePreviousValues
}

input GateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GateWhereInput
  AND: [GateSubscriptionWhereInput!]
  OR: [GateSubscriptionWhereInput!]
  NOT: [GateSubscriptionWhereInput!]
}

input GateUpdateDataInput {
  boundary: BoundaryUpdateManyInput
}

input GateUpdateInput {
  boundary: BoundaryUpdateManyInput
}

input GateUpdateManyInput {
  create: [GateCreateInput!]
  update: [GateUpdateWithWhereUniqueNestedInput!]
  upsert: [GateUpsertWithWhereUniqueNestedInput!]
  delete: [GateWhereUniqueInput!]
  connect: [GateWhereUniqueInput!]
  set: [GateWhereUniqueInput!]
  disconnect: [GateWhereUniqueInput!]
  deleteMany: [GateScalarWhereInput!]
}

input GateUpdateWithWhereUniqueNestedInput {
  where: GateWhereUniqueInput!
  data: GateUpdateDataInput!
}

input GateUpsertWithWhereUniqueNestedInput {
  where: GateWhereUniqueInput!
  update: GateUpdateDataInput!
  create: GateCreateInput!
}

input GateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  boundary_every: BoundaryWhereInput
  boundary_some: BoundaryWhereInput
  boundary_none: BoundaryWhereInput
  AND: [GateWhereInput!]
  OR: [GateWhereInput!]
  NOT: [GateWhereInput!]
}

input GateWhereUniqueInput {
  id: ID
}

type Genie {
  id: ID!
  wish(where: WishWhereInput, orderBy: WishOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Wish!]
}

type GenieConnection {
  pageInfo: PageInfo!
  edges: [GenieEdge]!
  aggregate: AggregateGenie!
}

input GenieCreateInput {
  id: ID
  wish: WishCreateManyInput
}

input GenieCreateOneInput {
  create: GenieCreateInput
  connect: GenieWhereUniqueInput
}

type GenieEdge {
  node: Genie!
  cursor: String!
}

enum GenieOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GeniePreviousValues {
  id: ID!
}

type GenieSubscriptionPayload {
  mutation: MutationType!
  node: Genie
  updatedFields: [String!]
  previousValues: GeniePreviousValues
}

input GenieSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GenieWhereInput
  AND: [GenieSubscriptionWhereInput!]
  OR: [GenieSubscriptionWhereInput!]
  NOT: [GenieSubscriptionWhereInput!]
}

input GenieUpdateDataInput {
  wish: WishUpdateManyInput
}

input GenieUpdateInput {
  wish: WishUpdateManyInput
}

input GenieUpdateOneInput {
  create: GenieCreateInput
  update: GenieUpdateDataInput
  upsert: GenieUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GenieWhereUniqueInput
}

input GenieUpsertNestedInput {
  update: GenieUpdateDataInput!
  create: GenieCreateInput!
}

input GenieWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  wish_every: WishWhereInput
  wish_some: WishWhereInput
  wish_none: WishWhereInput
  AND: [GenieWhereInput!]
  OR: [GenieWhereInput!]
  NOT: [GenieWhereInput!]
}

input GenieWhereUniqueInput {
  id: ID
}

type Gratitude {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type GratitudeConnection {
  pageInfo: PageInfo!
  edges: [GratitudeEdge]!
  aggregate: AggregateGratitude!
}

input GratitudeCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input GratitudeCreateManyInput {
  create: [GratitudeCreateInput!]
  connect: [GratitudeWhereUniqueInput!]
}

type GratitudeEdge {
  node: Gratitude!
  cursor: String!
}

enum GratitudeOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type GratitudePreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input GratitudeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [GratitudeScalarWhereInput!]
  OR: [GratitudeScalarWhereInput!]
  NOT: [GratitudeScalarWhereInput!]
}

type GratitudeSubscriptionPayload {
  mutation: MutationType!
  node: Gratitude
  updatedFields: [String!]
  previousValues: GratitudePreviousValues
}

input GratitudeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GratitudeWhereInput
  AND: [GratitudeSubscriptionWhereInput!]
  OR: [GratitudeSubscriptionWhereInput!]
  NOT: [GratitudeSubscriptionWhereInput!]
}

input GratitudeUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input GratitudeUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input GratitudeUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input GratitudeUpdateManyInput {
  create: [GratitudeCreateInput!]
  update: [GratitudeUpdateWithWhereUniqueNestedInput!]
  upsert: [GratitudeUpsertWithWhereUniqueNestedInput!]
  delete: [GratitudeWhereUniqueInput!]
  connect: [GratitudeWhereUniqueInput!]
  set: [GratitudeWhereUniqueInput!]
  disconnect: [GratitudeWhereUniqueInput!]
  deleteMany: [GratitudeScalarWhereInput!]
  updateMany: [GratitudeUpdateManyWithWhereNestedInput!]
}

input GratitudeUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input GratitudeUpdateManyWithWhereNestedInput {
  where: GratitudeScalarWhereInput!
  data: GratitudeUpdateManyDataInput!
}

input GratitudeUpdateWithWhereUniqueNestedInput {
  where: GratitudeWhereUniqueInput!
  data: GratitudeUpdateDataInput!
}

input GratitudeUpsertWithWhereUniqueNestedInput {
  where: GratitudeWhereUniqueInput!
  update: GratitudeUpdateDataInput!
  create: GratitudeCreateInput!
}

input GratitudeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [GratitudeWhereInput!]
  OR: [GratitudeWhereInput!]
  NOT: [GratitudeWhereInput!]
}

input GratitudeWhereUniqueInput {
  id: ID
}

type Guardian {
  id: ID!
  construct(where: ConstructWhereInput, orderBy: ConstructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Construct!]
}

type GuardianConnection {
  pageInfo: PageInfo!
  edges: [GuardianEdge]!
  aggregate: AggregateGuardian!
}

input GuardianCreateInput {
  id: ID
  construct: ConstructCreateManyInput
}

input GuardianCreateOneInput {
  create: GuardianCreateInput
  connect: GuardianWhereUniqueInput
}

type GuardianEdge {
  node: Guardian!
  cursor: String!
}

enum GuardianOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GuardianPreviousValues {
  id: ID!
}

type GuardianSubscriptionPayload {
  mutation: MutationType!
  node: Guardian
  updatedFields: [String!]
  previousValues: GuardianPreviousValues
}

input GuardianSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GuardianWhereInput
  AND: [GuardianSubscriptionWhereInput!]
  OR: [GuardianSubscriptionWhereInput!]
  NOT: [GuardianSubscriptionWhereInput!]
}

input GuardianUpdateDataInput {
  construct: ConstructUpdateManyInput
}

input GuardianUpdateInput {
  construct: ConstructUpdateManyInput
}

input GuardianUpdateOneInput {
  create: GuardianCreateInput
  update: GuardianUpdateDataInput
  upsert: GuardianUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: GuardianWhereUniqueInput
}

input GuardianUpsertNestedInput {
  update: GuardianUpdateDataInput!
  create: GuardianCreateInput!
}

input GuardianWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  construct_every: ConstructWhereInput
  construct_some: ConstructWhereInput
  construct_none: ConstructWhereInput
  AND: [GuardianWhereInput!]
  OR: [GuardianWhereInput!]
  NOT: [GuardianWhereInput!]
}

input GuardianWhereUniqueInput {
  id: ID
}

type Gut {
  id: ID!
  anger(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger!]
  fear(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear!]
  pride(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride!]
  selfPity(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity!]
}

type GutConnection {
  pageInfo: PageInfo!
  edges: [GutEdge]!
  aggregate: AggregateGut!
}

input GutCreateInput {
  id: ID
  anger: AngerCreateManyInput
  fear: FearCreateManyInput
  pride: PrideCreateManyInput
  selfPity: SelfPityCreateManyInput
}

input GutCreateManyInput {
  create: [GutCreateInput!]
  connect: [GutWhereUniqueInput!]
}

type GutEdge {
  node: Gut!
  cursor: String!
}

enum GutOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type GutPreviousValues {
  id: ID!
}

input GutScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [GutScalarWhereInput!]
  OR: [GutScalarWhereInput!]
  NOT: [GutScalarWhereInput!]
}

type GutSubscriptionPayload {
  mutation: MutationType!
  node: Gut
  updatedFields: [String!]
  previousValues: GutPreviousValues
}

input GutSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GutWhereInput
  AND: [GutSubscriptionWhereInput!]
  OR: [GutSubscriptionWhereInput!]
  NOT: [GutSubscriptionWhereInput!]
}

input GutUpdateDataInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input GutUpdateInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input GutUpdateManyInput {
  create: [GutCreateInput!]
  update: [GutUpdateWithWhereUniqueNestedInput!]
  upsert: [GutUpsertWithWhereUniqueNestedInput!]
  delete: [GutWhereUniqueInput!]
  connect: [GutWhereUniqueInput!]
  set: [GutWhereUniqueInput!]
  disconnect: [GutWhereUniqueInput!]
  deleteMany: [GutScalarWhereInput!]
}

input GutUpdateWithWhereUniqueNestedInput {
  where: GutWhereUniqueInput!
  data: GutUpdateDataInput!
}

input GutUpsertWithWhereUniqueNestedInput {
  where: GutWhereUniqueInput!
  update: GutUpdateDataInput!
  create: GutCreateInput!
}

input GutWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  anger_every: AngerWhereInput
  anger_some: AngerWhereInput
  anger_none: AngerWhereInput
  fear_every: FearWhereInput
  fear_some: FearWhereInput
  fear_none: FearWhereInput
  pride_every: PrideWhereInput
  pride_some: PrideWhereInput
  pride_none: PrideWhereInput
  selfPity_every: SelfPityWhereInput
  selfPity_some: SelfPityWhereInput
  selfPity_none: SelfPityWhereInput
  AND: [GutWhereInput!]
  OR: [GutWhereInput!]
  NOT: [GutWhereInput!]
}

input GutWhereUniqueInput {
  id: ID
}

type Has {
  id: ID!
  defect: Boolean!
  discontent: Boolean!
  resentment: Boolean!
  obsession: Boolean!
  experience: Boolean!
  strength: Boolean!
  hope: Boolean!
  acceptance: Boolean!
  anger: Boolean!
  armor: Boolean!
  boundary: Boolean!
  compassion: Boolean!
  courage: Boolean!
  fear: Boolean!
  fun: Boolean!
  gratitude: Boolean!
  irritability: Boolean!
  impatience: Boolean!
  joy: Boolean!
  pride: Boolean!
  salvaltion: Boolean!
  selfPity: Boolean!
  suffering: Boolean!
  toxicity: Boolean!
  trauma: Boolean!
  vulnerability: Boolean!
}

type HasConnection {
  pageInfo: PageInfo!
  edges: [HasEdge]!
  aggregate: AggregateHas!
}

input HasCreateInput {
  id: ID
  defect: Boolean
  discontent: Boolean
  resentment: Boolean
  obsession: Boolean
  experience: Boolean
  strength: Boolean
  hope: Boolean
  acceptance: Boolean
  anger: Boolean
  armor: Boolean
  boundary: Boolean
  compassion: Boolean
  courage: Boolean
  fear: Boolean
  fun: Boolean
  gratitude: Boolean
  irritability: Boolean
  impatience: Boolean
  joy: Boolean
  pride: Boolean
  salvaltion: Boolean
  selfPity: Boolean
  suffering: Boolean
  toxicity: Boolean
  trauma: Boolean
  vulnerability: Boolean
}

type HasEdge {
  node: Has!
  cursor: String!
}

enum HasOrderByInput {
  id_ASC
  id_DESC
  defect_ASC
  defect_DESC
  discontent_ASC
  discontent_DESC
  resentment_ASC
  resentment_DESC
  obsession_ASC
  obsession_DESC
  experience_ASC
  experience_DESC
  strength_ASC
  strength_DESC
  hope_ASC
  hope_DESC
  acceptance_ASC
  acceptance_DESC
  anger_ASC
  anger_DESC
  armor_ASC
  armor_DESC
  boundary_ASC
  boundary_DESC
  compassion_ASC
  compassion_DESC
  courage_ASC
  courage_DESC
  fear_ASC
  fear_DESC
  fun_ASC
  fun_DESC
  gratitude_ASC
  gratitude_DESC
  irritability_ASC
  irritability_DESC
  impatience_ASC
  impatience_DESC
  joy_ASC
  joy_DESC
  pride_ASC
  pride_DESC
  salvaltion_ASC
  salvaltion_DESC
  selfPity_ASC
  selfPity_DESC
  suffering_ASC
  suffering_DESC
  toxicity_ASC
  toxicity_DESC
  trauma_ASC
  trauma_DESC
  vulnerability_ASC
  vulnerability_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HasPreviousValues {
  id: ID!
  defect: Boolean!
  discontent: Boolean!
  resentment: Boolean!
  obsession: Boolean!
  experience: Boolean!
  strength: Boolean!
  hope: Boolean!
  acceptance: Boolean!
  anger: Boolean!
  armor: Boolean!
  boundary: Boolean!
  compassion: Boolean!
  courage: Boolean!
  fear: Boolean!
  fun: Boolean!
  gratitude: Boolean!
  irritability: Boolean!
  impatience: Boolean!
  joy: Boolean!
  pride: Boolean!
  salvaltion: Boolean!
  selfPity: Boolean!
  suffering: Boolean!
  toxicity: Boolean!
  trauma: Boolean!
  vulnerability: Boolean!
}

type HasSubscriptionPayload {
  mutation: MutationType!
  node: Has
  updatedFields: [String!]
  previousValues: HasPreviousValues
}

input HasSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HasWhereInput
  AND: [HasSubscriptionWhereInput!]
  OR: [HasSubscriptionWhereInput!]
  NOT: [HasSubscriptionWhereInput!]
}

input HasUpdateInput {
  defect: Boolean
  discontent: Boolean
  resentment: Boolean
  obsession: Boolean
  experience: Boolean
  strength: Boolean
  hope: Boolean
  acceptance: Boolean
  anger: Boolean
  armor: Boolean
  boundary: Boolean
  compassion: Boolean
  courage: Boolean
  fear: Boolean
  fun: Boolean
  gratitude: Boolean
  irritability: Boolean
  impatience: Boolean
  joy: Boolean
  pride: Boolean
  salvaltion: Boolean
  selfPity: Boolean
  suffering: Boolean
  toxicity: Boolean
  trauma: Boolean
  vulnerability: Boolean
}

input HasUpdateManyMutationInput {
  defect: Boolean
  discontent: Boolean
  resentment: Boolean
  obsession: Boolean
  experience: Boolean
  strength: Boolean
  hope: Boolean
  acceptance: Boolean
  anger: Boolean
  armor: Boolean
  boundary: Boolean
  compassion: Boolean
  courage: Boolean
  fear: Boolean
  fun: Boolean
  gratitude: Boolean
  irritability: Boolean
  impatience: Boolean
  joy: Boolean
  pride: Boolean
  salvaltion: Boolean
  selfPity: Boolean
  suffering: Boolean
  toxicity: Boolean
  trauma: Boolean
  vulnerability: Boolean
}

input HasWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  defect: Boolean
  defect_not: Boolean
  discontent: Boolean
  discontent_not: Boolean
  resentment: Boolean
  resentment_not: Boolean
  obsession: Boolean
  obsession_not: Boolean
  experience: Boolean
  experience_not: Boolean
  strength: Boolean
  strength_not: Boolean
  hope: Boolean
  hope_not: Boolean
  acceptance: Boolean
  acceptance_not: Boolean
  anger: Boolean
  anger_not: Boolean
  armor: Boolean
  armor_not: Boolean
  boundary: Boolean
  boundary_not: Boolean
  compassion: Boolean
  compassion_not: Boolean
  courage: Boolean
  courage_not: Boolean
  fear: Boolean
  fear_not: Boolean
  fun: Boolean
  fun_not: Boolean
  gratitude: Boolean
  gratitude_not: Boolean
  irritability: Boolean
  irritability_not: Boolean
  impatience: Boolean
  impatience_not: Boolean
  joy: Boolean
  joy_not: Boolean
  pride: Boolean
  pride_not: Boolean
  salvaltion: Boolean
  salvaltion_not: Boolean
  selfPity: Boolean
  selfPity_not: Boolean
  suffering: Boolean
  suffering_not: Boolean
  toxicity: Boolean
  toxicity_not: Boolean
  trauma: Boolean
  trauma_not: Boolean
  vulnerability: Boolean
  vulnerability_not: Boolean
  AND: [HasWhereInput!]
  OR: [HasWhereInput!]
  NOT: [HasWhereInput!]
}

input HasWhereUniqueInput {
  id: ID
}

type Heart {
  id: ID!
  anger(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger!]
  fear(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear!]
  pride(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride!]
  selfPity(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity!]
}

type HeartConnection {
  pageInfo: PageInfo!
  edges: [HeartEdge]!
  aggregate: AggregateHeart!
}

input HeartCreateInput {
  id: ID
  anger: AngerCreateManyInput
  fear: FearCreateManyInput
  pride: PrideCreateManyInput
  selfPity: SelfPityCreateManyInput
}

input HeartCreateManyInput {
  create: [HeartCreateInput!]
  connect: [HeartWhereUniqueInput!]
}

type HeartEdge {
  node: Heart!
  cursor: String!
}

enum HeartOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HeartPreviousValues {
  id: ID!
}

input HeartScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [HeartScalarWhereInput!]
  OR: [HeartScalarWhereInput!]
  NOT: [HeartScalarWhereInput!]
}

type HeartSubscriptionPayload {
  mutation: MutationType!
  node: Heart
  updatedFields: [String!]
  previousValues: HeartPreviousValues
}

input HeartSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HeartWhereInput
  AND: [HeartSubscriptionWhereInput!]
  OR: [HeartSubscriptionWhereInput!]
  NOT: [HeartSubscriptionWhereInput!]
}

input HeartUpdateDataInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input HeartUpdateInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input HeartUpdateManyInput {
  create: [HeartCreateInput!]
  update: [HeartUpdateWithWhereUniqueNestedInput!]
  upsert: [HeartUpsertWithWhereUniqueNestedInput!]
  delete: [HeartWhereUniqueInput!]
  connect: [HeartWhereUniqueInput!]
  set: [HeartWhereUniqueInput!]
  disconnect: [HeartWhereUniqueInput!]
  deleteMany: [HeartScalarWhereInput!]
}

input HeartUpdateWithWhereUniqueNestedInput {
  where: HeartWhereUniqueInput!
  data: HeartUpdateDataInput!
}

input HeartUpsertWithWhereUniqueNestedInput {
  where: HeartWhereUniqueInput!
  update: HeartUpdateDataInput!
  create: HeartCreateInput!
}

input HeartWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  anger_every: AngerWhereInput
  anger_some: AngerWhereInput
  anger_none: AngerWhereInput
  fear_every: FearWhereInput
  fear_some: FearWhereInput
  fear_none: FearWhereInput
  pride_every: PrideWhereInput
  pride_some: PrideWhereInput
  pride_none: PrideWhereInput
  selfPity_every: SelfPityWhereInput
  selfPity_some: SelfPityWhereInput
  selfPity_none: SelfPityWhereInput
  AND: [HeartWhereInput!]
  OR: [HeartWhereInput!]
  NOT: [HeartWhereInput!]
}

input HeartWhereUniqueInput {
  id: ID
}

type HigherPower {
  id: ID!
  prayer: Prayer
  inventory(where: FeelingWhereInput, orderBy: FeelingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feeling!]
  character: Characters
}

type HigherPowerConnection {
  pageInfo: PageInfo!
  edges: [HigherPowerEdge]!
  aggregate: AggregateHigherPower!
}

input HigherPowerCreateInput {
  id: ID
  prayer: PrayerCreateOneInput
  inventory: FeelingCreateManyInput
  character: CharactersCreateOneInput
}

type HigherPowerEdge {
  node: HigherPower!
  cursor: String!
}

enum HigherPowerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HigherPowerPreviousValues {
  id: ID!
}

type HigherPowerSubscriptionPayload {
  mutation: MutationType!
  node: HigherPower
  updatedFields: [String!]
  previousValues: HigherPowerPreviousValues
}

input HigherPowerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HigherPowerWhereInput
  AND: [HigherPowerSubscriptionWhereInput!]
  OR: [HigherPowerSubscriptionWhereInput!]
  NOT: [HigherPowerSubscriptionWhereInput!]
}

input HigherPowerUpdateInput {
  prayer: PrayerUpdateOneInput
  inventory: FeelingUpdateManyInput
  character: CharactersUpdateOneInput
}

input HigherPowerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  prayer: PrayerWhereInput
  inventory_every: FeelingWhereInput
  inventory_some: FeelingWhereInput
  inventory_none: FeelingWhereInput
  character: CharactersWhereInput
  AND: [HigherPowerWhereInput!]
  OR: [HigherPowerWhereInput!]
  NOT: [HigherPowerWhereInput!]
}

input HigherPowerWhereUniqueInput {
  id: ID
}

type Honor {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type HonorConnection {
  pageInfo: PageInfo!
  edges: [HonorEdge]!
  aggregate: AggregateHonor!
}

input HonorCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input HonorCreateManyInput {
  create: [HonorCreateInput!]
  connect: [HonorWhereUniqueInput!]
}

type HonorEdge {
  node: Honor!
  cursor: String!
}

enum HonorOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type HonorPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input HonorScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [HonorScalarWhereInput!]
  OR: [HonorScalarWhereInput!]
  NOT: [HonorScalarWhereInput!]
}

type HonorSubscriptionPayload {
  mutation: MutationType!
  node: Honor
  updatedFields: [String!]
  previousValues: HonorPreviousValues
}

input HonorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HonorWhereInput
  AND: [HonorSubscriptionWhereInput!]
  OR: [HonorSubscriptionWhereInput!]
  NOT: [HonorSubscriptionWhereInput!]
}

input HonorUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input HonorUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input HonorUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input HonorUpdateManyInput {
  create: [HonorCreateInput!]
  update: [HonorUpdateWithWhereUniqueNestedInput!]
  upsert: [HonorUpsertWithWhereUniqueNestedInput!]
  delete: [HonorWhereUniqueInput!]
  connect: [HonorWhereUniqueInput!]
  set: [HonorWhereUniqueInput!]
  disconnect: [HonorWhereUniqueInput!]
  deleteMany: [HonorScalarWhereInput!]
  updateMany: [HonorUpdateManyWithWhereNestedInput!]
}

input HonorUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input HonorUpdateManyWithWhereNestedInput {
  where: HonorScalarWhereInput!
  data: HonorUpdateManyDataInput!
}

input HonorUpdateWithWhereUniqueNestedInput {
  where: HonorWhereUniqueInput!
  data: HonorUpdateDataInput!
}

input HonorUpsertWithWhereUniqueNestedInput {
  where: HonorWhereUniqueInput!
  update: HonorUpdateDataInput!
  create: HonorCreateInput!
}

input HonorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [HonorWhereInput!]
  OR: [HonorWhereInput!]
  NOT: [HonorWhereInput!]
}

input HonorWhereUniqueInput {
  id: ID
}

type Hope {
  id: ID!
  salvation(where: SalvationWhereInput, orderBy: SalvationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Salvation!]
  fun(where: FunWhereInput, orderBy: FunOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fun!]
  joy(where: JoyWhereInput, orderBy: JoyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Joy!]
}

type HopeConnection {
  pageInfo: PageInfo!
  edges: [HopeEdge]!
  aggregate: AggregateHope!
}

input HopeCreateInput {
  id: ID
  salvation: SalvationCreateManyInput
  fun: FunCreateManyInput
  joy: JoyCreateManyInput
}

input HopeCreateManyInput {
  create: [HopeCreateInput!]
  connect: [HopeWhereUniqueInput!]
}

input HopeCreateOneInput {
  create: HopeCreateInput
  connect: HopeWhereUniqueInput
}

type HopeEdge {
  node: Hope!
  cursor: String!
}

enum HopeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HopePreviousValues {
  id: ID!
}

input HopeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [HopeScalarWhereInput!]
  OR: [HopeScalarWhereInput!]
  NOT: [HopeScalarWhereInput!]
}

type HopeSubscriptionPayload {
  mutation: MutationType!
  node: Hope
  updatedFields: [String!]
  previousValues: HopePreviousValues
}

input HopeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HopeWhereInput
  AND: [HopeSubscriptionWhereInput!]
  OR: [HopeSubscriptionWhereInput!]
  NOT: [HopeSubscriptionWhereInput!]
}

input HopeUpdateDataInput {
  salvation: SalvationUpdateManyInput
  fun: FunUpdateManyInput
  joy: JoyUpdateManyInput
}

input HopeUpdateInput {
  salvation: SalvationUpdateManyInput
  fun: FunUpdateManyInput
  joy: JoyUpdateManyInput
}

input HopeUpdateManyInput {
  create: [HopeCreateInput!]
  update: [HopeUpdateWithWhereUniqueNestedInput!]
  upsert: [HopeUpsertWithWhereUniqueNestedInput!]
  delete: [HopeWhereUniqueInput!]
  connect: [HopeWhereUniqueInput!]
  set: [HopeWhereUniqueInput!]
  disconnect: [HopeWhereUniqueInput!]
  deleteMany: [HopeScalarWhereInput!]
}

input HopeUpdateOneInput {
  create: HopeCreateInput
  update: HopeUpdateDataInput
  upsert: HopeUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: HopeWhereUniqueInput
}

input HopeUpdateWithWhereUniqueNestedInput {
  where: HopeWhereUniqueInput!
  data: HopeUpdateDataInput!
}

input HopeUpsertNestedInput {
  update: HopeUpdateDataInput!
  create: HopeCreateInput!
}

input HopeUpsertWithWhereUniqueNestedInput {
  where: HopeWhereUniqueInput!
  update: HopeUpdateDataInput!
  create: HopeCreateInput!
}

input HopeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  salvation_every: SalvationWhereInput
  salvation_some: SalvationWhereInput
  salvation_none: SalvationWhereInput
  fun_every: FunWhereInput
  fun_some: FunWhereInput
  fun_none: FunWhereInput
  joy_every: JoyWhereInput
  joy_some: JoyWhereInput
  joy_none: JoyWhereInput
  AND: [HopeWhereInput!]
  OR: [HopeWhereInput!]
  NOT: [HopeWhereInput!]
}

input HopeWhereUniqueInput {
  id: ID
}

type Impatience {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

type ImpatienceConnection {
  pageInfo: PageInfo!
  edges: [ImpatienceEdge]!
  aggregate: AggregateImpatience!
}

input ImpatienceCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input ImpatienceCreateManyInput {
  create: [ImpatienceCreateInput!]
  connect: [ImpatienceWhereUniqueInput!]
}

type ImpatienceEdge {
  node: Impatience!
  cursor: String!
}

enum ImpatienceOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolveAt_ASC
  resolveAt_DESC
}

type ImpatiencePreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input ImpatienceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolveAt: DateTime
  resolveAt_not: DateTime
  resolveAt_in: [DateTime!]
  resolveAt_not_in: [DateTime!]
  resolveAt_lt: DateTime
  resolveAt_lte: DateTime
  resolveAt_gt: DateTime
  resolveAt_gte: DateTime
  AND: [ImpatienceScalarWhereInput!]
  OR: [ImpatienceScalarWhereInput!]
  NOT: [ImpatienceScalarWhereInput!]
}

type ImpatienceSubscriptionPayload {
  mutation: MutationType!
  node: Impatience
  updatedFields: [String!]
  previousValues: ImpatiencePreviousValues
}

input ImpatienceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImpatienceWhereInput
  AND: [ImpatienceSubscriptionWhereInput!]
  OR: [ImpatienceSubscriptionWhereInput!]
  NOT: [ImpatienceSubscriptionWhereInput!]
}

input ImpatienceUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input ImpatienceUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input ImpatienceUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input ImpatienceUpdateManyInput {
  create: [ImpatienceCreateInput!]
  update: [ImpatienceUpdateWithWhereUniqueNestedInput!]
  upsert: [ImpatienceUpsertWithWhereUniqueNestedInput!]
  delete: [ImpatienceWhereUniqueInput!]
  connect: [ImpatienceWhereUniqueInput!]
  set: [ImpatienceWhereUniqueInput!]
  disconnect: [ImpatienceWhereUniqueInput!]
  deleteMany: [ImpatienceScalarWhereInput!]
  updateMany: [ImpatienceUpdateManyWithWhereNestedInput!]
}

input ImpatienceUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input ImpatienceUpdateManyWithWhereNestedInput {
  where: ImpatienceScalarWhereInput!
  data: ImpatienceUpdateManyDataInput!
}

input ImpatienceUpdateWithWhereUniqueNestedInput {
  where: ImpatienceWhereUniqueInput!
  data: ImpatienceUpdateDataInput!
}

input ImpatienceUpsertWithWhereUniqueNestedInput {
  where: ImpatienceWhereUniqueInput!
  update: ImpatienceUpdateDataInput!
  create: ImpatienceCreateInput!
}

input ImpatienceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolveAt: DateTime
  resolveAt_not: DateTime
  resolveAt_in: [DateTime!]
  resolveAt_not_in: [DateTime!]
  resolveAt_lt: DateTime
  resolveAt_lte: DateTime
  resolveAt_gt: DateTime
  resolveAt_gte: DateTime
  AND: [ImpatienceWhereInput!]
  OR: [ImpatienceWhereInput!]
  NOT: [ImpatienceWhereInput!]
}

input ImpatienceWhereUniqueInput {
  id: ID
}

type Infection {
  id: ID!
  trauma(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma!]
  toxicity(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity!]
}

type InfectionConnection {
  pageInfo: PageInfo!
  edges: [InfectionEdge]!
  aggregate: AggregateInfection!
}

input InfectionCreateInput {
  id: ID
  trauma: TraumaCreateManyInput
  toxicity: ToxicityCreateManyInput
}

input InfectionCreateManyInput {
  create: [InfectionCreateInput!]
  connect: [InfectionWhereUniqueInput!]
}

type InfectionEdge {
  node: Infection!
  cursor: String!
}

enum InfectionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InfectionPreviousValues {
  id: ID!
}

input InfectionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [InfectionScalarWhereInput!]
  OR: [InfectionScalarWhereInput!]
  NOT: [InfectionScalarWhereInput!]
}

type InfectionSubscriptionPayload {
  mutation: MutationType!
  node: Infection
  updatedFields: [String!]
  previousValues: InfectionPreviousValues
}

input InfectionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InfectionWhereInput
  AND: [InfectionSubscriptionWhereInput!]
  OR: [InfectionSubscriptionWhereInput!]
  NOT: [InfectionSubscriptionWhereInput!]
}

input InfectionUpdateDataInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input InfectionUpdateInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input InfectionUpdateManyInput {
  create: [InfectionCreateInput!]
  update: [InfectionUpdateWithWhereUniqueNestedInput!]
  upsert: [InfectionUpsertWithWhereUniqueNestedInput!]
  delete: [InfectionWhereUniqueInput!]
  connect: [InfectionWhereUniqueInput!]
  set: [InfectionWhereUniqueInput!]
  disconnect: [InfectionWhereUniqueInput!]
  deleteMany: [InfectionScalarWhereInput!]
}

input InfectionUpdateWithWhereUniqueNestedInput {
  where: InfectionWhereUniqueInput!
  data: InfectionUpdateDataInput!
}

input InfectionUpsertWithWhereUniqueNestedInput {
  where: InfectionWhereUniqueInput!
  update: InfectionUpdateDataInput!
  create: InfectionCreateInput!
}

input InfectionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  trauma_every: TraumaWhereInput
  trauma_some: TraumaWhereInput
  trauma_none: TraumaWhereInput
  toxicity_every: ToxicityWhereInput
  toxicity_some: ToxicityWhereInput
  toxicity_none: ToxicityWhereInput
  AND: [InfectionWhereInput!]
  OR: [InfectionWhereInput!]
  NOT: [InfectionWhereInput!]
}

input InfectionWhereUniqueInput {
  id: ID
}

type Inventory {
  id: ID!
  defect(where: DefectWhereInput, orderBy: DefectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Defect!]
  discontent(where: DiscontentWhereInput, orderBy: DiscontentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Discontent!]
  resentment(where: ResentmentWhereInput, orderBy: ResentmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Resentment!]
  obsession(where: ObsessionWhereInput, orderBy: ObsessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Obsession!]
  experience(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience!]
  strength(where: StrengthWhereInput, orderBy: StrengthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Strength!]
  hope(where: HopeWhereInput, orderBy: HopeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hope!]
}

type InventoryConnection {
  pageInfo: PageInfo!
  edges: [InventoryEdge]!
  aggregate: AggregateInventory!
}

input InventoryCreateInput {
  id: ID
  defect: DefectCreateManyInput
  discontent: DiscontentCreateManyInput
  resentment: ResentmentCreateManyInput
  obsession: ObsessionCreateManyInput
  experience: ExperienceCreateManyInput
  strength: StrengthCreateManyInput
  hope: HopeCreateManyInput
}

type InventoryEdge {
  node: Inventory!
  cursor: String!
}

enum InventoryOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InventoryPreviousValues {
  id: ID!
}

type InventorySubscriptionPayload {
  mutation: MutationType!
  node: Inventory
  updatedFields: [String!]
  previousValues: InventoryPreviousValues
}

input InventorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryWhereInput
  AND: [InventorySubscriptionWhereInput!]
  OR: [InventorySubscriptionWhereInput!]
  NOT: [InventorySubscriptionWhereInput!]
}

input InventoryUpdateInput {
  defect: DefectUpdateManyInput
  discontent: DiscontentUpdateManyInput
  resentment: ResentmentUpdateManyInput
  obsession: ObsessionUpdateManyInput
  experience: ExperienceUpdateManyInput
  strength: StrengthUpdateManyInput
  hope: HopeUpdateManyInput
}

input InventoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  defect_every: DefectWhereInput
  defect_some: DefectWhereInput
  defect_none: DefectWhereInput
  discontent_every: DiscontentWhereInput
  discontent_some: DiscontentWhereInput
  discontent_none: DiscontentWhereInput
  resentment_every: ResentmentWhereInput
  resentment_some: ResentmentWhereInput
  resentment_none: ResentmentWhereInput
  obsession_every: ObsessionWhereInput
  obsession_some: ObsessionWhereInput
  obsession_none: ObsessionWhereInput
  experience_every: ExperienceWhereInput
  experience_some: ExperienceWhereInput
  experience_none: ExperienceWhereInput
  strength_every: StrengthWhereInput
  strength_some: StrengthWhereInput
  strength_none: StrengthWhereInput
  hope_every: HopeWhereInput
  hope_some: HopeWhereInput
  hope_none: HopeWhereInput
  AND: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
}

input InventoryWhereUniqueInput {
  id: ID
}

type Irritability {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

type IrritabilityConnection {
  pageInfo: PageInfo!
  edges: [IrritabilityEdge]!
  aggregate: AggregateIrritability!
}

input IrritabilityCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input IrritabilityCreateManyInput {
  create: [IrritabilityCreateInput!]
  connect: [IrritabilityWhereUniqueInput!]
}

type IrritabilityEdge {
  node: Irritability!
  cursor: String!
}

enum IrritabilityOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolveAt_ASC
  resolveAt_DESC
}

type IrritabilityPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input IrritabilityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolveAt: DateTime
  resolveAt_not: DateTime
  resolveAt_in: [DateTime!]
  resolveAt_not_in: [DateTime!]
  resolveAt_lt: DateTime
  resolveAt_lte: DateTime
  resolveAt_gt: DateTime
  resolveAt_gte: DateTime
  AND: [IrritabilityScalarWhereInput!]
  OR: [IrritabilityScalarWhereInput!]
  NOT: [IrritabilityScalarWhereInput!]
}

type IrritabilitySubscriptionPayload {
  mutation: MutationType!
  node: Irritability
  updatedFields: [String!]
  previousValues: IrritabilityPreviousValues
}

input IrritabilitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: IrritabilityWhereInput
  AND: [IrritabilitySubscriptionWhereInput!]
  OR: [IrritabilitySubscriptionWhereInput!]
  NOT: [IrritabilitySubscriptionWhereInput!]
}

input IrritabilityUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input IrritabilityUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input IrritabilityUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input IrritabilityUpdateManyInput {
  create: [IrritabilityCreateInput!]
  update: [IrritabilityUpdateWithWhereUniqueNestedInput!]
  upsert: [IrritabilityUpsertWithWhereUniqueNestedInput!]
  delete: [IrritabilityWhereUniqueInput!]
  connect: [IrritabilityWhereUniqueInput!]
  set: [IrritabilityWhereUniqueInput!]
  disconnect: [IrritabilityWhereUniqueInput!]
  deleteMany: [IrritabilityScalarWhereInput!]
  updateMany: [IrritabilityUpdateManyWithWhereNestedInput!]
}

input IrritabilityUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input IrritabilityUpdateManyWithWhereNestedInput {
  where: IrritabilityScalarWhereInput!
  data: IrritabilityUpdateManyDataInput!
}

input IrritabilityUpdateWithWhereUniqueNestedInput {
  where: IrritabilityWhereUniqueInput!
  data: IrritabilityUpdateDataInput!
}

input IrritabilityUpsertWithWhereUniqueNestedInput {
  where: IrritabilityWhereUniqueInput!
  update: IrritabilityUpdateDataInput!
  create: IrritabilityCreateInput!
}

input IrritabilityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolveAt: DateTime
  resolveAt_not: DateTime
  resolveAt_in: [DateTime!]
  resolveAt_not_in: [DateTime!]
  resolveAt_lt: DateTime
  resolveAt_lte: DateTime
  resolveAt_gt: DateTime
  resolveAt_gte: DateTime
  AND: [IrritabilityWhereInput!]
  OR: [IrritabilityWhereInput!]
  NOT: [IrritabilityWhereInput!]
}

input IrritabilityWhereUniqueInput {
  id: ID
}

type Joy {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

type JoyConnection {
  pageInfo: PageInfo!
  edges: [JoyEdge]!
  aggregate: AggregateJoy!
}

input JoyCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input JoyCreateManyInput {
  create: [JoyCreateInput!]
  connect: [JoyWhereUniqueInput!]
}

type JoyEdge {
  node: Joy!
  cursor: String!
}

enum JoyOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolveAt_ASC
  resolveAt_DESC
}

type JoyPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime
  updatedAt: DateTime
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input JoyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolveAt: DateTime
  resolveAt_not: DateTime
  resolveAt_in: [DateTime!]
  resolveAt_not_in: [DateTime!]
  resolveAt_lt: DateTime
  resolveAt_lte: DateTime
  resolveAt_gt: DateTime
  resolveAt_gte: DateTime
  AND: [JoyScalarWhereInput!]
  OR: [JoyScalarWhereInput!]
  NOT: [JoyScalarWhereInput!]
}

type JoySubscriptionPayload {
  mutation: MutationType!
  node: Joy
  updatedFields: [String!]
  previousValues: JoyPreviousValues
}

input JoySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: JoyWhereInput
  AND: [JoySubscriptionWhereInput!]
  OR: [JoySubscriptionWhereInput!]
  NOT: [JoySubscriptionWhereInput!]
}

input JoyUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input JoyUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input JoyUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input JoyUpdateManyInput {
  create: [JoyCreateInput!]
  update: [JoyUpdateWithWhereUniqueNestedInput!]
  upsert: [JoyUpsertWithWhereUniqueNestedInput!]
  delete: [JoyWhereUniqueInput!]
  connect: [JoyWhereUniqueInput!]
  set: [JoyWhereUniqueInput!]
  disconnect: [JoyWhereUniqueInput!]
  deleteMany: [JoyScalarWhereInput!]
  updateMany: [JoyUpdateManyWithWhereNestedInput!]
}

input JoyUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolveAt: DateTime
}

input JoyUpdateManyWithWhereNestedInput {
  where: JoyScalarWhereInput!
  data: JoyUpdateManyDataInput!
}

input JoyUpdateWithWhereUniqueNestedInput {
  where: JoyWhereUniqueInput!
  data: JoyUpdateDataInput!
}

input JoyUpsertWithWhereUniqueNestedInput {
  where: JoyWhereUniqueInput!
  update: JoyUpdateDataInput!
  create: JoyCreateInput!
}

input JoyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolveAt: DateTime
  resolveAt_not: DateTime
  resolveAt_in: [DateTime!]
  resolveAt_not_in: [DateTime!]
  resolveAt_lt: DateTime
  resolveAt_lte: DateTime
  resolveAt_gt: DateTime
  resolveAt_gte: DateTime
  AND: [JoyWhereInput!]
  OR: [JoyWhereInput!]
  NOT: [JoyWhereInput!]
}

input JoyWhereUniqueInput {
  id: ID
}

scalar Long

type Love {
  id: ID!
  vulnerability(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vulnerability!]
  acceptance(where: AcceptanceWhereInput, orderBy: AcceptanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Acceptance!]
}

type LoveConnection {
  pageInfo: PageInfo!
  edges: [LoveEdge]!
  aggregate: AggregateLove!
}

input LoveCreateInput {
  id: ID
  vulnerability: VulnerabilityCreateManyInput
  acceptance: AcceptanceCreateManyInput
}

type LoveEdge {
  node: Love!
  cursor: String!
}

enum LoveOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type LovePreviousValues {
  id: ID!
}

type LoveSubscriptionPayload {
  mutation: MutationType!
  node: Love
  updatedFields: [String!]
  previousValues: LovePreviousValues
}

input LoveSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LoveWhereInput
  AND: [LoveSubscriptionWhereInput!]
  OR: [LoveSubscriptionWhereInput!]
  NOT: [LoveSubscriptionWhereInput!]
}

input LoveUpdateInput {
  vulnerability: VulnerabilityUpdateManyInput
  acceptance: AcceptanceUpdateManyInput
}

input LoveWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  vulnerability_every: VulnerabilityWhereInput
  vulnerability_some: VulnerabilityWhereInput
  vulnerability_none: VulnerabilityWhereInput
  acceptance_every: AcceptanceWhereInput
  acceptance_some: AcceptanceWhereInput
  acceptance_none: AcceptanceWhereInput
  AND: [LoveWhereInput!]
  OR: [LoveWhereInput!]
  NOT: [LoveWhereInput!]
}

input LoveWhereUniqueInput {
  id: ID
}

type Loyalty {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type LoyaltyConnection {
  pageInfo: PageInfo!
  edges: [LoyaltyEdge]!
  aggregate: AggregateLoyalty!
}

input LoyaltyCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input LoyaltyCreateManyInput {
  create: [LoyaltyCreateInput!]
  connect: [LoyaltyWhereUniqueInput!]
}

type LoyaltyEdge {
  node: Loyalty!
  cursor: String!
}

enum LoyaltyOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type LoyaltyPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input LoyaltyScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [LoyaltyScalarWhereInput!]
  OR: [LoyaltyScalarWhereInput!]
  NOT: [LoyaltyScalarWhereInput!]
}

type LoyaltySubscriptionPayload {
  mutation: MutationType!
  node: Loyalty
  updatedFields: [String!]
  previousValues: LoyaltyPreviousValues
}

input LoyaltySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LoyaltyWhereInput
  AND: [LoyaltySubscriptionWhereInput!]
  OR: [LoyaltySubscriptionWhereInput!]
  NOT: [LoyaltySubscriptionWhereInput!]
}

input LoyaltyUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input LoyaltyUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input LoyaltyUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input LoyaltyUpdateManyInput {
  create: [LoyaltyCreateInput!]
  update: [LoyaltyUpdateWithWhereUniqueNestedInput!]
  upsert: [LoyaltyUpsertWithWhereUniqueNestedInput!]
  delete: [LoyaltyWhereUniqueInput!]
  connect: [LoyaltyWhereUniqueInput!]
  set: [LoyaltyWhereUniqueInput!]
  disconnect: [LoyaltyWhereUniqueInput!]
  deleteMany: [LoyaltyScalarWhereInput!]
  updateMany: [LoyaltyUpdateManyWithWhereNestedInput!]
}

input LoyaltyUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input LoyaltyUpdateManyWithWhereNestedInput {
  where: LoyaltyScalarWhereInput!
  data: LoyaltyUpdateManyDataInput!
}

input LoyaltyUpdateWithWhereUniqueNestedInput {
  where: LoyaltyWhereUniqueInput!
  data: LoyaltyUpdateDataInput!
}

input LoyaltyUpsertWithWhereUniqueNestedInput {
  where: LoyaltyWhereUniqueInput!
  update: LoyaltyUpdateDataInput!
  create: LoyaltyCreateInput!
}

input LoyaltyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [LoyaltyWhereInput!]
  OR: [LoyaltyWhereInput!]
  NOT: [LoyaltyWhereInput!]
}

input LoyaltyWhereUniqueInput {
  id: ID
}

type Martyr {
  id: ID!
  stigmata(where: StigmataWhereInput, orderBy: StigmataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Stigmata!]
}

type MartyrConnection {
  pageInfo: PageInfo!
  edges: [MartyrEdge]!
  aggregate: AggregateMartyr!
}

input MartyrCreateInput {
  id: ID
  stigmata: StigmataCreateManyInput
}

input MartyrCreateOneInput {
  create: MartyrCreateInput
  connect: MartyrWhereUniqueInput
}

type MartyrEdge {
  node: Martyr!
  cursor: String!
}

enum MartyrOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MartyrPreviousValues {
  id: ID!
}

type MartyrSubscriptionPayload {
  mutation: MutationType!
  node: Martyr
  updatedFields: [String!]
  previousValues: MartyrPreviousValues
}

input MartyrSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MartyrWhereInput
  AND: [MartyrSubscriptionWhereInput!]
  OR: [MartyrSubscriptionWhereInput!]
  NOT: [MartyrSubscriptionWhereInput!]
}

input MartyrUpdateDataInput {
  stigmata: StigmataUpdateManyInput
}

input MartyrUpdateInput {
  stigmata: StigmataUpdateManyInput
}

input MartyrUpdateOneInput {
  create: MartyrCreateInput
  update: MartyrUpdateDataInput
  upsert: MartyrUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: MartyrWhereUniqueInput
}

input MartyrUpsertNestedInput {
  update: MartyrUpdateDataInput!
  create: MartyrCreateInput!
}

input MartyrWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stigmata_every: StigmataWhereInput
  stigmata_some: StigmataWhereInput
  stigmata_none: StigmataWhereInput
  AND: [MartyrWhereInput!]
  OR: [MartyrWhereInput!]
  NOT: [MartyrWhereInput!]
}

input MartyrWhereUniqueInput {
  id: ID
}

type Mind {
  id: ID!
  vulnerability(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vulnerability!]
  acceptance(where: AcceptanceWhereInput, orderBy: AcceptanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Acceptance!]
}

type MindConnection {
  pageInfo: PageInfo!
  edges: [MindEdge]!
  aggregate: AggregateMind!
}

input MindCreateInput {
  id: ID
  vulnerability: VulnerabilityCreateManyInput
  acceptance: AcceptanceCreateManyInput
}

type MindEdge {
  node: Mind!
  cursor: String!
}

enum MindOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MindPreviousValues {
  id: ID!
}

type MindSubscriptionPayload {
  mutation: MutationType!
  node: Mind
  updatedFields: [String!]
  previousValues: MindPreviousValues
}

input MindSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MindWhereInput
  AND: [MindSubscriptionWhereInput!]
  OR: [MindSubscriptionWhereInput!]
  NOT: [MindSubscriptionWhereInput!]
}

input MindUpdateInput {
  vulnerability: VulnerabilityUpdateManyInput
  acceptance: AcceptanceUpdateManyInput
}

input MindWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  vulnerability_every: VulnerabilityWhereInput
  vulnerability_some: VulnerabilityWhereInput
  vulnerability_none: VulnerabilityWhereInput
  acceptance_every: AcceptanceWhereInput
  acceptance_some: AcceptanceWhereInput
  acceptance_none: AcceptanceWhereInput
  AND: [MindWhereInput!]
  OR: [MindWhereInput!]
  NOT: [MindWhereInput!]
}

input MindWhereUniqueInput {
  id: ID
}

type Mouth {
  id: ID!
  anger(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger!]
  fear(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear!]
  pride(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride!]
  selfPity(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity!]
}

type MouthConnection {
  pageInfo: PageInfo!
  edges: [MouthEdge]!
  aggregate: AggregateMouth!
}

input MouthCreateInput {
  id: ID
  anger: AngerCreateManyInput
  fear: FearCreateManyInput
  pride: PrideCreateManyInput
  selfPity: SelfPityCreateManyInput
}

input MouthCreateManyInput {
  create: [MouthCreateInput!]
  connect: [MouthWhereUniqueInput!]
}

type MouthEdge {
  node: Mouth!
  cursor: String!
}

enum MouthOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MouthPreviousValues {
  id: ID!
}

input MouthScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [MouthScalarWhereInput!]
  OR: [MouthScalarWhereInput!]
  NOT: [MouthScalarWhereInput!]
}

type MouthSubscriptionPayload {
  mutation: MutationType!
  node: Mouth
  updatedFields: [String!]
  previousValues: MouthPreviousValues
}

input MouthSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MouthWhereInput
  AND: [MouthSubscriptionWhereInput!]
  OR: [MouthSubscriptionWhereInput!]
  NOT: [MouthSubscriptionWhereInput!]
}

input MouthUpdateDataInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input MouthUpdateInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input MouthUpdateManyInput {
  create: [MouthCreateInput!]
  update: [MouthUpdateWithWhereUniqueNestedInput!]
  upsert: [MouthUpsertWithWhereUniqueNestedInput!]
  delete: [MouthWhereUniqueInput!]
  connect: [MouthWhereUniqueInput!]
  set: [MouthWhereUniqueInput!]
  disconnect: [MouthWhereUniqueInput!]
  deleteMany: [MouthScalarWhereInput!]
}

input MouthUpdateWithWhereUniqueNestedInput {
  where: MouthWhereUniqueInput!
  data: MouthUpdateDataInput!
}

input MouthUpsertWithWhereUniqueNestedInput {
  where: MouthWhereUniqueInput!
  update: MouthUpdateDataInput!
  create: MouthCreateInput!
}

input MouthWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  anger_every: AngerWhereInput
  anger_some: AngerWhereInput
  anger_none: AngerWhereInput
  fear_every: FearWhereInput
  fear_some: FearWhereInput
  fear_none: FearWhereInput
  pride_every: PrideWhereInput
  pride_some: PrideWhereInput
  pride_none: PrideWhereInput
  selfPity_every: SelfPityWhereInput
  selfPity_some: SelfPityWhereInput
  selfPity_none: SelfPityWhereInput
  AND: [MouthWhereInput!]
  OR: [MouthWhereInput!]
  NOT: [MouthWhereInput!]
}

input MouthWhereUniqueInput {
  id: ID
}

type Mutation {
  createAcceptance(data: AcceptanceCreateInput!): Acceptance!
  updateAcceptance(data: AcceptanceUpdateInput!, where: AcceptanceWhereUniqueInput!): Acceptance
  updateManyAcceptances(data: AcceptanceUpdateManyMutationInput!, where: AcceptanceWhereInput): BatchPayload!
  upsertAcceptance(where: AcceptanceWhereUniqueInput!, create: AcceptanceCreateInput!, update: AcceptanceUpdateInput!): Acceptance!
  deleteAcceptance(where: AcceptanceWhereUniqueInput!): Acceptance
  deleteManyAcceptances(where: AcceptanceWhereInput): BatchPayload!
  createAct(data: ActCreateInput!): Act!
  updateAct(data: ActUpdateInput!, where: ActWhereUniqueInput!): Act
  upsertAct(where: ActWhereUniqueInput!, create: ActCreateInput!, update: ActUpdateInput!): Act!
  deleteAct(where: ActWhereUniqueInput!): Act
  deleteManyActs(where: ActWhereInput): BatchPayload!
  createAffliction(data: AfflictionCreateInput!): Affliction!
  updateAffliction(data: AfflictionUpdateInput!, where: AfflictionWhereUniqueInput!): Affliction
  upsertAffliction(where: AfflictionWhereUniqueInput!, create: AfflictionCreateInput!, update: AfflictionUpdateInput!): Affliction!
  deleteAffliction(where: AfflictionWhereUniqueInput!): Affliction
  deleteManyAfflictions(where: AfflictionWhereInput): BatchPayload!
  createAnger(data: AngerCreateInput!): Anger!
  updateAnger(data: AngerUpdateInput!, where: AngerWhereUniqueInput!): Anger
  updateManyAngers(data: AngerUpdateManyMutationInput!, where: AngerWhereInput): BatchPayload!
  upsertAnger(where: AngerWhereUniqueInput!, create: AngerCreateInput!, update: AngerUpdateInput!): Anger!
  deleteAnger(where: AngerWhereUniqueInput!): Anger
  deleteManyAngers(where: AngerWhereInput): BatchPayload!
  createArmor(data: ArmorCreateInput!): Armor!
  updateArmor(data: ArmorUpdateInput!, where: ArmorWhereUniqueInput!): Armor
  updateManyArmors(data: ArmorUpdateManyMutationInput!, where: ArmorWhereInput): BatchPayload!
  upsertArmor(where: ArmorWhereUniqueInput!, create: ArmorCreateInput!, update: ArmorUpdateInput!): Armor!
  deleteArmor(where: ArmorWhereUniqueInput!): Armor
  deleteManyArmors(where: ArmorWhereInput): BatchPayload!
  createBody(data: BodyCreateInput!): Body!
  updateBody(data: BodyUpdateInput!, where: BodyWhereUniqueInput!): Body
  upsertBody(where: BodyWhereUniqueInput!, create: BodyCreateInput!, update: BodyUpdateInput!): Body!
  deleteBody(where: BodyWhereUniqueInput!): Body
  deleteManyBodies(where: BodyWhereInput): BatchPayload!
  createBoundary(data: BoundaryCreateInput!): Boundary!
  updateBoundary(data: BoundaryUpdateInput!, where: BoundaryWhereUniqueInput!): Boundary
  updateManyBoundaries(data: BoundaryUpdateManyMutationInput!, where: BoundaryWhereInput): BatchPayload!
  upsertBoundary(where: BoundaryWhereUniqueInput!, create: BoundaryCreateInput!, update: BoundaryUpdateInput!): Boundary!
  deleteBoundary(where: BoundaryWhereUniqueInput!): Boundary
  deleteManyBoundaries(where: BoundaryWhereInput): BatchPayload!
  createBrain(data: BrainCreateInput!): Brain!
  updateBrain(data: BrainUpdateInput!, where: BrainWhereUniqueInput!): Brain
  upsertBrain(where: BrainWhereUniqueInput!, create: BrainCreateInput!, update: BrainUpdateInput!): Brain!
  deleteBrain(where: BrainWhereUniqueInput!): Brain
  deleteManyBrains(where: BrainWhereInput): BatchPayload!
  createCampaign(data: CampaignCreateInput!): Campaign!
  updateCampaign(data: CampaignUpdateInput!, where: CampaignWhereUniqueInput!): Campaign
  upsertCampaign(where: CampaignWhereUniqueInput!, create: CampaignCreateInput!, update: CampaignUpdateInput!): Campaign!
  deleteCampaign(where: CampaignWhereUniqueInput!): Campaign
  deleteManyCampaigns(where: CampaignWhereInput): BatchPayload!
  createCharacters(data: CharactersCreateInput!): Characters!
  updateCharacters(data: CharactersUpdateInput!, where: CharactersWhereUniqueInput!): Characters
  upsertCharacters(where: CharactersWhereUniqueInput!, create: CharactersCreateInput!, update: CharactersUpdateInput!): Characters!
  deleteCharacters(where: CharactersWhereUniqueInput!): Characters
  deleteManyCharacterses(where: CharactersWhereInput): BatchPayload!
  createCompassion(data: CompassionCreateInput!): Compassion!
  updateCompassion(data: CompassionUpdateInput!, where: CompassionWhereUniqueInput!): Compassion
  updateManyCompassions(data: CompassionUpdateManyMutationInput!, where: CompassionWhereInput): BatchPayload!
  upsertCompassion(where: CompassionWhereUniqueInput!, create: CompassionCreateInput!, update: CompassionUpdateInput!): Compassion!
  deleteCompassion(where: CompassionWhereUniqueInput!): Compassion
  deleteManyCompassions(where: CompassionWhereInput): BatchPayload!
  createConfusion(data: ConfusionCreateInput!): Confusion!
  updateConfusion(data: ConfusionUpdateInput!, where: ConfusionWhereUniqueInput!): Confusion
  upsertConfusion(where: ConfusionWhereUniqueInput!, create: ConfusionCreateInput!, update: ConfusionUpdateInput!): Confusion!
  deleteConfusion(where: ConfusionWhereUniqueInput!): Confusion
  deleteManyConfusions(where: ConfusionWhereInput): BatchPayload!
  createCongregant(data: CongregantCreateInput!): Congregant!
  deleteCongregant(where: CongregantWhereUniqueInput!): Congregant
  deleteManyCongregants(where: CongregantWhereInput): BatchPayload!
  createConstruct(data: ConstructCreateInput!): Construct!
  updateConstruct(data: ConstructUpdateInput!, where: ConstructWhereUniqueInput!): Construct
  upsertConstruct(where: ConstructWhereUniqueInput!, create: ConstructCreateInput!, update: ConstructUpdateInput!): Construct!
  deleteConstruct(where: ConstructWhereUniqueInput!): Construct
  deleteManyConstructs(where: ConstructWhereInput): BatchPayload!
  createCourage(data: CourageCreateInput!): Courage!
  updateCourage(data: CourageUpdateInput!, where: CourageWhereUniqueInput!): Courage
  updateManyCourages(data: CourageUpdateManyMutationInput!, where: CourageWhereInput): BatchPayload!
  upsertCourage(where: CourageWhereUniqueInput!, create: CourageCreateInput!, update: CourageUpdateInput!): Courage!
  deleteCourage(where: CourageWhereUniqueInput!): Courage
  deleteManyCourages(where: CourageWhereInput): BatchPayload!
  createCross(data: CrossCreateInput!): Cross!
  updateCross(data: CrossUpdateInput!, where: CrossWhereUniqueInput!): Cross
  upsertCross(where: CrossWhereUniqueInput!, create: CrossCreateInput!, update: CrossUpdateInput!): Cross!
  deleteCross(where: CrossWhereUniqueInput!): Cross
  deleteManyCrosses(where: CrossWhereInput): BatchPayload!
  createCrown(data: CrownCreateInput!): Crown!
  updateCrown(data: CrownUpdateInput!, where: CrownWhereUniqueInput!): Crown
  upsertCrown(where: CrownWhereUniqueInput!, create: CrownCreateInput!, update: CrownUpdateInput!): Crown!
  deleteCrown(where: CrownWhereUniqueInput!): Crown
  deleteManyCrowns(where: CrownWhereInput): BatchPayload!
  createCrusade(data: CrusadeCreateInput!): Crusade!
  updateCrusade(data: CrusadeUpdateInput!, where: CrusadeWhereUniqueInput!): Crusade
  upsertCrusade(where: CrusadeWhereUniqueInput!, create: CrusadeCreateInput!, update: CrusadeUpdateInput!): Crusade!
  deleteCrusade(where: CrusadeWhereUniqueInput!): Crusade
  deleteManyCrusades(where: CrusadeWhereInput): BatchPayload!
  createDefect(data: DefectCreateInput!): Defect!
  updateDefect(data: DefectUpdateInput!, where: DefectWhereUniqueInput!): Defect
  upsertDefect(where: DefectWhereUniqueInput!, create: DefectCreateInput!, update: DefectUpdateInput!): Defect!
  deleteDefect(where: DefectWhereUniqueInput!): Defect
  deleteManyDefects(where: DefectWhereInput): BatchPayload!
  createDelirium(data: DeliriumCreateInput!): Delirium!
  updateDelirium(data: DeliriumUpdateInput!, where: DeliriumWhereUniqueInput!): Delirium
  upsertDelirium(where: DeliriumWhereUniqueInput!, create: DeliriumCreateInput!, update: DeliriumUpdateInput!): Delirium!
  deleteDelirium(where: DeliriumWhereUniqueInput!): Delirium
  deleteManyDeliriums(where: DeliriumWhereInput): BatchPayload!
  createDenial(data: DenialCreateInput!): Denial!
  updateDenial(data: DenialUpdateInput!, where: DenialWhereUniqueInput!): Denial
  upsertDenial(where: DenialWhereUniqueInput!, create: DenialCreateInput!, update: DenialUpdateInput!): Denial!
  deleteDenial(where: DenialWhereUniqueInput!): Denial
  deleteManyDenials(where: DenialWhereInput): BatchPayload!
  createDiscontent(data: DiscontentCreateInput!): Discontent!
  updateDiscontent(data: DiscontentUpdateInput!, where: DiscontentWhereUniqueInput!): Discontent
  upsertDiscontent(where: DiscontentWhereUniqueInput!, create: DiscontentCreateInput!, update: DiscontentUpdateInput!): Discontent!
  deleteDiscontent(where: DiscontentWhereUniqueInput!): Discontent
  deleteManyDiscontents(where: DiscontentWhereInput): BatchPayload!
  createDream(data: DreamCreateInput!): Dream!
  updateDream(data: DreamUpdateInput!, where: DreamWhereUniqueInput!): Dream
  upsertDream(where: DreamWhereUniqueInput!, create: DreamCreateInput!, update: DreamUpdateInput!): Dream!
  deleteDream(where: DreamWhereUniqueInput!): Dream
  deleteManyDreams(where: DreamWhereInput): BatchPayload!
  createExperience(data: ExperienceCreateInput!): Experience!
  updateExperience(data: ExperienceUpdateInput!, where: ExperienceWhereUniqueInput!): Experience
  upsertExperience(where: ExperienceWhereUniqueInput!, create: ExperienceCreateInput!, update: ExperienceUpdateInput!): Experience!
  deleteExperience(where: ExperienceWhereUniqueInput!): Experience
  deleteManyExperiences(where: ExperienceWhereInput): BatchPayload!
  createFace(data: FaceCreateInput!): Face!
  updateFace(data: FaceUpdateInput!, where: FaceWhereUniqueInput!): Face
  upsertFace(where: FaceWhereUniqueInput!, create: FaceCreateInput!, update: FaceUpdateInput!): Face!
  deleteFace(where: FaceWhereUniqueInput!): Face
  deleteManyFaces(where: FaceWhereInput): BatchPayload!
  createFear(data: FearCreateInput!): Fear!
  updateFear(data: FearUpdateInput!, where: FearWhereUniqueInput!): Fear
  updateManyFears(data: FearUpdateManyMutationInput!, where: FearWhereInput): BatchPayload!
  upsertFear(where: FearWhereUniqueInput!, create: FearCreateInput!, update: FearUpdateInput!): Fear!
  deleteFear(where: FearWhereUniqueInput!): Fear
  deleteManyFears(where: FearWhereInput): BatchPayload!
  createFeeling(data: FeelingCreateInput!): Feeling!
  updateFeeling(data: FeelingUpdateInput!, where: FeelingWhereUniqueInput!): Feeling
  updateManyFeelings(data: FeelingUpdateManyMutationInput!, where: FeelingWhereInput): BatchPayload!
  upsertFeeling(where: FeelingWhereUniqueInput!, create: FeelingCreateInput!, update: FeelingUpdateInput!): Feeling!
  deleteFeeling(where: FeelingWhereUniqueInput!): Feeling
  deleteManyFeelings(where: FeelingWhereInput): BatchPayload!
  createFun(data: FunCreateInput!): Fun!
  updateFun(data: FunUpdateInput!, where: FunWhereUniqueInput!): Fun
  updateManyFuns(data: FunUpdateManyMutationInput!, where: FunWhereInput): BatchPayload!
  upsertFun(where: FunWhereUniqueInput!, create: FunCreateInput!, update: FunUpdateInput!): Fun!
  deleteFun(where: FunWhereUniqueInput!): Fun
  deleteManyFuns(where: FunWhereInput): BatchPayload!
  createGash(data: GashCreateInput!): Gash!
  updateGash(data: GashUpdateInput!, where: GashWhereUniqueInput!): Gash
  upsertGash(where: GashWhereUniqueInput!, create: GashCreateInput!, update: GashUpdateInput!): Gash!
  deleteGash(where: GashWhereUniqueInput!): Gash
  deleteManyGashes(where: GashWhereInput): BatchPayload!
  createGate(data: GateCreateInput!): Gate!
  updateGate(data: GateUpdateInput!, where: GateWhereUniqueInput!): Gate
  upsertGate(where: GateWhereUniqueInput!, create: GateCreateInput!, update: GateUpdateInput!): Gate!
  deleteGate(where: GateWhereUniqueInput!): Gate
  deleteManyGates(where: GateWhereInput): BatchPayload!
  createGenie(data: GenieCreateInput!): Genie!
  updateGenie(data: GenieUpdateInput!, where: GenieWhereUniqueInput!): Genie
  upsertGenie(where: GenieWhereUniqueInput!, create: GenieCreateInput!, update: GenieUpdateInput!): Genie!
  deleteGenie(where: GenieWhereUniqueInput!): Genie
  deleteManyGenies(where: GenieWhereInput): BatchPayload!
  createGratitude(data: GratitudeCreateInput!): Gratitude!
  updateGratitude(data: GratitudeUpdateInput!, where: GratitudeWhereUniqueInput!): Gratitude
  updateManyGratitudes(data: GratitudeUpdateManyMutationInput!, where: GratitudeWhereInput): BatchPayload!
  upsertGratitude(where: GratitudeWhereUniqueInput!, create: GratitudeCreateInput!, update: GratitudeUpdateInput!): Gratitude!
  deleteGratitude(where: GratitudeWhereUniqueInput!): Gratitude
  deleteManyGratitudes(where: GratitudeWhereInput): BatchPayload!
  createGuardian(data: GuardianCreateInput!): Guardian!
  updateGuardian(data: GuardianUpdateInput!, where: GuardianWhereUniqueInput!): Guardian
  upsertGuardian(where: GuardianWhereUniqueInput!, create: GuardianCreateInput!, update: GuardianUpdateInput!): Guardian!
  deleteGuardian(where: GuardianWhereUniqueInput!): Guardian
  deleteManyGuardians(where: GuardianWhereInput): BatchPayload!
  createGut(data: GutCreateInput!): Gut!
  updateGut(data: GutUpdateInput!, where: GutWhereUniqueInput!): Gut
  upsertGut(where: GutWhereUniqueInput!, create: GutCreateInput!, update: GutUpdateInput!): Gut!
  deleteGut(where: GutWhereUniqueInput!): Gut
  deleteManyGuts(where: GutWhereInput): BatchPayload!
  createHas(data: HasCreateInput!): Has!
  updateHas(data: HasUpdateInput!, where: HasWhereUniqueInput!): Has
  updateManyHases(data: HasUpdateManyMutationInput!, where: HasWhereInput): BatchPayload!
  upsertHas(where: HasWhereUniqueInput!, create: HasCreateInput!, update: HasUpdateInput!): Has!
  deleteHas(where: HasWhereUniqueInput!): Has
  deleteManyHases(where: HasWhereInput): BatchPayload!
  createHeart(data: HeartCreateInput!): Heart!
  updateHeart(data: HeartUpdateInput!, where: HeartWhereUniqueInput!): Heart
  upsertHeart(where: HeartWhereUniqueInput!, create: HeartCreateInput!, update: HeartUpdateInput!): Heart!
  deleteHeart(where: HeartWhereUniqueInput!): Heart
  deleteManyHearts(where: HeartWhereInput): BatchPayload!
  createHigherPower(data: HigherPowerCreateInput!): HigherPower!
  updateHigherPower(data: HigherPowerUpdateInput!, where: HigherPowerWhereUniqueInput!): HigherPower
  upsertHigherPower(where: HigherPowerWhereUniqueInput!, create: HigherPowerCreateInput!, update: HigherPowerUpdateInput!): HigherPower!
  deleteHigherPower(where: HigherPowerWhereUniqueInput!): HigherPower
  deleteManyHigherPowers(where: HigherPowerWhereInput): BatchPayload!
  createHonor(data: HonorCreateInput!): Honor!
  updateHonor(data: HonorUpdateInput!, where: HonorWhereUniqueInput!): Honor
  updateManyHonors(data: HonorUpdateManyMutationInput!, where: HonorWhereInput): BatchPayload!
  upsertHonor(where: HonorWhereUniqueInput!, create: HonorCreateInput!, update: HonorUpdateInput!): Honor!
  deleteHonor(where: HonorWhereUniqueInput!): Honor
  deleteManyHonors(where: HonorWhereInput): BatchPayload!
  createHope(data: HopeCreateInput!): Hope!
  updateHope(data: HopeUpdateInput!, where: HopeWhereUniqueInput!): Hope
  upsertHope(where: HopeWhereUniqueInput!, create: HopeCreateInput!, update: HopeUpdateInput!): Hope!
  deleteHope(where: HopeWhereUniqueInput!): Hope
  deleteManyHopes(where: HopeWhereInput): BatchPayload!
  createImpatience(data: ImpatienceCreateInput!): Impatience!
  updateImpatience(data: ImpatienceUpdateInput!, where: ImpatienceWhereUniqueInput!): Impatience
  updateManyImpatiences(data: ImpatienceUpdateManyMutationInput!, where: ImpatienceWhereInput): BatchPayload!
  upsertImpatience(where: ImpatienceWhereUniqueInput!, create: ImpatienceCreateInput!, update: ImpatienceUpdateInput!): Impatience!
  deleteImpatience(where: ImpatienceWhereUniqueInput!): Impatience
  deleteManyImpatiences(where: ImpatienceWhereInput): BatchPayload!
  createInfection(data: InfectionCreateInput!): Infection!
  updateInfection(data: InfectionUpdateInput!, where: InfectionWhereUniqueInput!): Infection
  upsertInfection(where: InfectionWhereUniqueInput!, create: InfectionCreateInput!, update: InfectionUpdateInput!): Infection!
  deleteInfection(where: InfectionWhereUniqueInput!): Infection
  deleteManyInfections(where: InfectionWhereInput): BatchPayload!
  createInventory(data: InventoryCreateInput!): Inventory!
  updateInventory(data: InventoryUpdateInput!, where: InventoryWhereUniqueInput!): Inventory
  upsertInventory(where: InventoryWhereUniqueInput!, create: InventoryCreateInput!, update: InventoryUpdateInput!): Inventory!
  deleteInventory(where: InventoryWhereUniqueInput!): Inventory
  deleteManyInventories(where: InventoryWhereInput): BatchPayload!
  createIrritability(data: IrritabilityCreateInput!): Irritability!
  updateIrritability(data: IrritabilityUpdateInput!, where: IrritabilityWhereUniqueInput!): Irritability
  updateManyIrritabilities(data: IrritabilityUpdateManyMutationInput!, where: IrritabilityWhereInput): BatchPayload!
  upsertIrritability(where: IrritabilityWhereUniqueInput!, create: IrritabilityCreateInput!, update: IrritabilityUpdateInput!): Irritability!
  deleteIrritability(where: IrritabilityWhereUniqueInput!): Irritability
  deleteManyIrritabilities(where: IrritabilityWhereInput): BatchPayload!
  createJoy(data: JoyCreateInput!): Joy!
  updateJoy(data: JoyUpdateInput!, where: JoyWhereUniqueInput!): Joy
  updateManyJoys(data: JoyUpdateManyMutationInput!, where: JoyWhereInput): BatchPayload!
  upsertJoy(where: JoyWhereUniqueInput!, create: JoyCreateInput!, update: JoyUpdateInput!): Joy!
  deleteJoy(where: JoyWhereUniqueInput!): Joy
  deleteManyJoys(where: JoyWhereInput): BatchPayload!
  createLove(data: LoveCreateInput!): Love!
  updateLove(data: LoveUpdateInput!, where: LoveWhereUniqueInput!): Love
  upsertLove(where: LoveWhereUniqueInput!, create: LoveCreateInput!, update: LoveUpdateInput!): Love!
  deleteLove(where: LoveWhereUniqueInput!): Love
  deleteManyLoves(where: LoveWhereInput): BatchPayload!
  createLoyalty(data: LoyaltyCreateInput!): Loyalty!
  updateLoyalty(data: LoyaltyUpdateInput!, where: LoyaltyWhereUniqueInput!): Loyalty
  updateManyLoyalties(data: LoyaltyUpdateManyMutationInput!, where: LoyaltyWhereInput): BatchPayload!
  upsertLoyalty(where: LoyaltyWhereUniqueInput!, create: LoyaltyCreateInput!, update: LoyaltyUpdateInput!): Loyalty!
  deleteLoyalty(where: LoyaltyWhereUniqueInput!): Loyalty
  deleteManyLoyalties(where: LoyaltyWhereInput): BatchPayload!
  createMartyr(data: MartyrCreateInput!): Martyr!
  updateMartyr(data: MartyrUpdateInput!, where: MartyrWhereUniqueInput!): Martyr
  upsertMartyr(where: MartyrWhereUniqueInput!, create: MartyrCreateInput!, update: MartyrUpdateInput!): Martyr!
  deleteMartyr(where: MartyrWhereUniqueInput!): Martyr
  deleteManyMartyrs(where: MartyrWhereInput): BatchPayload!
  createMind(data: MindCreateInput!): Mind!
  updateMind(data: MindUpdateInput!, where: MindWhereUniqueInput!): Mind
  upsertMind(where: MindWhereUniqueInput!, create: MindCreateInput!, update: MindUpdateInput!): Mind!
  deleteMind(where: MindWhereUniqueInput!): Mind
  deleteManyMinds(where: MindWhereInput): BatchPayload!
  createMouth(data: MouthCreateInput!): Mouth!
  updateMouth(data: MouthUpdateInput!, where: MouthWhereUniqueInput!): Mouth
  upsertMouth(where: MouthWhereUniqueInput!, create: MouthCreateInput!, update: MouthUpdateInput!): Mouth!
  deleteMouth(where: MouthWhereUniqueInput!): Mouth
  deleteManyMouths(where: MouthWhereInput): BatchPayload!
  createNail(data: NailCreateInput!): Nail!
  updateNail(data: NailUpdateInput!, where: NailWhereUniqueInput!): Nail
  upsertNail(where: NailWhereUniqueInput!, create: NailCreateInput!, update: NailUpdateInput!): Nail!
  deleteNail(where: NailWhereUniqueInput!): Nail
  deleteManyNails(where: NailWhereInput): BatchPayload!
  createNightmare(data: NightmareCreateInput!): Nightmare!
  updateNightmare(data: NightmareUpdateInput!, where: NightmareWhereUniqueInput!): Nightmare
  upsertNightmare(where: NightmareWhereUniqueInput!, create: NightmareCreateInput!, update: NightmareUpdateInput!): Nightmare!
  deleteNightmare(where: NightmareWhereUniqueInput!): Nightmare
  deleteManyNightmares(where: NightmareWhereInput): BatchPayload!
  createOath(data: OathCreateInput!): Oath!
  updateOath(data: OathUpdateInput!, where: OathWhereUniqueInput!): Oath
  upsertOath(where: OathWhereUniqueInput!, create: OathCreateInput!, update: OathUpdateInput!): Oath!
  deleteOath(where: OathWhereUniqueInput!): Oath
  deleteManyOaths(where: OathWhereInput): BatchPayload!
  createObsession(data: ObsessionCreateInput!): Obsession!
  updateObsession(data: ObsessionUpdateInput!, where: ObsessionWhereUniqueInput!): Obsession
  upsertObsession(where: ObsessionWhereUniqueInput!, create: ObsessionCreateInput!, update: ObsessionUpdateInput!): Obsession!
  deleteObsession(where: ObsessionWhereUniqueInput!): Obsession
  deleteManyObsessions(where: ObsessionWhereInput): BatchPayload!
  createPaladin(data: PaladinCreateInput!): Paladin!
  updatePaladin(data: PaladinUpdateInput!, where: PaladinWhereUniqueInput!): Paladin
  upsertPaladin(where: PaladinWhereUniqueInput!, create: PaladinCreateInput!, update: PaladinUpdateInput!): Paladin!
  deletePaladin(where: PaladinWhereUniqueInput!): Paladin
  deleteManyPaladins(where: PaladinWhereInput): BatchPayload!
  createPath(data: PathCreateInput!): Path!
  updatePath(data: PathUpdateInput!, where: PathWhereUniqueInput!): Path
  upsertPath(where: PathWhereUniqueInput!, create: PathCreateInput!, update: PathUpdateInput!): Path!
  deletePath(where: PathWhereUniqueInput!): Path
  deleteManyPaths(where: PathWhereInput): BatchPayload!
  createPledge(data: PledgeCreateInput!): Pledge!
  updatePledge(data: PledgeUpdateInput!, where: PledgeWhereUniqueInput!): Pledge
  upsertPledge(where: PledgeWhereUniqueInput!, create: PledgeCreateInput!, update: PledgeUpdateInput!): Pledge!
  deletePledge(where: PledgeWhereUniqueInput!): Pledge
  deleteManyPledges(where: PledgeWhereInput): BatchPayload!
  createPrayer(data: PrayerCreateInput!): Prayer!
  updatePrayer(data: PrayerUpdateInput!, where: PrayerWhereUniqueInput!): Prayer
  upsertPrayer(where: PrayerWhereUniqueInput!, create: PrayerCreateInput!, update: PrayerUpdateInput!): Prayer!
  deletePrayer(where: PrayerWhereUniqueInput!): Prayer
  deleteManyPrayers(where: PrayerWhereInput): BatchPayload!
  createPride(data: PrideCreateInput!): Pride!
  updatePride(data: PrideUpdateInput!, where: PrideWhereUniqueInput!): Pride
  updateManyPrides(data: PrideUpdateManyMutationInput!, where: PrideWhereInput): BatchPayload!
  upsertPride(where: PrideWhereUniqueInput!, create: PrideCreateInput!, update: PrideUpdateInput!): Pride!
  deletePride(where: PrideWhereUniqueInput!): Pride
  deleteManyPrides(where: PrideWhereInput): BatchPayload!
  createProcess(data: ProcessCreateInput!): Process!
  updateProcess(data: ProcessUpdateInput!, where: ProcessWhereUniqueInput!): Process
  upsertProcess(where: ProcessWhereUniqueInput!, create: ProcessCreateInput!, update: ProcessUpdateInput!): Process!
  deleteProcess(where: ProcessWhereUniqueInput!): Process
  deleteManyProcesses(where: ProcessWhereInput): BatchPayload!
  createResentment(data: ResentmentCreateInput!): Resentment!
  updateResentment(data: ResentmentUpdateInput!, where: ResentmentWhereUniqueInput!): Resentment
  upsertResentment(where: ResentmentWhereUniqueInput!, create: ResentmentCreateInput!, update: ResentmentUpdateInput!): Resentment!
  deleteResentment(where: ResentmentWhereUniqueInput!): Resentment
  deleteManyResentments(where: ResentmentWhereInput): BatchPayload!
  createSacrifice(data: SacrificeCreateInput!): Sacrifice!
  updateSacrifice(data: SacrificeUpdateInput!, where: SacrificeWhereUniqueInput!): Sacrifice
  upsertSacrifice(where: SacrificeWhereUniqueInput!, create: SacrificeCreateInput!, update: SacrificeUpdateInput!): Sacrifice!
  deleteSacrifice(where: SacrificeWhereUniqueInput!): Sacrifice
  deleteManySacrifices(where: SacrificeWhereInput): BatchPayload!
  createSalvation(data: SalvationCreateInput!): Salvation!
  updateSalvation(data: SalvationUpdateInput!, where: SalvationWhereUniqueInput!): Salvation
  updateManySalvations(data: SalvationUpdateManyMutationInput!, where: SalvationWhereInput): BatchPayload!
  upsertSalvation(where: SalvationWhereUniqueInput!, create: SalvationCreateInput!, update: SalvationUpdateInput!): Salvation!
  deleteSalvation(where: SalvationWhereUniqueInput!): Salvation
  deleteManySalvations(where: SalvationWhereInput): BatchPayload!
  createSarcasm(data: SarcasmCreateInput!): Sarcasm!
  updateSarcasm(data: SarcasmUpdateInput!, where: SarcasmWhereUniqueInput!): Sarcasm
  upsertSarcasm(where: SarcasmWhereUniqueInput!, create: SarcasmCreateInput!, update: SarcasmUpdateInput!): Sarcasm!
  deleteSarcasm(where: SarcasmWhereUniqueInput!): Sarcasm
  deleteManySarcasms(where: SarcasmWhereInput): BatchPayload!
  createScar(data: ScarCreateInput!): Scar!
  updateScar(data: ScarUpdateInput!, where: ScarWhereUniqueInput!): Scar
  upsertScar(where: ScarWhereUniqueInput!, create: ScarCreateInput!, update: ScarUpdateInput!): Scar!
  deleteScar(where: ScarWhereUniqueInput!): Scar
  deleteManyScars(where: ScarWhereInput): BatchPayload!
  createSeeker(data: SeekerCreateInput!): Seeker!
  updateSeeker(data: SeekerUpdateInput!, where: SeekerWhereUniqueInput!): Seeker
  upsertSeeker(where: SeekerWhereUniqueInput!, create: SeekerCreateInput!, update: SeekerUpdateInput!): Seeker!
  deleteSeeker(where: SeekerWhereUniqueInput!): Seeker
  deleteManySeekers(where: SeekerWhereInput): BatchPayload!
  createSelf(data: SelfCreateInput!): Self!
  updateSelf(data: SelfUpdateInput!, where: SelfWhereUniqueInput!): Self
  upsertSelf(where: SelfWhereUniqueInput!, create: SelfCreateInput!, update: SelfUpdateInput!): Self!
  deleteSelf(where: SelfWhereUniqueInput!): Self
  deleteManySelves(where: SelfWhereInput): BatchPayload!
  createSelfPity(data: SelfPityCreateInput!): SelfPity!
  updateSelfPity(data: SelfPityUpdateInput!, where: SelfPityWhereUniqueInput!): SelfPity
  updateManySelfPities(data: SelfPityUpdateManyMutationInput!, where: SelfPityWhereInput): BatchPayload!
  upsertSelfPity(where: SelfPityWhereUniqueInput!, create: SelfPityCreateInput!, update: SelfPityUpdateInput!): SelfPity!
  deleteSelfPity(where: SelfPityWhereUniqueInput!): SelfPity
  deleteManySelfPities(where: SelfPityWhereInput): BatchPayload!
  createService(data: ServiceCreateInput!): Service!
  updateService(data: ServiceUpdateInput!, where: ServiceWhereUniqueInput!): Service
  upsertService(where: ServiceWhereUniqueInput!, create: ServiceCreateInput!, update: ServiceUpdateInput!): Service!
  deleteService(where: ServiceWhereUniqueInput!): Service
  deleteManyServices(where: ServiceWhereInput): BatchPayload!
  createShield(data: ShieldCreateInput!): Shield!
  updateShield(data: ShieldUpdateInput!, where: ShieldWhereUniqueInput!): Shield
  upsertShield(where: ShieldWhereUniqueInput!, create: ShieldCreateInput!, update: ShieldUpdateInput!): Shield!
  deleteShield(where: ShieldWhereUniqueInput!): Shield
  deleteManyShields(where: ShieldWhereInput): BatchPayload!
  createSilence(data: SilenceCreateInput!): Silence!
  updateSilence(data: SilenceUpdateInput!, where: SilenceWhereUniqueInput!): Silence
  upsertSilence(where: SilenceWhereUniqueInput!, create: SilenceCreateInput!, update: SilenceUpdateInput!): Silence!
  deleteSilence(where: SilenceWhereUniqueInput!): Silence
  deleteManySilences(where: SilenceWhereInput): BatchPayload!
  createSkin(data: SkinCreateInput!): Skin!
  updateSkin(data: SkinUpdateInput!, where: SkinWhereUniqueInput!): Skin
  upsertSkin(where: SkinWhereUniqueInput!, create: SkinCreateInput!, update: SkinUpdateInput!): Skin!
  deleteSkin(where: SkinWhereUniqueInput!): Skin
  deleteManySkins(where: SkinWhereInput): BatchPayload!
  createSmith(data: SmithCreateInput!): Smith!
  updateSmith(data: SmithUpdateInput!, where: SmithWhereUniqueInput!): Smith
  upsertSmith(where: SmithWhereUniqueInput!, create: SmithCreateInput!, update: SmithUpdateInput!): Smith!
  deleteSmith(where: SmithWhereUniqueInput!): Smith
  deleteManySmiths(where: SmithWhereInput): BatchPayload!
  createSoul(data: SoulCreateInput!): Soul!
  updateSoul(data: SoulUpdateInput!, where: SoulWhereUniqueInput!): Soul
  upsertSoul(where: SoulWhereUniqueInput!, create: SoulCreateInput!, update: SoulUpdateInput!): Soul!
  deleteSoul(where: SoulWhereUniqueInput!): Soul
  deleteManySouls(where: SoulWhereInput): BatchPayload!
  createSternum(data: SternumCreateInput!): Sternum!
  updateSternum(data: SternumUpdateInput!, where: SternumWhereUniqueInput!): Sternum
  upsertSternum(where: SternumWhereUniqueInput!, create: SternumCreateInput!, update: SternumUpdateInput!): Sternum!
  deleteSternum(where: SternumWhereUniqueInput!): Sternum
  deleteManySternums(where: SternumWhereInput): BatchPayload!
  createStigmata(data: StigmataCreateInput!): Stigmata!
  updateStigmata(data: StigmataUpdateInput!, where: StigmataWhereUniqueInput!): Stigmata
  upsertStigmata(where: StigmataWhereUniqueInput!, create: StigmataCreateInput!, update: StigmataUpdateInput!): Stigmata!
  deleteStigmata(where: StigmataWhereUniqueInput!): Stigmata
  deleteManyStigmatas(where: StigmataWhereInput): BatchPayload!
  createStrength(data: StrengthCreateInput!): Strength!
  updateStrength(data: StrengthUpdateInput!, where: StrengthWhereUniqueInput!): Strength
  upsertStrength(where: StrengthWhereUniqueInput!, create: StrengthCreateInput!, update: StrengthUpdateInput!): Strength!
  deleteStrength(where: StrengthWhereUniqueInput!): Strength
  deleteManyStrengths(where: StrengthWhereInput): BatchPayload!
  createSuffering(data: SufferingCreateInput!): Suffering!
  updateSuffering(data: SufferingUpdateInput!, where: SufferingWhereUniqueInput!): Suffering
  updateManySufferings(data: SufferingUpdateManyMutationInput!, where: SufferingWhereInput): BatchPayload!
  upsertSuffering(where: SufferingWhereUniqueInput!, create: SufferingCreateInput!, update: SufferingUpdateInput!): Suffering!
  deleteSuffering(where: SufferingWhereUniqueInput!): Suffering
  deleteManySufferings(where: SufferingWhereInput): BatchPayload!
  createSummoner(data: SummonerCreateInput!): Summoner!
  deleteSummoner(where: SummonerWhereUniqueInput!): Summoner
  deleteManySummoners(where: SummonerWhereInput): BatchPayload!
  createSupport(data: SupportCreateInput!): Support!
  updateSupport(data: SupportUpdateInput!, where: SupportWhereUniqueInput!): Support
  upsertSupport(where: SupportWhereUniqueInput!, create: SupportCreateInput!, update: SupportUpdateInput!): Support!
  deleteSupport(where: SupportWhereUniqueInput!): Support
  deleteManySupports(where: SupportWhereInput): BatchPayload!
  createTower(data: TowerCreateInput!): Tower!
  updateTower(data: TowerUpdateInput!, where: TowerWhereUniqueInput!): Tower
  upsertTower(where: TowerWhereUniqueInput!, create: TowerCreateInput!, update: TowerUpdateInput!): Tower!
  deleteTower(where: TowerWhereUniqueInput!): Tower
  deleteManyTowers(where: TowerWhereInput): BatchPayload!
  createToxicity(data: ToxicityCreateInput!): Toxicity!
  updateToxicity(data: ToxicityUpdateInput!, where: ToxicityWhereUniqueInput!): Toxicity
  updateManyToxicities(data: ToxicityUpdateManyMutationInput!, where: ToxicityWhereInput): BatchPayload!
  upsertToxicity(where: ToxicityWhereUniqueInput!, create: ToxicityCreateInput!, update: ToxicityUpdateInput!): Toxicity!
  deleteToxicity(where: ToxicityWhereUniqueInput!): Toxicity
  deleteManyToxicities(where: ToxicityWhereInput): BatchPayload!
  createTrauma(data: TraumaCreateInput!): Trauma!
  updateTrauma(data: TraumaUpdateInput!, where: TraumaWhereUniqueInput!): Trauma
  updateManyTraumas(data: TraumaUpdateManyMutationInput!, where: TraumaWhereInput): BatchPayload!
  upsertTrauma(where: TraumaWhereUniqueInput!, create: TraumaCreateInput!, update: TraumaUpdateInput!): Trauma!
  deleteTrauma(where: TraumaWhereUniqueInput!): Trauma
  deleteManyTraumas(where: TraumaWhereInput): BatchPayload!
  createTremor(data: TremorCreateInput!): Tremor!
  updateTremor(data: TremorUpdateInput!, where: TremorWhereUniqueInput!): Tremor
  upsertTremor(where: TremorWhereUniqueInput!, create: TremorCreateInput!, update: TremorUpdateInput!): Tremor!
  deleteTremor(where: TremorWhereUniqueInput!): Tremor
  deleteManyTremors(where: TremorWhereInput): BatchPayload!
  createVictim(data: VictimCreateInput!): Victim!
  updateVictim(data: VictimUpdateInput!, where: VictimWhereUniqueInput!): Victim
  upsertVictim(where: VictimWhereUniqueInput!, create: VictimCreateInput!, update: VictimUpdateInput!): Victim!
  deleteVictim(where: VictimWhereUniqueInput!): Victim
  deleteManyVictims(where: VictimWhereInput): BatchPayload!
  createVirtue(data: VirtueCreateInput!): Virtue!
  updateVirtue(data: VirtueUpdateInput!, where: VirtueWhereUniqueInput!): Virtue
  upsertVirtue(where: VirtueWhereUniqueInput!, create: VirtueCreateInput!, update: VirtueUpdateInput!): Virtue!
  deleteVirtue(where: VirtueWhereUniqueInput!): Virtue
  deleteManyVirtues(where: VirtueWhereInput): BatchPayload!
  createVolunteer(data: VolunteerCreateInput!): Volunteer!
  updateVolunteer(data: VolunteerUpdateInput!, where: VolunteerWhereUniqueInput!): Volunteer
  upsertVolunteer(where: VolunteerWhereUniqueInput!, create: VolunteerCreateInput!, update: VolunteerUpdateInput!): Volunteer!
  deleteVolunteer(where: VolunteerWhereUniqueInput!): Volunteer
  deleteManyVolunteers(where: VolunteerWhereInput): BatchPayload!
  createVulnerability(data: VulnerabilityCreateInput!): Vulnerability!
  updateVulnerability(data: VulnerabilityUpdateInput!, where: VulnerabilityWhereUniqueInput!): Vulnerability
  updateManyVulnerabilities(data: VulnerabilityUpdateManyMutationInput!, where: VulnerabilityWhereInput): BatchPayload!
  upsertVulnerability(where: VulnerabilityWhereUniqueInput!, create: VulnerabilityCreateInput!, update: VulnerabilityUpdateInput!): Vulnerability!
  deleteVulnerability(where: VulnerabilityWhereUniqueInput!): Vulnerability
  deleteManyVulnerabilities(where: VulnerabilityWhereInput): BatchPayload!
  createWall(data: WallCreateInput!): Wall!
  updateWall(data: WallUpdateInput!, where: WallWhereUniqueInput!): Wall
  upsertWall(where: WallWhereUniqueInput!, create: WallCreateInput!, update: WallUpdateInput!): Wall!
  deleteWall(where: WallWhereUniqueInput!): Wall
  deleteManyWalls(where: WallWhereInput): BatchPayload!
  createWish(data: WishCreateInput!): Wish!
  updateWish(data: WishUpdateInput!, where: WishWhereUniqueInput!): Wish
  upsertWish(where: WishWhereUniqueInput!, create: WishCreateInput!, update: WishUpdateInput!): Wish!
  deleteWish(where: WishWhereUniqueInput!): Wish
  deleteManyWishes(where: WishWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type Nail {
  id: ID!
  suffering(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering!]
}

type NailConnection {
  pageInfo: PageInfo!
  edges: [NailEdge]!
  aggregate: AggregateNail!
}

input NailCreateInput {
  id: ID
  suffering: SufferingCreateManyInput
}

input NailCreateManyInput {
  create: [NailCreateInput!]
  connect: [NailWhereUniqueInput!]
}

type NailEdge {
  node: Nail!
  cursor: String!
}

enum NailOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NailPreviousValues {
  id: ID!
}

input NailScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [NailScalarWhereInput!]
  OR: [NailScalarWhereInput!]
  NOT: [NailScalarWhereInput!]
}

type NailSubscriptionPayload {
  mutation: MutationType!
  node: Nail
  updatedFields: [String!]
  previousValues: NailPreviousValues
}

input NailSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NailWhereInput
  AND: [NailSubscriptionWhereInput!]
  OR: [NailSubscriptionWhereInput!]
  NOT: [NailSubscriptionWhereInput!]
}

input NailUpdateDataInput {
  suffering: SufferingUpdateManyInput
}

input NailUpdateInput {
  suffering: SufferingUpdateManyInput
}

input NailUpdateManyInput {
  create: [NailCreateInput!]
  update: [NailUpdateWithWhereUniqueNestedInput!]
  upsert: [NailUpsertWithWhereUniqueNestedInput!]
  delete: [NailWhereUniqueInput!]
  connect: [NailWhereUniqueInput!]
  set: [NailWhereUniqueInput!]
  disconnect: [NailWhereUniqueInput!]
  deleteMany: [NailScalarWhereInput!]
}

input NailUpdateWithWhereUniqueNestedInput {
  where: NailWhereUniqueInput!
  data: NailUpdateDataInput!
}

input NailUpsertWithWhereUniqueNestedInput {
  where: NailWhereUniqueInput!
  update: NailUpdateDataInput!
  create: NailCreateInput!
}

input NailWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  suffering_every: SufferingWhereInput
  suffering_some: SufferingWhereInput
  suffering_none: SufferingWhereInput
  AND: [NailWhereInput!]
  OR: [NailWhereInput!]
  NOT: [NailWhereInput!]
}

input NailWhereUniqueInput {
  id: ID
}

type Nightmare {
  id: ID!
  trauma(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma!]
  toxicity(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity!]
}

type NightmareConnection {
  pageInfo: PageInfo!
  edges: [NightmareEdge]!
  aggregate: AggregateNightmare!
}

input NightmareCreateInput {
  id: ID
  trauma: TraumaCreateManyInput
  toxicity: ToxicityCreateManyInput
}

input NightmareCreateManyInput {
  create: [NightmareCreateInput!]
  connect: [NightmareWhereUniqueInput!]
}

type NightmareEdge {
  node: Nightmare!
  cursor: String!
}

enum NightmareOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NightmarePreviousValues {
  id: ID!
}

input NightmareScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [NightmareScalarWhereInput!]
  OR: [NightmareScalarWhereInput!]
  NOT: [NightmareScalarWhereInput!]
}

type NightmareSubscriptionPayload {
  mutation: MutationType!
  node: Nightmare
  updatedFields: [String!]
  previousValues: NightmarePreviousValues
}

input NightmareSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NightmareWhereInput
  AND: [NightmareSubscriptionWhereInput!]
  OR: [NightmareSubscriptionWhereInput!]
  NOT: [NightmareSubscriptionWhereInput!]
}

input NightmareUpdateDataInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input NightmareUpdateInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input NightmareUpdateManyInput {
  create: [NightmareCreateInput!]
  update: [NightmareUpdateWithWhereUniqueNestedInput!]
  upsert: [NightmareUpsertWithWhereUniqueNestedInput!]
  delete: [NightmareWhereUniqueInput!]
  connect: [NightmareWhereUniqueInput!]
  set: [NightmareWhereUniqueInput!]
  disconnect: [NightmareWhereUniqueInput!]
  deleteMany: [NightmareScalarWhereInput!]
}

input NightmareUpdateWithWhereUniqueNestedInput {
  where: NightmareWhereUniqueInput!
  data: NightmareUpdateDataInput!
}

input NightmareUpsertWithWhereUniqueNestedInput {
  where: NightmareWhereUniqueInput!
  update: NightmareUpdateDataInput!
  create: NightmareCreateInput!
}

input NightmareWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  trauma_every: TraumaWhereInput
  trauma_some: TraumaWhereInput
  trauma_none: TraumaWhereInput
  toxicity_every: ToxicityWhereInput
  toxicity_some: ToxicityWhereInput
  toxicity_none: ToxicityWhereInput
  AND: [NightmareWhereInput!]
  OR: [NightmareWhereInput!]
  NOT: [NightmareWhereInput!]
}

input NightmareWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type Oath {
  id: ID!
  pledge(where: PledgeWhereInput, orderBy: PledgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pledge!]
  campaign(where: CampaignWhereInput, orderBy: CampaignOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Campaign!]
  crusade(where: CrusadeWhereInput, orderBy: CrusadeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Crusade!]
}

type OathConnection {
  pageInfo: PageInfo!
  edges: [OathEdge]!
  aggregate: AggregateOath!
}

input OathCreateInput {
  id: ID
  pledge: PledgeCreateManyInput
  campaign: CampaignCreateManyInput
  crusade: CrusadeCreateManyInput
}

input OathCreateManyInput {
  create: [OathCreateInput!]
  connect: [OathWhereUniqueInput!]
}

input OathCreateOneInput {
  create: OathCreateInput
  connect: OathWhereUniqueInput
}

type OathEdge {
  node: Oath!
  cursor: String!
}

enum OathOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OathPreviousValues {
  id: ID!
}

input OathScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [OathScalarWhereInput!]
  OR: [OathScalarWhereInput!]
  NOT: [OathScalarWhereInput!]
}

type OathSubscriptionPayload {
  mutation: MutationType!
  node: Oath
  updatedFields: [String!]
  previousValues: OathPreviousValues
}

input OathSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OathWhereInput
  AND: [OathSubscriptionWhereInput!]
  OR: [OathSubscriptionWhereInput!]
  NOT: [OathSubscriptionWhereInput!]
}

input OathUpdateDataInput {
  pledge: PledgeUpdateManyInput
  campaign: CampaignUpdateManyInput
  crusade: CrusadeUpdateManyInput
}

input OathUpdateInput {
  pledge: PledgeUpdateManyInput
  campaign: CampaignUpdateManyInput
  crusade: CrusadeUpdateManyInput
}

input OathUpdateManyInput {
  create: [OathCreateInput!]
  update: [OathUpdateWithWhereUniqueNestedInput!]
  upsert: [OathUpsertWithWhereUniqueNestedInput!]
  delete: [OathWhereUniqueInput!]
  connect: [OathWhereUniqueInput!]
  set: [OathWhereUniqueInput!]
  disconnect: [OathWhereUniqueInput!]
  deleteMany: [OathScalarWhereInput!]
}

input OathUpdateOneInput {
  create: OathCreateInput
  update: OathUpdateDataInput
  upsert: OathUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: OathWhereUniqueInput
}

input OathUpdateWithWhereUniqueNestedInput {
  where: OathWhereUniqueInput!
  data: OathUpdateDataInput!
}

input OathUpsertNestedInput {
  update: OathUpdateDataInput!
  create: OathCreateInput!
}

input OathUpsertWithWhereUniqueNestedInput {
  where: OathWhereUniqueInput!
  update: OathUpdateDataInput!
  create: OathCreateInput!
}

input OathWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  pledge_every: PledgeWhereInput
  pledge_some: PledgeWhereInput
  pledge_none: PledgeWhereInput
  campaign_every: CampaignWhereInput
  campaign_some: CampaignWhereInput
  campaign_none: CampaignWhereInput
  crusade_every: CrusadeWhereInput
  crusade_some: CrusadeWhereInput
  crusade_none: CrusadeWhereInput
  AND: [OathWhereInput!]
  OR: [OathWhereInput!]
  NOT: [OathWhereInput!]
}

input OathWhereUniqueInput {
  id: ID
}

type Obsession {
  id: ID!
  suffering(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering!]
  loyalty(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Loyalty!]
  honor(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Honor!]
  vulnerability(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vulnerability!]
}

type ObsessionConnection {
  pageInfo: PageInfo!
  edges: [ObsessionEdge]!
  aggregate: AggregateObsession!
}

input ObsessionCreateInput {
  id: ID
  suffering: SufferingCreateManyInput
  loyalty: LoyaltyCreateManyInput
  honor: HonorCreateManyInput
  vulnerability: VulnerabilityCreateManyInput
}

input ObsessionCreateManyInput {
  create: [ObsessionCreateInput!]
  connect: [ObsessionWhereUniqueInput!]
}

input ObsessionCreateOneInput {
  create: ObsessionCreateInput
  connect: ObsessionWhereUniqueInput
}

type ObsessionEdge {
  node: Obsession!
  cursor: String!
}

enum ObsessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ObsessionPreviousValues {
  id: ID!
}

input ObsessionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ObsessionScalarWhereInput!]
  OR: [ObsessionScalarWhereInput!]
  NOT: [ObsessionScalarWhereInput!]
}

type ObsessionSubscriptionPayload {
  mutation: MutationType!
  node: Obsession
  updatedFields: [String!]
  previousValues: ObsessionPreviousValues
}

input ObsessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ObsessionWhereInput
  AND: [ObsessionSubscriptionWhereInput!]
  OR: [ObsessionSubscriptionWhereInput!]
  NOT: [ObsessionSubscriptionWhereInput!]
}

input ObsessionUpdateDataInput {
  suffering: SufferingUpdateManyInput
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
  vulnerability: VulnerabilityUpdateManyInput
}

input ObsessionUpdateInput {
  suffering: SufferingUpdateManyInput
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
  vulnerability: VulnerabilityUpdateManyInput
}

input ObsessionUpdateManyInput {
  create: [ObsessionCreateInput!]
  update: [ObsessionUpdateWithWhereUniqueNestedInput!]
  upsert: [ObsessionUpsertWithWhereUniqueNestedInput!]
  delete: [ObsessionWhereUniqueInput!]
  connect: [ObsessionWhereUniqueInput!]
  set: [ObsessionWhereUniqueInput!]
  disconnect: [ObsessionWhereUniqueInput!]
  deleteMany: [ObsessionScalarWhereInput!]
}

input ObsessionUpdateOneInput {
  create: ObsessionCreateInput
  update: ObsessionUpdateDataInput
  upsert: ObsessionUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ObsessionWhereUniqueInput
}

input ObsessionUpdateWithWhereUniqueNestedInput {
  where: ObsessionWhereUniqueInput!
  data: ObsessionUpdateDataInput!
}

input ObsessionUpsertNestedInput {
  update: ObsessionUpdateDataInput!
  create: ObsessionCreateInput!
}

input ObsessionUpsertWithWhereUniqueNestedInput {
  where: ObsessionWhereUniqueInput!
  update: ObsessionUpdateDataInput!
  create: ObsessionCreateInput!
}

input ObsessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  suffering_every: SufferingWhereInput
  suffering_some: SufferingWhereInput
  suffering_none: SufferingWhereInput
  loyalty_every: LoyaltyWhereInput
  loyalty_some: LoyaltyWhereInput
  loyalty_none: LoyaltyWhereInput
  honor_every: HonorWhereInput
  honor_some: HonorWhereInput
  honor_none: HonorWhereInput
  vulnerability_every: VulnerabilityWhereInput
  vulnerability_some: VulnerabilityWhereInput
  vulnerability_none: VulnerabilityWhereInput
  AND: [ObsessionWhereInput!]
  OR: [ObsessionWhereInput!]
  NOT: [ObsessionWhereInput!]
}

input ObsessionWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Paladin {
  id: ID!
  oath(where: OathWhereInput, orderBy: OathOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Oath!]
}

type PaladinConnection {
  pageInfo: PageInfo!
  edges: [PaladinEdge]!
  aggregate: AggregatePaladin!
}

input PaladinCreateInput {
  id: ID
  oath: OathCreateManyInput
}

input PaladinCreateOneInput {
  create: PaladinCreateInput
  connect: PaladinWhereUniqueInput
}

type PaladinEdge {
  node: Paladin!
  cursor: String!
}

enum PaladinOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaladinPreviousValues {
  id: ID!
}

type PaladinSubscriptionPayload {
  mutation: MutationType!
  node: Paladin
  updatedFields: [String!]
  previousValues: PaladinPreviousValues
}

input PaladinSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaladinWhereInput
  AND: [PaladinSubscriptionWhereInput!]
  OR: [PaladinSubscriptionWhereInput!]
  NOT: [PaladinSubscriptionWhereInput!]
}

input PaladinUpdateDataInput {
  oath: OathUpdateManyInput
}

input PaladinUpdateInput {
  oath: OathUpdateManyInput
}

input PaladinUpdateOneInput {
  create: PaladinCreateInput
  update: PaladinUpdateDataInput
  upsert: PaladinUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PaladinWhereUniqueInput
}

input PaladinUpsertNestedInput {
  update: PaladinUpdateDataInput!
  create: PaladinCreateInput!
}

input PaladinWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  oath_every: OathWhereInput
  oath_some: OathWhereInput
  oath_none: OathWhereInput
  AND: [PaladinWhereInput!]
  OR: [PaladinWhereInput!]
  NOT: [PaladinWhereInput!]
}

input PaladinWhereUniqueInput {
  id: ID
}

type Path {
  id: ID!
  defect: Defect
  discontent: Discontent
  resentment: Resentment
  obsession: Obsession
  experience: Experience
  strength: Strength
  hope: Hope
}

type PathConnection {
  pageInfo: PageInfo!
  edges: [PathEdge]!
  aggregate: AggregatePath!
}

input PathCreateInput {
  id: ID
  defect: DefectCreateOneInput
  discontent: DiscontentCreateOneInput
  resentment: ResentmentCreateOneInput
  obsession: ObsessionCreateOneInput
  experience: ExperienceCreateOneInput
  strength: StrengthCreateOneInput
  hope: HopeCreateOneInput
}

input PathCreateOneInput {
  create: PathCreateInput
  connect: PathWhereUniqueInput
}

type PathEdge {
  node: Path!
  cursor: String!
}

enum PathOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PathPreviousValues {
  id: ID!
}

type PathSubscriptionPayload {
  mutation: MutationType!
  node: Path
  updatedFields: [String!]
  previousValues: PathPreviousValues
}

input PathSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PathWhereInput
  AND: [PathSubscriptionWhereInput!]
  OR: [PathSubscriptionWhereInput!]
  NOT: [PathSubscriptionWhereInput!]
}

input PathUpdateDataInput {
  defect: DefectUpdateOneInput
  discontent: DiscontentUpdateOneInput
  resentment: ResentmentUpdateOneInput
  obsession: ObsessionUpdateOneInput
  experience: ExperienceUpdateOneInput
  strength: StrengthUpdateOneInput
  hope: HopeUpdateOneInput
}

input PathUpdateInput {
  defect: DefectUpdateOneInput
  discontent: DiscontentUpdateOneInput
  resentment: ResentmentUpdateOneInput
  obsession: ObsessionUpdateOneInput
  experience: ExperienceUpdateOneInput
  strength: StrengthUpdateOneInput
  hope: HopeUpdateOneInput
}

input PathUpdateOneInput {
  create: PathCreateInput
  update: PathUpdateDataInput
  upsert: PathUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PathWhereUniqueInput
}

input PathUpsertNestedInput {
  update: PathUpdateDataInput!
  create: PathCreateInput!
}

input PathWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  defect: DefectWhereInput
  discontent: DiscontentWhereInput
  resentment: ResentmentWhereInput
  obsession: ObsessionWhereInput
  experience: ExperienceWhereInput
  strength: StrengthWhereInput
  hope: HopeWhereInput
  AND: [PathWhereInput!]
  OR: [PathWhereInput!]
  NOT: [PathWhereInput!]
}

input PathWhereUniqueInput {
  id: ID
}

type Pledge {
  id: ID!
  loyalty(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Loyalty!]
  honor(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Honor!]
}

type PledgeConnection {
  pageInfo: PageInfo!
  edges: [PledgeEdge]!
  aggregate: AggregatePledge!
}

input PledgeCreateInput {
  id: ID
  loyalty: LoyaltyCreateManyInput
  honor: HonorCreateManyInput
}

input PledgeCreateManyInput {
  create: [PledgeCreateInput!]
  connect: [PledgeWhereUniqueInput!]
}

type PledgeEdge {
  node: Pledge!
  cursor: String!
}

enum PledgeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PledgePreviousValues {
  id: ID!
}

input PledgeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [PledgeScalarWhereInput!]
  OR: [PledgeScalarWhereInput!]
  NOT: [PledgeScalarWhereInput!]
}

type PledgeSubscriptionPayload {
  mutation: MutationType!
  node: Pledge
  updatedFields: [String!]
  previousValues: PledgePreviousValues
}

input PledgeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PledgeWhereInput
  AND: [PledgeSubscriptionWhereInput!]
  OR: [PledgeSubscriptionWhereInput!]
  NOT: [PledgeSubscriptionWhereInput!]
}

input PledgeUpdateDataInput {
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
}

input PledgeUpdateInput {
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
}

input PledgeUpdateManyInput {
  create: [PledgeCreateInput!]
  update: [PledgeUpdateWithWhereUniqueNestedInput!]
  upsert: [PledgeUpsertWithWhereUniqueNestedInput!]
  delete: [PledgeWhereUniqueInput!]
  connect: [PledgeWhereUniqueInput!]
  set: [PledgeWhereUniqueInput!]
  disconnect: [PledgeWhereUniqueInput!]
  deleteMany: [PledgeScalarWhereInput!]
}

input PledgeUpdateWithWhereUniqueNestedInput {
  where: PledgeWhereUniqueInput!
  data: PledgeUpdateDataInput!
}

input PledgeUpsertWithWhereUniqueNestedInput {
  where: PledgeWhereUniqueInput!
  update: PledgeUpdateDataInput!
  create: PledgeCreateInput!
}

input PledgeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  loyalty_every: LoyaltyWhereInput
  loyalty_some: LoyaltyWhereInput
  loyalty_none: LoyaltyWhereInput
  honor_every: HonorWhereInput
  honor_some: HonorWhereInput
  honor_none: HonorWhereInput
  AND: [PledgeWhereInput!]
  OR: [PledgeWhereInput!]
  NOT: [PledgeWhereInput!]
}

input PledgeWhereUniqueInput {
  id: ID
}

type Prayer {
  id: ID!
  process: Process
  path: Path
}

type PrayerConnection {
  pageInfo: PageInfo!
  edges: [PrayerEdge]!
  aggregate: AggregatePrayer!
}

input PrayerCreateInput {
  id: ID
  process: ProcessCreateOneInput
  path: PathCreateOneInput
}

input PrayerCreateOneInput {
  create: PrayerCreateInput
  connect: PrayerWhereUniqueInput
}

type PrayerEdge {
  node: Prayer!
  cursor: String!
}

enum PrayerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PrayerPreviousValues {
  id: ID!
}

type PrayerSubscriptionPayload {
  mutation: MutationType!
  node: Prayer
  updatedFields: [String!]
  previousValues: PrayerPreviousValues
}

input PrayerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PrayerWhereInput
  AND: [PrayerSubscriptionWhereInput!]
  OR: [PrayerSubscriptionWhereInput!]
  NOT: [PrayerSubscriptionWhereInput!]
}

input PrayerUpdateDataInput {
  process: ProcessUpdateOneInput
  path: PathUpdateOneInput
}

input PrayerUpdateInput {
  process: ProcessUpdateOneInput
  path: PathUpdateOneInput
}

input PrayerUpdateOneInput {
  create: PrayerCreateInput
  update: PrayerUpdateDataInput
  upsert: PrayerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: PrayerWhereUniqueInput
}

input PrayerUpsertNestedInput {
  update: PrayerUpdateDataInput!
  create: PrayerCreateInput!
}

input PrayerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  process: ProcessWhereInput
  path: PathWhereInput
  AND: [PrayerWhereInput!]
  OR: [PrayerWhereInput!]
  NOT: [PrayerWhereInput!]
}

input PrayerWhereUniqueInput {
  id: ID
}

type Pride {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type PrideConnection {
  pageInfo: PageInfo!
  edges: [PrideEdge]!
  aggregate: AggregatePride!
}

input PrideCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input PrideCreateManyInput {
  create: [PrideCreateInput!]
  connect: [PrideWhereUniqueInput!]
}

type PrideEdge {
  node: Pride!
  cursor: String!
}

enum PrideOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type PridePreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input PrideScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [PrideScalarWhereInput!]
  OR: [PrideScalarWhereInput!]
  NOT: [PrideScalarWhereInput!]
}

type PrideSubscriptionPayload {
  mutation: MutationType!
  node: Pride
  updatedFields: [String!]
  previousValues: PridePreviousValues
}

input PrideSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PrideWhereInput
  AND: [PrideSubscriptionWhereInput!]
  OR: [PrideSubscriptionWhereInput!]
  NOT: [PrideSubscriptionWhereInput!]
}

input PrideUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input PrideUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input PrideUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input PrideUpdateManyInput {
  create: [PrideCreateInput!]
  update: [PrideUpdateWithWhereUniqueNestedInput!]
  upsert: [PrideUpsertWithWhereUniqueNestedInput!]
  delete: [PrideWhereUniqueInput!]
  connect: [PrideWhereUniqueInput!]
  set: [PrideWhereUniqueInput!]
  disconnect: [PrideWhereUniqueInput!]
  deleteMany: [PrideScalarWhereInput!]
  updateMany: [PrideUpdateManyWithWhereNestedInput!]
}

input PrideUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input PrideUpdateManyWithWhereNestedInput {
  where: PrideScalarWhereInput!
  data: PrideUpdateManyDataInput!
}

input PrideUpdateWithWhereUniqueNestedInput {
  where: PrideWhereUniqueInput!
  data: PrideUpdateDataInput!
}

input PrideUpsertWithWhereUniqueNestedInput {
  where: PrideWhereUniqueInput!
  update: PrideUpdateDataInput!
  create: PrideCreateInput!
}

input PrideWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [PrideWhereInput!]
  OR: [PrideWhereInput!]
  NOT: [PrideWhereInput!]
}

input PrideWhereUniqueInput {
  id: ID
}

type Process {
  id: ID!
  act: Act
  affliction: Affliction
  body: Body
  construct: Construct
  oath: Oath
  shield: Shield
  stigmata: Stigmata
  virtue: Virtue
  wish: Wish
}

type ProcessConnection {
  pageInfo: PageInfo!
  edges: [ProcessEdge]!
  aggregate: AggregateProcess!
}

input ProcessCreateInput {
  id: ID
  act: ActCreateOneInput
  affliction: AfflictionCreateOneInput
  body: BodyCreateOneInput
  construct: ConstructCreateOneInput
  oath: OathCreateOneInput
  shield: ShieldCreateOneInput
  stigmata: StigmataCreateOneInput
  virtue: VirtueCreateOneInput
  wish: WishCreateOneInput
}

input ProcessCreateOneInput {
  create: ProcessCreateInput
  connect: ProcessWhereUniqueInput
}

type ProcessEdge {
  node: Process!
  cursor: String!
}

enum ProcessOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProcessPreviousValues {
  id: ID!
}

type ProcessSubscriptionPayload {
  mutation: MutationType!
  node: Process
  updatedFields: [String!]
  previousValues: ProcessPreviousValues
}

input ProcessSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProcessWhereInput
  AND: [ProcessSubscriptionWhereInput!]
  OR: [ProcessSubscriptionWhereInput!]
  NOT: [ProcessSubscriptionWhereInput!]
}

input ProcessUpdateDataInput {
  act: ActUpdateOneInput
  affliction: AfflictionUpdateOneInput
  body: BodyUpdateOneInput
  construct: ConstructUpdateOneInput
  oath: OathUpdateOneInput
  shield: ShieldUpdateOneInput
  stigmata: StigmataUpdateOneInput
  virtue: VirtueUpdateOneInput
  wish: WishUpdateOneInput
}

input ProcessUpdateInput {
  act: ActUpdateOneInput
  affliction: AfflictionUpdateOneInput
  body: BodyUpdateOneInput
  construct: ConstructUpdateOneInput
  oath: OathUpdateOneInput
  shield: ShieldUpdateOneInput
  stigmata: StigmataUpdateOneInput
  virtue: VirtueUpdateOneInput
  wish: WishUpdateOneInput
}

input ProcessUpdateOneInput {
  create: ProcessCreateInput
  update: ProcessUpdateDataInput
  upsert: ProcessUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProcessWhereUniqueInput
}

input ProcessUpsertNestedInput {
  update: ProcessUpdateDataInput!
  create: ProcessCreateInput!
}

input ProcessWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  act: ActWhereInput
  affliction: AfflictionWhereInput
  body: BodyWhereInput
  construct: ConstructWhereInput
  oath: OathWhereInput
  shield: ShieldWhereInput
  stigmata: StigmataWhereInput
  virtue: VirtueWhereInput
  wish: WishWhereInput
  AND: [ProcessWhereInput!]
  OR: [ProcessWhereInput!]
  NOT: [ProcessWhereInput!]
}

input ProcessWhereUniqueInput {
  id: ID
}

type Query {
  acceptance(where: AcceptanceWhereUniqueInput!): Acceptance
  acceptances(where: AcceptanceWhereInput, orderBy: AcceptanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Acceptance]!
  acceptancesConnection(where: AcceptanceWhereInput, orderBy: AcceptanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AcceptanceConnection!
  act(where: ActWhereUniqueInput!): Act
  acts(where: ActWhereInput, orderBy: ActOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Act]!
  actsConnection(where: ActWhereInput, orderBy: ActOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ActConnection!
  affliction(where: AfflictionWhereUniqueInput!): Affliction
  afflictions(where: AfflictionWhereInput, orderBy: AfflictionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Affliction]!
  afflictionsConnection(where: AfflictionWhereInput, orderBy: AfflictionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AfflictionConnection!
  anger(where: AngerWhereUniqueInput!): Anger
  angers(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger]!
  angersConnection(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AngerConnection!
  armor(where: ArmorWhereUniqueInput!): Armor
  armors(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Armor]!
  armorsConnection(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ArmorConnection!
  body(where: BodyWhereUniqueInput!): Body
  bodies(where: BodyWhereInput, orderBy: BodyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Body]!
  bodiesConnection(where: BodyWhereInput, orderBy: BodyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BodyConnection!
  boundary(where: BoundaryWhereUniqueInput!): Boundary
  boundaries(where: BoundaryWhereInput, orderBy: BoundaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boundary]!
  boundariesConnection(where: BoundaryWhereInput, orderBy: BoundaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BoundaryConnection!
  brain(where: BrainWhereUniqueInput!): Brain
  brains(where: BrainWhereInput, orderBy: BrainOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Brain]!
  brainsConnection(where: BrainWhereInput, orderBy: BrainOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BrainConnection!
  campaign(where: CampaignWhereUniqueInput!): Campaign
  campaigns(where: CampaignWhereInput, orderBy: CampaignOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Campaign]!
  campaignsConnection(where: CampaignWhereInput, orderBy: CampaignOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CampaignConnection!
  characters(where: CharactersWhereUniqueInput!): Characters
  characterses(where: CharactersWhereInput, orderBy: CharactersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Characters]!
  charactersesConnection(where: CharactersWhereInput, orderBy: CharactersOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CharactersConnection!
  compassion(where: CompassionWhereUniqueInput!): Compassion
  compassions(where: CompassionWhereInput, orderBy: CompassionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Compassion]!
  compassionsConnection(where: CompassionWhereInput, orderBy: CompassionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompassionConnection!
  confusion(where: ConfusionWhereUniqueInput!): Confusion
  confusions(where: ConfusionWhereInput, orderBy: ConfusionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Confusion]!
  confusionsConnection(where: ConfusionWhereInput, orderBy: ConfusionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConfusionConnection!
  congregant(where: CongregantWhereUniqueInput!): Congregant
  congregants(where: CongregantWhereInput, orderBy: CongregantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Congregant]!
  congregantsConnection(where: CongregantWhereInput, orderBy: CongregantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CongregantConnection!
  construct(where: ConstructWhereUniqueInput!): Construct
  constructs(where: ConstructWhereInput, orderBy: ConstructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Construct]!
  constructsConnection(where: ConstructWhereInput, orderBy: ConstructOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ConstructConnection!
  courage(where: CourageWhereUniqueInput!): Courage
  courages(where: CourageWhereInput, orderBy: CourageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Courage]!
  couragesConnection(where: CourageWhereInput, orderBy: CourageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourageConnection!
  cross(where: CrossWhereUniqueInput!): Cross
  crosses(where: CrossWhereInput, orderBy: CrossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cross]!
  crossesConnection(where: CrossWhereInput, orderBy: CrossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CrossConnection!
  crown(where: CrownWhereUniqueInput!): Crown
  crowns(where: CrownWhereInput, orderBy: CrownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Crown]!
  crownsConnection(where: CrownWhereInput, orderBy: CrownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CrownConnection!
  crusade(where: CrusadeWhereUniqueInput!): Crusade
  crusades(where: CrusadeWhereInput, orderBy: CrusadeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Crusade]!
  crusadesConnection(where: CrusadeWhereInput, orderBy: CrusadeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CrusadeConnection!
  defect(where: DefectWhereUniqueInput!): Defect
  defects(where: DefectWhereInput, orderBy: DefectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Defect]!
  defectsConnection(where: DefectWhereInput, orderBy: DefectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DefectConnection!
  delirium(where: DeliriumWhereUniqueInput!): Delirium
  deliriums(where: DeliriumWhereInput, orderBy: DeliriumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Delirium]!
  deliriumsConnection(where: DeliriumWhereInput, orderBy: DeliriumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DeliriumConnection!
  denial(where: DenialWhereUniqueInput!): Denial
  denials(where: DenialWhereInput, orderBy: DenialOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Denial]!
  denialsConnection(where: DenialWhereInput, orderBy: DenialOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DenialConnection!
  discontent(where: DiscontentWhereUniqueInput!): Discontent
  discontents(where: DiscontentWhereInput, orderBy: DiscontentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Discontent]!
  discontentsConnection(where: DiscontentWhereInput, orderBy: DiscontentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DiscontentConnection!
  dream(where: DreamWhereUniqueInput!): Dream
  dreams(where: DreamWhereInput, orderBy: DreamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Dream]!
  dreamsConnection(where: DreamWhereInput, orderBy: DreamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DreamConnection!
  experience(where: ExperienceWhereUniqueInput!): Experience
  experiences(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience]!
  experiencesConnection(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExperienceConnection!
  face(where: FaceWhereUniqueInput!): Face
  faces(where: FaceWhereInput, orderBy: FaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Face]!
  facesConnection(where: FaceWhereInput, orderBy: FaceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FaceConnection!
  fear(where: FearWhereUniqueInput!): Fear
  fears(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear]!
  fearsConnection(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FearConnection!
  feeling(where: FeelingWhereUniqueInput!): Feeling
  feelings(where: FeelingWhereInput, orderBy: FeelingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Feeling]!
  feelingsConnection(where: FeelingWhereInput, orderBy: FeelingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FeelingConnection!
  fun(where: FunWhereUniqueInput!): Fun
  funs(where: FunWhereInput, orderBy: FunOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fun]!
  funsConnection(where: FunWhereInput, orderBy: FunOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FunConnection!
  gash(where: GashWhereUniqueInput!): Gash
  gashes(where: GashWhereInput, orderBy: GashOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gash]!
  gashesConnection(where: GashWhereInput, orderBy: GashOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GashConnection!
  gate(where: GateWhereUniqueInput!): Gate
  gates(where: GateWhereInput, orderBy: GateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gate]!
  gatesConnection(where: GateWhereInput, orderBy: GateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GateConnection!
  genie(where: GenieWhereUniqueInput!): Genie
  genies(where: GenieWhereInput, orderBy: GenieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Genie]!
  geniesConnection(where: GenieWhereInput, orderBy: GenieOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GenieConnection!
  gratitude(where: GratitudeWhereUniqueInput!): Gratitude
  gratitudes(where: GratitudeWhereInput, orderBy: GratitudeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gratitude]!
  gratitudesConnection(where: GratitudeWhereInput, orderBy: GratitudeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GratitudeConnection!
  guardian(where: GuardianWhereUniqueInput!): Guardian
  guardians(where: GuardianWhereInput, orderBy: GuardianOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Guardian]!
  guardiansConnection(where: GuardianWhereInput, orderBy: GuardianOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GuardianConnection!
  gut(where: GutWhereUniqueInput!): Gut
  guts(where: GutWhereInput, orderBy: GutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Gut]!
  gutsConnection(where: GutWhereInput, orderBy: GutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GutConnection!
  has(where: HasWhereUniqueInput!): Has
  hases(where: HasWhereInput, orderBy: HasOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Has]!
  hasesConnection(where: HasWhereInput, orderBy: HasOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HasConnection!
  heart(where: HeartWhereUniqueInput!): Heart
  hearts(where: HeartWhereInput, orderBy: HeartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Heart]!
  heartsConnection(where: HeartWhereInput, orderBy: HeartOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HeartConnection!
  higherPower(where: HigherPowerWhereUniqueInput!): HigherPower
  higherPowers(where: HigherPowerWhereInput, orderBy: HigherPowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HigherPower]!
  higherPowersConnection(where: HigherPowerWhereInput, orderBy: HigherPowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HigherPowerConnection!
  honor(where: HonorWhereUniqueInput!): Honor
  honors(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Honor]!
  honorsConnection(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HonorConnection!
  hope(where: HopeWhereUniqueInput!): Hope
  hopes(where: HopeWhereInput, orderBy: HopeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hope]!
  hopesConnection(where: HopeWhereInput, orderBy: HopeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HopeConnection!
  impatience(where: ImpatienceWhereUniqueInput!): Impatience
  impatiences(where: ImpatienceWhereInput, orderBy: ImpatienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Impatience]!
  impatiencesConnection(where: ImpatienceWhereInput, orderBy: ImpatienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImpatienceConnection!
  infection(where: InfectionWhereUniqueInput!): Infection
  infections(where: InfectionWhereInput, orderBy: InfectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Infection]!
  infectionsConnection(where: InfectionWhereInput, orderBy: InfectionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InfectionConnection!
  inventory(where: InventoryWhereUniqueInput!): Inventory
  inventories(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Inventory]!
  inventoriesConnection(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryConnection!
  irritability(where: IrritabilityWhereUniqueInput!): Irritability
  irritabilities(where: IrritabilityWhereInput, orderBy: IrritabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Irritability]!
  irritabilitiesConnection(where: IrritabilityWhereInput, orderBy: IrritabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): IrritabilityConnection!
  joy(where: JoyWhereUniqueInput!): Joy
  joys(where: JoyWhereInput, orderBy: JoyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Joy]!
  joysConnection(where: JoyWhereInput, orderBy: JoyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): JoyConnection!
  love(where: LoveWhereUniqueInput!): Love
  loves(where: LoveWhereInput, orderBy: LoveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Love]!
  lovesConnection(where: LoveWhereInput, orderBy: LoveOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LoveConnection!
  loyalty(where: LoyaltyWhereUniqueInput!): Loyalty
  loyalties(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Loyalty]!
  loyaltiesConnection(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LoyaltyConnection!
  martyr(where: MartyrWhereUniqueInput!): Martyr
  martyrs(where: MartyrWhereInput, orderBy: MartyrOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Martyr]!
  martyrsConnection(where: MartyrWhereInput, orderBy: MartyrOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MartyrConnection!
  mind(where: MindWhereUniqueInput!): Mind
  minds(where: MindWhereInput, orderBy: MindOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mind]!
  mindsConnection(where: MindWhereInput, orderBy: MindOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MindConnection!
  mouth(where: MouthWhereUniqueInput!): Mouth
  mouths(where: MouthWhereInput, orderBy: MouthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Mouth]!
  mouthsConnection(where: MouthWhereInput, orderBy: MouthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MouthConnection!
  nail(where: NailWhereUniqueInput!): Nail
  nails(where: NailWhereInput, orderBy: NailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Nail]!
  nailsConnection(where: NailWhereInput, orderBy: NailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NailConnection!
  nightmare(where: NightmareWhereUniqueInput!): Nightmare
  nightmares(where: NightmareWhereInput, orderBy: NightmareOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Nightmare]!
  nightmaresConnection(where: NightmareWhereInput, orderBy: NightmareOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NightmareConnection!
  oath(where: OathWhereUniqueInput!): Oath
  oaths(where: OathWhereInput, orderBy: OathOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Oath]!
  oathsConnection(where: OathWhereInput, orderBy: OathOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OathConnection!
  obsession(where: ObsessionWhereUniqueInput!): Obsession
  obsessions(where: ObsessionWhereInput, orderBy: ObsessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Obsession]!
  obsessionsConnection(where: ObsessionWhereInput, orderBy: ObsessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ObsessionConnection!
  paladin(where: PaladinWhereUniqueInput!): Paladin
  paladins(where: PaladinWhereInput, orderBy: PaladinOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Paladin]!
  paladinsConnection(where: PaladinWhereInput, orderBy: PaladinOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaladinConnection!
  path(where: PathWhereUniqueInput!): Path
  paths(where: PathWhereInput, orderBy: PathOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Path]!
  pathsConnection(where: PathWhereInput, orderBy: PathOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PathConnection!
  pledge(where: PledgeWhereUniqueInput!): Pledge
  pledges(where: PledgeWhereInput, orderBy: PledgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pledge]!
  pledgesConnection(where: PledgeWhereInput, orderBy: PledgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PledgeConnection!
  prayer(where: PrayerWhereUniqueInput!): Prayer
  prayers(where: PrayerWhereInput, orderBy: PrayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Prayer]!
  prayersConnection(where: PrayerWhereInput, orderBy: PrayerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PrayerConnection!
  pride(where: PrideWhereUniqueInput!): Pride
  prides(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride]!
  pridesConnection(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PrideConnection!
  process(where: ProcessWhereUniqueInput!): Process
  processes(where: ProcessWhereInput, orderBy: ProcessOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Process]!
  processesConnection(where: ProcessWhereInput, orderBy: ProcessOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProcessConnection!
  resentment(where: ResentmentWhereUniqueInput!): Resentment
  resentments(where: ResentmentWhereInput, orderBy: ResentmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Resentment]!
  resentmentsConnection(where: ResentmentWhereInput, orderBy: ResentmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ResentmentConnection!
  sacrifice(where: SacrificeWhereUniqueInput!): Sacrifice
  sacrifices(where: SacrificeWhereInput, orderBy: SacrificeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sacrifice]!
  sacrificesConnection(where: SacrificeWhereInput, orderBy: SacrificeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SacrificeConnection!
  salvation(where: SalvationWhereUniqueInput!): Salvation
  salvations(where: SalvationWhereInput, orderBy: SalvationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Salvation]!
  salvationsConnection(where: SalvationWhereInput, orderBy: SalvationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SalvationConnection!
  sarcasm(where: SarcasmWhereUniqueInput!): Sarcasm
  sarcasms(where: SarcasmWhereInput, orderBy: SarcasmOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sarcasm]!
  sarcasmsConnection(where: SarcasmWhereInput, orderBy: SarcasmOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SarcasmConnection!
  scar(where: ScarWhereUniqueInput!): Scar
  scars(where: ScarWhereInput, orderBy: ScarOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Scar]!
  scarsConnection(where: ScarWhereInput, orderBy: ScarOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScarConnection!
  seeker(where: SeekerWhereUniqueInput!): Seeker
  seekers(where: SeekerWhereInput, orderBy: SeekerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Seeker]!
  seekersConnection(where: SeekerWhereInput, orderBy: SeekerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SeekerConnection!
  self(where: SelfWhereUniqueInput!): Self
  selves(where: SelfWhereInput, orderBy: SelfOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Self]!
  selvesConnection(where: SelfWhereInput, orderBy: SelfOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SelfConnection!
  selfPity(where: SelfPityWhereUniqueInput!): SelfPity
  selfPities(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity]!
  selfPitiesConnection(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SelfPityConnection!
  service(where: ServiceWhereUniqueInput!): Service
  services(where: ServiceWhereInput, orderBy: ServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Service]!
  servicesConnection(where: ServiceWhereInput, orderBy: ServiceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ServiceConnection!
  shield(where: ShieldWhereUniqueInput!): Shield
  shields(where: ShieldWhereInput, orderBy: ShieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Shield]!
  shieldsConnection(where: ShieldWhereInput, orderBy: ShieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ShieldConnection!
  silence(where: SilenceWhereUniqueInput!): Silence
  silences(where: SilenceWhereInput, orderBy: SilenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Silence]!
  silencesConnection(where: SilenceWhereInput, orderBy: SilenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SilenceConnection!
  skin(where: SkinWhereUniqueInput!): Skin
  skins(where: SkinWhereInput, orderBy: SkinOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Skin]!
  skinsConnection(where: SkinWhereInput, orderBy: SkinOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SkinConnection!
  smith(where: SmithWhereUniqueInput!): Smith
  smiths(where: SmithWhereInput, orderBy: SmithOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Smith]!
  smithsConnection(where: SmithWhereInput, orderBy: SmithOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SmithConnection!
  soul(where: SoulWhereUniqueInput!): Soul
  souls(where: SoulWhereInput, orderBy: SoulOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Soul]!
  soulsConnection(where: SoulWhereInput, orderBy: SoulOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SoulConnection!
  sternum(where: SternumWhereUniqueInput!): Sternum
  sternums(where: SternumWhereInput, orderBy: SternumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sternum]!
  sternumsConnection(where: SternumWhereInput, orderBy: SternumOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SternumConnection!
  stigmata(where: StigmataWhereUniqueInput!): Stigmata
  stigmatas(where: StigmataWhereInput, orderBy: StigmataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Stigmata]!
  stigmatasConnection(where: StigmataWhereInput, orderBy: StigmataOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StigmataConnection!
  strength(where: StrengthWhereUniqueInput!): Strength
  strengths(where: StrengthWhereInput, orderBy: StrengthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Strength]!
  strengthsConnection(where: StrengthWhereInput, orderBy: StrengthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StrengthConnection!
  suffering(where: SufferingWhereUniqueInput!): Suffering
  sufferings(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering]!
  sufferingsConnection(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SufferingConnection!
  summoner(where: SummonerWhereUniqueInput!): Summoner
  summoners(where: SummonerWhereInput, orderBy: SummonerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Summoner]!
  summonersConnection(where: SummonerWhereInput, orderBy: SummonerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SummonerConnection!
  support(where: SupportWhereUniqueInput!): Support
  supports(where: SupportWhereInput, orderBy: SupportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Support]!
  supportsConnection(where: SupportWhereInput, orderBy: SupportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SupportConnection!
  tower(where: TowerWhereUniqueInput!): Tower
  towers(where: TowerWhereInput, orderBy: TowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tower]!
  towersConnection(where: TowerWhereInput, orderBy: TowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TowerConnection!
  toxicity(where: ToxicityWhereUniqueInput!): Toxicity
  toxicities(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity]!
  toxicitiesConnection(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ToxicityConnection!
  trauma(where: TraumaWhereUniqueInput!): Trauma
  traumas(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma]!
  traumasConnection(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TraumaConnection!
  tremor(where: TremorWhereUniqueInput!): Tremor
  tremors(where: TremorWhereInput, orderBy: TremorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Tremor]!
  tremorsConnection(where: TremorWhereInput, orderBy: TremorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TremorConnection!
  victim(where: VictimWhereUniqueInput!): Victim
  victims(where: VictimWhereInput, orderBy: VictimOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Victim]!
  victimsConnection(where: VictimWhereInput, orderBy: VictimOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VictimConnection!
  virtue(where: VirtueWhereUniqueInput!): Virtue
  virtues(where: VirtueWhereInput, orderBy: VirtueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Virtue]!
  virtuesConnection(where: VirtueWhereInput, orderBy: VirtueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VirtueConnection!
  volunteer(where: VolunteerWhereUniqueInput!): Volunteer
  volunteers(where: VolunteerWhereInput, orderBy: VolunteerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Volunteer]!
  volunteersConnection(where: VolunteerWhereInput, orderBy: VolunteerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VolunteerConnection!
  vulnerability(where: VulnerabilityWhereUniqueInput!): Vulnerability
  vulnerabilities(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vulnerability]!
  vulnerabilitiesConnection(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VulnerabilityConnection!
  wall(where: WallWhereUniqueInput!): Wall
  walls(where: WallWhereInput, orderBy: WallOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Wall]!
  wallsConnection(where: WallWhereInput, orderBy: WallOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WallConnection!
  wish(where: WishWhereUniqueInput!): Wish
  wishes(where: WishWhereInput, orderBy: WishOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Wish]!
  wishesConnection(where: WishWhereInput, orderBy: WishOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WishConnection!
  node(id: ID!): Node
}

type Resentment {
  id: ID!
  anger(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger!]
  selfPity(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity!]
  fear(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear!]
  pride(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride!]
}

type ResentmentConnection {
  pageInfo: PageInfo!
  edges: [ResentmentEdge]!
  aggregate: AggregateResentment!
}

input ResentmentCreateInput {
  id: ID
  anger: AngerCreateManyInput
  selfPity: SelfPityCreateManyInput
  fear: FearCreateManyInput
  pride: PrideCreateManyInput
}

input ResentmentCreateManyInput {
  create: [ResentmentCreateInput!]
  connect: [ResentmentWhereUniqueInput!]
}

input ResentmentCreateOneInput {
  create: ResentmentCreateInput
  connect: ResentmentWhereUniqueInput
}

type ResentmentEdge {
  node: Resentment!
  cursor: String!
}

enum ResentmentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ResentmentPreviousValues {
  id: ID!
}

input ResentmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ResentmentScalarWhereInput!]
  OR: [ResentmentScalarWhereInput!]
  NOT: [ResentmentScalarWhereInput!]
}

type ResentmentSubscriptionPayload {
  mutation: MutationType!
  node: Resentment
  updatedFields: [String!]
  previousValues: ResentmentPreviousValues
}

input ResentmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ResentmentWhereInput
  AND: [ResentmentSubscriptionWhereInput!]
  OR: [ResentmentSubscriptionWhereInput!]
  NOT: [ResentmentSubscriptionWhereInput!]
}

input ResentmentUpdateDataInput {
  anger: AngerUpdateManyInput
  selfPity: SelfPityUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
}

input ResentmentUpdateInput {
  anger: AngerUpdateManyInput
  selfPity: SelfPityUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
}

input ResentmentUpdateManyInput {
  create: [ResentmentCreateInput!]
  update: [ResentmentUpdateWithWhereUniqueNestedInput!]
  upsert: [ResentmentUpsertWithWhereUniqueNestedInput!]
  delete: [ResentmentWhereUniqueInput!]
  connect: [ResentmentWhereUniqueInput!]
  set: [ResentmentWhereUniqueInput!]
  disconnect: [ResentmentWhereUniqueInput!]
  deleteMany: [ResentmentScalarWhereInput!]
}

input ResentmentUpdateOneInput {
  create: ResentmentCreateInput
  update: ResentmentUpdateDataInput
  upsert: ResentmentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ResentmentWhereUniqueInput
}

input ResentmentUpdateWithWhereUniqueNestedInput {
  where: ResentmentWhereUniqueInput!
  data: ResentmentUpdateDataInput!
}

input ResentmentUpsertNestedInput {
  update: ResentmentUpdateDataInput!
  create: ResentmentCreateInput!
}

input ResentmentUpsertWithWhereUniqueNestedInput {
  where: ResentmentWhereUniqueInput!
  update: ResentmentUpdateDataInput!
  create: ResentmentCreateInput!
}

input ResentmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  anger_every: AngerWhereInput
  anger_some: AngerWhereInput
  anger_none: AngerWhereInput
  selfPity_every: SelfPityWhereInput
  selfPity_some: SelfPityWhereInput
  selfPity_none: SelfPityWhereInput
  fear_every: FearWhereInput
  fear_some: FearWhereInput
  fear_none: FearWhereInput
  pride_every: PrideWhereInput
  pride_some: PrideWhereInput
  pride_none: PrideWhereInput
  AND: [ResentmentWhereInput!]
  OR: [ResentmentWhereInput!]
  NOT: [ResentmentWhereInput!]
}

input ResentmentWhereUniqueInput {
  id: ID
}

type Sacrifice {
  id: ID!
  courage(where: CourageWhereInput, orderBy: CourageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Courage!]
  compassion(where: CompassionWhereInput, orderBy: CompassionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Compassion!]
}

type SacrificeConnection {
  pageInfo: PageInfo!
  edges: [SacrificeEdge]!
  aggregate: AggregateSacrifice!
}

input SacrificeCreateInput {
  id: ID
  courage: CourageCreateManyInput
  compassion: CompassionCreateManyInput
}

input SacrificeCreateManyInput {
  create: [SacrificeCreateInput!]
  connect: [SacrificeWhereUniqueInput!]
}

type SacrificeEdge {
  node: Sacrifice!
  cursor: String!
}

enum SacrificeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SacrificePreviousValues {
  id: ID!
}

input SacrificeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SacrificeScalarWhereInput!]
  OR: [SacrificeScalarWhereInput!]
  NOT: [SacrificeScalarWhereInput!]
}

type SacrificeSubscriptionPayload {
  mutation: MutationType!
  node: Sacrifice
  updatedFields: [String!]
  previousValues: SacrificePreviousValues
}

input SacrificeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SacrificeWhereInput
  AND: [SacrificeSubscriptionWhereInput!]
  OR: [SacrificeSubscriptionWhereInput!]
  NOT: [SacrificeSubscriptionWhereInput!]
}

input SacrificeUpdateDataInput {
  courage: CourageUpdateManyInput
  compassion: CompassionUpdateManyInput
}

input SacrificeUpdateInput {
  courage: CourageUpdateManyInput
  compassion: CompassionUpdateManyInput
}

input SacrificeUpdateManyInput {
  create: [SacrificeCreateInput!]
  update: [SacrificeUpdateWithWhereUniqueNestedInput!]
  upsert: [SacrificeUpsertWithWhereUniqueNestedInput!]
  delete: [SacrificeWhereUniqueInput!]
  connect: [SacrificeWhereUniqueInput!]
  set: [SacrificeWhereUniqueInput!]
  disconnect: [SacrificeWhereUniqueInput!]
  deleteMany: [SacrificeScalarWhereInput!]
}

input SacrificeUpdateWithWhereUniqueNestedInput {
  where: SacrificeWhereUniqueInput!
  data: SacrificeUpdateDataInput!
}

input SacrificeUpsertWithWhereUniqueNestedInput {
  where: SacrificeWhereUniqueInput!
  update: SacrificeUpdateDataInput!
  create: SacrificeCreateInput!
}

input SacrificeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  courage_every: CourageWhereInput
  courage_some: CourageWhereInput
  courage_none: CourageWhereInput
  compassion_every: CompassionWhereInput
  compassion_some: CompassionWhereInput
  compassion_none: CompassionWhereInput
  AND: [SacrificeWhereInput!]
  OR: [SacrificeWhereInput!]
  NOT: [SacrificeWhereInput!]
}

input SacrificeWhereUniqueInput {
  id: ID
}

type Salvation {
  id: ID!
  thought: String!
  character: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type SalvationConnection {
  pageInfo: PageInfo!
  edges: [SalvationEdge]!
  aggregate: AggregateSalvation!
}

input SalvationCreateInput {
  id: ID
  thought: String!
  character: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SalvationCreateManyInput {
  create: [SalvationCreateInput!]
  connect: [SalvationWhereUniqueInput!]
}

type SalvationEdge {
  node: Salvation!
  cursor: String!
}

enum SalvationOrderByInput {
  id_ASC
  id_DESC
  thought_ASC
  thought_DESC
  character_ASC
  character_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type SalvationPreviousValues {
  id: ID!
  thought: String!
  character: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SalvationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [SalvationScalarWhereInput!]
  OR: [SalvationScalarWhereInput!]
  NOT: [SalvationScalarWhereInput!]
}

type SalvationSubscriptionPayload {
  mutation: MutationType!
  node: Salvation
  updatedFields: [String!]
  previousValues: SalvationPreviousValues
}

input SalvationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SalvationWhereInput
  AND: [SalvationSubscriptionWhereInput!]
  OR: [SalvationSubscriptionWhereInput!]
  NOT: [SalvationSubscriptionWhereInput!]
}

input SalvationUpdateDataInput {
  thought: String
  character: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SalvationUpdateInput {
  thought: String
  character: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SalvationUpdateManyDataInput {
  thought: String
  character: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SalvationUpdateManyInput {
  create: [SalvationCreateInput!]
  update: [SalvationUpdateWithWhereUniqueNestedInput!]
  upsert: [SalvationUpsertWithWhereUniqueNestedInput!]
  delete: [SalvationWhereUniqueInput!]
  connect: [SalvationWhereUniqueInput!]
  set: [SalvationWhereUniqueInput!]
  disconnect: [SalvationWhereUniqueInput!]
  deleteMany: [SalvationScalarWhereInput!]
  updateMany: [SalvationUpdateManyWithWhereNestedInput!]
}

input SalvationUpdateManyMutationInput {
  thought: String
  character: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SalvationUpdateManyWithWhereNestedInput {
  where: SalvationScalarWhereInput!
  data: SalvationUpdateManyDataInput!
}

input SalvationUpdateWithWhereUniqueNestedInput {
  where: SalvationWhereUniqueInput!
  data: SalvationUpdateDataInput!
}

input SalvationUpsertWithWhereUniqueNestedInput {
  where: SalvationWhereUniqueInput!
  update: SalvationUpdateDataInput!
  create: SalvationCreateInput!
}

input SalvationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [SalvationWhereInput!]
  OR: [SalvationWhereInput!]
  NOT: [SalvationWhereInput!]
}

input SalvationWhereUniqueInput {
  id: ID
}

type Sarcasm {
  id: ID!
  armor(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Armor!]
}

type SarcasmConnection {
  pageInfo: PageInfo!
  edges: [SarcasmEdge]!
  aggregate: AggregateSarcasm!
}

input SarcasmCreateInput {
  id: ID
  armor: ArmorCreateManyInput
}

input SarcasmCreateManyInput {
  create: [SarcasmCreateInput!]
  connect: [SarcasmWhereUniqueInput!]
}

type SarcasmEdge {
  node: Sarcasm!
  cursor: String!
}

enum SarcasmOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SarcasmPreviousValues {
  id: ID!
}

input SarcasmScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SarcasmScalarWhereInput!]
  OR: [SarcasmScalarWhereInput!]
  NOT: [SarcasmScalarWhereInput!]
}

type SarcasmSubscriptionPayload {
  mutation: MutationType!
  node: Sarcasm
  updatedFields: [String!]
  previousValues: SarcasmPreviousValues
}

input SarcasmSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SarcasmWhereInput
  AND: [SarcasmSubscriptionWhereInput!]
  OR: [SarcasmSubscriptionWhereInput!]
  NOT: [SarcasmSubscriptionWhereInput!]
}

input SarcasmUpdateDataInput {
  armor: ArmorUpdateManyInput
}

input SarcasmUpdateInput {
  armor: ArmorUpdateManyInput
}

input SarcasmUpdateManyInput {
  create: [SarcasmCreateInput!]
  update: [SarcasmUpdateWithWhereUniqueNestedInput!]
  upsert: [SarcasmUpsertWithWhereUniqueNestedInput!]
  delete: [SarcasmWhereUniqueInput!]
  connect: [SarcasmWhereUniqueInput!]
  set: [SarcasmWhereUniqueInput!]
  disconnect: [SarcasmWhereUniqueInput!]
  deleteMany: [SarcasmScalarWhereInput!]
}

input SarcasmUpdateWithWhereUniqueNestedInput {
  where: SarcasmWhereUniqueInput!
  data: SarcasmUpdateDataInput!
}

input SarcasmUpsertWithWhereUniqueNestedInput {
  where: SarcasmWhereUniqueInput!
  update: SarcasmUpdateDataInput!
  create: SarcasmCreateInput!
}

input SarcasmWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  armor_every: ArmorWhereInput
  armor_some: ArmorWhereInput
  armor_none: ArmorWhereInput
  AND: [SarcasmWhereInput!]
  OR: [SarcasmWhereInput!]
  NOT: [SarcasmWhereInput!]
}

input SarcasmWhereUniqueInput {
  id: ID
}

type Scar {
  id: ID!
  trauma(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma!]
  toxicity(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity!]
}

type ScarConnection {
  pageInfo: PageInfo!
  edges: [ScarEdge]!
  aggregate: AggregateScar!
}

input ScarCreateInput {
  id: ID
  trauma: TraumaCreateManyInput
  toxicity: ToxicityCreateManyInput
}

input ScarCreateManyInput {
  create: [ScarCreateInput!]
  connect: [ScarWhereUniqueInput!]
}

type ScarEdge {
  node: Scar!
  cursor: String!
}

enum ScarOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ScarPreviousValues {
  id: ID!
}

input ScarScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ScarScalarWhereInput!]
  OR: [ScarScalarWhereInput!]
  NOT: [ScarScalarWhereInput!]
}

type ScarSubscriptionPayload {
  mutation: MutationType!
  node: Scar
  updatedFields: [String!]
  previousValues: ScarPreviousValues
}

input ScarSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScarWhereInput
  AND: [ScarSubscriptionWhereInput!]
  OR: [ScarSubscriptionWhereInput!]
  NOT: [ScarSubscriptionWhereInput!]
}

input ScarUpdateDataInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input ScarUpdateInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input ScarUpdateManyInput {
  create: [ScarCreateInput!]
  update: [ScarUpdateWithWhereUniqueNestedInput!]
  upsert: [ScarUpsertWithWhereUniqueNestedInput!]
  delete: [ScarWhereUniqueInput!]
  connect: [ScarWhereUniqueInput!]
  set: [ScarWhereUniqueInput!]
  disconnect: [ScarWhereUniqueInput!]
  deleteMany: [ScarScalarWhereInput!]
}

input ScarUpdateWithWhereUniqueNestedInput {
  where: ScarWhereUniqueInput!
  data: ScarUpdateDataInput!
}

input ScarUpsertWithWhereUniqueNestedInput {
  where: ScarWhereUniqueInput!
  update: ScarUpdateDataInput!
  create: ScarCreateInput!
}

input ScarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  trauma_every: TraumaWhereInput
  trauma_some: TraumaWhereInput
  trauma_none: TraumaWhereInput
  toxicity_every: ToxicityWhereInput
  toxicity_some: ToxicityWhereInput
  toxicity_none: ToxicityWhereInput
  AND: [ScarWhereInput!]
  OR: [ScarWhereInput!]
  NOT: [ScarWhereInput!]
}

input ScarWhereUniqueInput {
  id: ID
}

type Seeker {
  id: ID!
  virtue(where: VirtueWhereInput, orderBy: VirtueOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Virtue!]
}

type SeekerConnection {
  pageInfo: PageInfo!
  edges: [SeekerEdge]!
  aggregate: AggregateSeeker!
}

input SeekerCreateInput {
  id: ID
  virtue: VirtueCreateManyInput
}

input SeekerCreateOneInput {
  create: SeekerCreateInput
  connect: SeekerWhereUniqueInput
}

type SeekerEdge {
  node: Seeker!
  cursor: String!
}

enum SeekerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SeekerPreviousValues {
  id: ID!
}

type SeekerSubscriptionPayload {
  mutation: MutationType!
  node: Seeker
  updatedFields: [String!]
  previousValues: SeekerPreviousValues
}

input SeekerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SeekerWhereInput
  AND: [SeekerSubscriptionWhereInput!]
  OR: [SeekerSubscriptionWhereInput!]
  NOT: [SeekerSubscriptionWhereInput!]
}

input SeekerUpdateDataInput {
  virtue: VirtueUpdateManyInput
}

input SeekerUpdateInput {
  virtue: VirtueUpdateManyInput
}

input SeekerUpdateOneInput {
  create: SeekerCreateInput
  update: SeekerUpdateDataInput
  upsert: SeekerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SeekerWhereUniqueInput
}

input SeekerUpsertNestedInput {
  update: SeekerUpdateDataInput!
  create: SeekerCreateInput!
}

input SeekerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  virtue_every: VirtueWhereInput
  virtue_some: VirtueWhereInput
  virtue_none: VirtueWhereInput
  AND: [SeekerWhereInput!]
  OR: [SeekerWhereInput!]
  NOT: [SeekerWhereInput!]
}

input SeekerWhereUniqueInput {
  id: ID
}

type Self {
  id: ID!
  body(where: BodyWhereInput, orderBy: BodyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Body!]
}

type SelfConnection {
  pageInfo: PageInfo!
  edges: [SelfEdge]!
  aggregate: AggregateSelf!
}

input SelfCreateInput {
  id: ID
  body: BodyCreateManyInput
}

input SelfCreateOneInput {
  create: SelfCreateInput
  connect: SelfWhereUniqueInput
}

type SelfEdge {
  node: Self!
  cursor: String!
}

enum SelfOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SelfPity {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type SelfPityConnection {
  pageInfo: PageInfo!
  edges: [SelfPityEdge]!
  aggregate: AggregateSelfPity!
}

input SelfPityCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SelfPityCreateManyInput {
  create: [SelfPityCreateInput!]
  connect: [SelfPityWhereUniqueInput!]
}

type SelfPityEdge {
  node: SelfPity!
  cursor: String!
}

enum SelfPityOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type SelfPityPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SelfPityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [SelfPityScalarWhereInput!]
  OR: [SelfPityScalarWhereInput!]
  NOT: [SelfPityScalarWhereInput!]
}

type SelfPitySubscriptionPayload {
  mutation: MutationType!
  node: SelfPity
  updatedFields: [String!]
  previousValues: SelfPityPreviousValues
}

input SelfPitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SelfPityWhereInput
  AND: [SelfPitySubscriptionWhereInput!]
  OR: [SelfPitySubscriptionWhereInput!]
  NOT: [SelfPitySubscriptionWhereInput!]
}

input SelfPityUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SelfPityUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SelfPityUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SelfPityUpdateManyInput {
  create: [SelfPityCreateInput!]
  update: [SelfPityUpdateWithWhereUniqueNestedInput!]
  upsert: [SelfPityUpsertWithWhereUniqueNestedInput!]
  delete: [SelfPityWhereUniqueInput!]
  connect: [SelfPityWhereUniqueInput!]
  set: [SelfPityWhereUniqueInput!]
  disconnect: [SelfPityWhereUniqueInput!]
  deleteMany: [SelfPityScalarWhereInput!]
  updateMany: [SelfPityUpdateManyWithWhereNestedInput!]
}

input SelfPityUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SelfPityUpdateManyWithWhereNestedInput {
  where: SelfPityScalarWhereInput!
  data: SelfPityUpdateManyDataInput!
}

input SelfPityUpdateWithWhereUniqueNestedInput {
  where: SelfPityWhereUniqueInput!
  data: SelfPityUpdateDataInput!
}

input SelfPityUpsertWithWhereUniqueNestedInput {
  where: SelfPityWhereUniqueInput!
  update: SelfPityUpdateDataInput!
  create: SelfPityCreateInput!
}

input SelfPityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [SelfPityWhereInput!]
  OR: [SelfPityWhereInput!]
  NOT: [SelfPityWhereInput!]
}

input SelfPityWhereUniqueInput {
  id: ID
}

type SelfPreviousValues {
  id: ID!
}

type SelfSubscriptionPayload {
  mutation: MutationType!
  node: Self
  updatedFields: [String!]
  previousValues: SelfPreviousValues
}

input SelfSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SelfWhereInput
  AND: [SelfSubscriptionWhereInput!]
  OR: [SelfSubscriptionWhereInput!]
  NOT: [SelfSubscriptionWhereInput!]
}

input SelfUpdateDataInput {
  body: BodyUpdateManyInput
}

input SelfUpdateInput {
  body: BodyUpdateManyInput
}

input SelfUpdateOneInput {
  create: SelfCreateInput
  update: SelfUpdateDataInput
  upsert: SelfUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SelfWhereUniqueInput
}

input SelfUpsertNestedInput {
  update: SelfUpdateDataInput!
  create: SelfCreateInput!
}

input SelfWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  body_every: BodyWhereInput
  body_some: BodyWhereInput
  body_none: BodyWhereInput
  AND: [SelfWhereInput!]
  OR: [SelfWhereInput!]
  NOT: [SelfWhereInput!]
}

input SelfWhereUniqueInput {
  id: ID
}

type Service {
  id: ID!
  courage(where: CourageWhereInput, orderBy: CourageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Courage!]
  compassion(where: CompassionWhereInput, orderBy: CompassionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Compassion!]
}

type ServiceConnection {
  pageInfo: PageInfo!
  edges: [ServiceEdge]!
  aggregate: AggregateService!
}

input ServiceCreateInput {
  id: ID
  courage: CourageCreateManyInput
  compassion: CompassionCreateManyInput
}

input ServiceCreateManyInput {
  create: [ServiceCreateInput!]
  connect: [ServiceWhereUniqueInput!]
}

type ServiceEdge {
  node: Service!
  cursor: String!
}

enum ServiceOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ServicePreviousValues {
  id: ID!
}

input ServiceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ServiceScalarWhereInput!]
  OR: [ServiceScalarWhereInput!]
  NOT: [ServiceScalarWhereInput!]
}

type ServiceSubscriptionPayload {
  mutation: MutationType!
  node: Service
  updatedFields: [String!]
  previousValues: ServicePreviousValues
}

input ServiceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ServiceWhereInput
  AND: [ServiceSubscriptionWhereInput!]
  OR: [ServiceSubscriptionWhereInput!]
  NOT: [ServiceSubscriptionWhereInput!]
}

input ServiceUpdateDataInput {
  courage: CourageUpdateManyInput
  compassion: CompassionUpdateManyInput
}

input ServiceUpdateInput {
  courage: CourageUpdateManyInput
  compassion: CompassionUpdateManyInput
}

input ServiceUpdateManyInput {
  create: [ServiceCreateInput!]
  update: [ServiceUpdateWithWhereUniqueNestedInput!]
  upsert: [ServiceUpsertWithWhereUniqueNestedInput!]
  delete: [ServiceWhereUniqueInput!]
  connect: [ServiceWhereUniqueInput!]
  set: [ServiceWhereUniqueInput!]
  disconnect: [ServiceWhereUniqueInput!]
  deleteMany: [ServiceScalarWhereInput!]
}

input ServiceUpdateWithWhereUniqueNestedInput {
  where: ServiceWhereUniqueInput!
  data: ServiceUpdateDataInput!
}

input ServiceUpsertWithWhereUniqueNestedInput {
  where: ServiceWhereUniqueInput!
  update: ServiceUpdateDataInput!
  create: ServiceCreateInput!
}

input ServiceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  courage_every: CourageWhereInput
  courage_some: CourageWhereInput
  courage_none: CourageWhereInput
  compassion_every: CompassionWhereInput
  compassion_some: CompassionWhereInput
  compassion_none: CompassionWhereInput
  AND: [ServiceWhereInput!]
  OR: [ServiceWhereInput!]
  NOT: [ServiceWhereInput!]
}

input ServiceWhereUniqueInput {
  id: ID
}

type Shield {
  id: ID!
  silence(where: SilenceWhereInput, orderBy: SilenceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Silence!]
  sarcasm(where: SarcasmWhereInput, orderBy: SarcasmOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sarcasm!]
  denial(where: DenialWhereInput, orderBy: DenialOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Denial!]
  confusion(where: ConfusionWhereInput, orderBy: ConfusionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Confusion!]
}

type ShieldConnection {
  pageInfo: PageInfo!
  edges: [ShieldEdge]!
  aggregate: AggregateShield!
}

input ShieldCreateInput {
  id: ID
  silence: SilenceCreateManyInput
  sarcasm: SarcasmCreateManyInput
  denial: DenialCreateManyInput
  confusion: ConfusionCreateManyInput
}

input ShieldCreateManyInput {
  create: [ShieldCreateInput!]
  connect: [ShieldWhereUniqueInput!]
}

input ShieldCreateOneInput {
  create: ShieldCreateInput
  connect: ShieldWhereUniqueInput
}

type ShieldEdge {
  node: Shield!
  cursor: String!
}

enum ShieldOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ShieldPreviousValues {
  id: ID!
}

input ShieldScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [ShieldScalarWhereInput!]
  OR: [ShieldScalarWhereInput!]
  NOT: [ShieldScalarWhereInput!]
}

type ShieldSubscriptionPayload {
  mutation: MutationType!
  node: Shield
  updatedFields: [String!]
  previousValues: ShieldPreviousValues
}

input ShieldSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ShieldWhereInput
  AND: [ShieldSubscriptionWhereInput!]
  OR: [ShieldSubscriptionWhereInput!]
  NOT: [ShieldSubscriptionWhereInput!]
}

input ShieldUpdateDataInput {
  silence: SilenceUpdateManyInput
  sarcasm: SarcasmUpdateManyInput
  denial: DenialUpdateManyInput
  confusion: ConfusionUpdateManyInput
}

input ShieldUpdateInput {
  silence: SilenceUpdateManyInput
  sarcasm: SarcasmUpdateManyInput
  denial: DenialUpdateManyInput
  confusion: ConfusionUpdateManyInput
}

input ShieldUpdateManyInput {
  create: [ShieldCreateInput!]
  update: [ShieldUpdateWithWhereUniqueNestedInput!]
  upsert: [ShieldUpsertWithWhereUniqueNestedInput!]
  delete: [ShieldWhereUniqueInput!]
  connect: [ShieldWhereUniqueInput!]
  set: [ShieldWhereUniqueInput!]
  disconnect: [ShieldWhereUniqueInput!]
  deleteMany: [ShieldScalarWhereInput!]
}

input ShieldUpdateOneInput {
  create: ShieldCreateInput
  update: ShieldUpdateDataInput
  upsert: ShieldUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ShieldWhereUniqueInput
}

input ShieldUpdateWithWhereUniqueNestedInput {
  where: ShieldWhereUniqueInput!
  data: ShieldUpdateDataInput!
}

input ShieldUpsertNestedInput {
  update: ShieldUpdateDataInput!
  create: ShieldCreateInput!
}

input ShieldUpsertWithWhereUniqueNestedInput {
  where: ShieldWhereUniqueInput!
  update: ShieldUpdateDataInput!
  create: ShieldCreateInput!
}

input ShieldWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  silence_every: SilenceWhereInput
  silence_some: SilenceWhereInput
  silence_none: SilenceWhereInput
  sarcasm_every: SarcasmWhereInput
  sarcasm_some: SarcasmWhereInput
  sarcasm_none: SarcasmWhereInput
  denial_every: DenialWhereInput
  denial_some: DenialWhereInput
  denial_none: DenialWhereInput
  confusion_every: ConfusionWhereInput
  confusion_some: ConfusionWhereInput
  confusion_none: ConfusionWhereInput
  AND: [ShieldWhereInput!]
  OR: [ShieldWhereInput!]
  NOT: [ShieldWhereInput!]
}

input ShieldWhereUniqueInput {
  id: ID
}

type Silence {
  id: ID!
  armor(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Armor!]
}

type SilenceConnection {
  pageInfo: PageInfo!
  edges: [SilenceEdge]!
  aggregate: AggregateSilence!
}

input SilenceCreateInput {
  id: ID
  armor: ArmorCreateManyInput
}

input SilenceCreateManyInput {
  create: [SilenceCreateInput!]
  connect: [SilenceWhereUniqueInput!]
}

type SilenceEdge {
  node: Silence!
  cursor: String!
}

enum SilenceOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SilencePreviousValues {
  id: ID!
}

input SilenceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SilenceScalarWhereInput!]
  OR: [SilenceScalarWhereInput!]
  NOT: [SilenceScalarWhereInput!]
}

type SilenceSubscriptionPayload {
  mutation: MutationType!
  node: Silence
  updatedFields: [String!]
  previousValues: SilencePreviousValues
}

input SilenceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SilenceWhereInput
  AND: [SilenceSubscriptionWhereInput!]
  OR: [SilenceSubscriptionWhereInput!]
  NOT: [SilenceSubscriptionWhereInput!]
}

input SilenceUpdateDataInput {
  armor: ArmorUpdateManyInput
}

input SilenceUpdateInput {
  armor: ArmorUpdateManyInput
}

input SilenceUpdateManyInput {
  create: [SilenceCreateInput!]
  update: [SilenceUpdateWithWhereUniqueNestedInput!]
  upsert: [SilenceUpsertWithWhereUniqueNestedInput!]
  delete: [SilenceWhereUniqueInput!]
  connect: [SilenceWhereUniqueInput!]
  set: [SilenceWhereUniqueInput!]
  disconnect: [SilenceWhereUniqueInput!]
  deleteMany: [SilenceScalarWhereInput!]
}

input SilenceUpdateWithWhereUniqueNestedInput {
  where: SilenceWhereUniqueInput!
  data: SilenceUpdateDataInput!
}

input SilenceUpsertWithWhereUniqueNestedInput {
  where: SilenceWhereUniqueInput!
  update: SilenceUpdateDataInput!
  create: SilenceCreateInput!
}

input SilenceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  armor_every: ArmorWhereInput
  armor_some: ArmorWhereInput
  armor_none: ArmorWhereInput
  AND: [SilenceWhereInput!]
  OR: [SilenceWhereInput!]
  NOT: [SilenceWhereInput!]
}

input SilenceWhereUniqueInput {
  id: ID
}

type Skin {
  id: ID!
  anger(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger!]
  fear(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear!]
  pride(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride!]
  selfPity(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity!]
}

type SkinConnection {
  pageInfo: PageInfo!
  edges: [SkinEdge]!
  aggregate: AggregateSkin!
}

input SkinCreateInput {
  id: ID
  anger: AngerCreateManyInput
  fear: FearCreateManyInput
  pride: PrideCreateManyInput
  selfPity: SelfPityCreateManyInput
}

type SkinEdge {
  node: Skin!
  cursor: String!
}

enum SkinOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SkinPreviousValues {
  id: ID!
}

type SkinSubscriptionPayload {
  mutation: MutationType!
  node: Skin
  updatedFields: [String!]
  previousValues: SkinPreviousValues
}

input SkinSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SkinWhereInput
  AND: [SkinSubscriptionWhereInput!]
  OR: [SkinSubscriptionWhereInput!]
  NOT: [SkinSubscriptionWhereInput!]
}

input SkinUpdateInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input SkinWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  anger_every: AngerWhereInput
  anger_some: AngerWhereInput
  anger_none: AngerWhereInput
  fear_every: FearWhereInput
  fear_some: FearWhereInput
  fear_none: FearWhereInput
  pride_every: PrideWhereInput
  pride_some: PrideWhereInput
  pride_none: PrideWhereInput
  selfPity_every: SelfPityWhereInput
  selfPity_some: SelfPityWhereInput
  selfPity_none: SelfPityWhereInput
  AND: [SkinWhereInput!]
  OR: [SkinWhereInput!]
  NOT: [SkinWhereInput!]
}

input SkinWhereUniqueInput {
  id: ID
}

type Smith {
  id: ID!
  shield(where: ShieldWhereInput, orderBy: ShieldOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Shield!]
}

type SmithConnection {
  pageInfo: PageInfo!
  edges: [SmithEdge]!
  aggregate: AggregateSmith!
}

input SmithCreateInput {
  id: ID
  shield: ShieldCreateManyInput
}

input SmithCreateOneInput {
  create: SmithCreateInput
  connect: SmithWhereUniqueInput
}

type SmithEdge {
  node: Smith!
  cursor: String!
}

enum SmithOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SmithPreviousValues {
  id: ID!
}

type SmithSubscriptionPayload {
  mutation: MutationType!
  node: Smith
  updatedFields: [String!]
  previousValues: SmithPreviousValues
}

input SmithSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SmithWhereInput
  AND: [SmithSubscriptionWhereInput!]
  OR: [SmithSubscriptionWhereInput!]
  NOT: [SmithSubscriptionWhereInput!]
}

input SmithUpdateDataInput {
  shield: ShieldUpdateManyInput
}

input SmithUpdateInput {
  shield: ShieldUpdateManyInput
}

input SmithUpdateOneInput {
  create: SmithCreateInput
  update: SmithUpdateDataInput
  upsert: SmithUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SmithWhereUniqueInput
}

input SmithUpsertNestedInput {
  update: SmithUpdateDataInput!
  create: SmithCreateInput!
}

input SmithWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  shield_every: ShieldWhereInput
  shield_some: ShieldWhereInput
  shield_none: ShieldWhereInput
  AND: [SmithWhereInput!]
  OR: [SmithWhereInput!]
  NOT: [SmithWhereInput!]
}

input SmithWhereUniqueInput {
  id: ID
}

type Soul {
  id: ID!
  vulnerability(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vulnerability!]
  acceptance(where: AcceptanceWhereInput, orderBy: AcceptanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Acceptance!]
}

type SoulConnection {
  pageInfo: PageInfo!
  edges: [SoulEdge]!
  aggregate: AggregateSoul!
}

input SoulCreateInput {
  id: ID
  vulnerability: VulnerabilityCreateManyInput
  acceptance: AcceptanceCreateManyInput
}

input SoulCreateManyInput {
  create: [SoulCreateInput!]
  connect: [SoulWhereUniqueInput!]
}

type SoulEdge {
  node: Soul!
  cursor: String!
}

enum SoulOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SoulPreviousValues {
  id: ID!
}

input SoulScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SoulScalarWhereInput!]
  OR: [SoulScalarWhereInput!]
  NOT: [SoulScalarWhereInput!]
}

type SoulSubscriptionPayload {
  mutation: MutationType!
  node: Soul
  updatedFields: [String!]
  previousValues: SoulPreviousValues
}

input SoulSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SoulWhereInput
  AND: [SoulSubscriptionWhereInput!]
  OR: [SoulSubscriptionWhereInput!]
  NOT: [SoulSubscriptionWhereInput!]
}

input SoulUpdateDataInput {
  vulnerability: VulnerabilityUpdateManyInput
  acceptance: AcceptanceUpdateManyInput
}

input SoulUpdateInput {
  vulnerability: VulnerabilityUpdateManyInput
  acceptance: AcceptanceUpdateManyInput
}

input SoulUpdateManyInput {
  create: [SoulCreateInput!]
  update: [SoulUpdateWithWhereUniqueNestedInput!]
  upsert: [SoulUpsertWithWhereUniqueNestedInput!]
  delete: [SoulWhereUniqueInput!]
  connect: [SoulWhereUniqueInput!]
  set: [SoulWhereUniqueInput!]
  disconnect: [SoulWhereUniqueInput!]
  deleteMany: [SoulScalarWhereInput!]
}

input SoulUpdateWithWhereUniqueNestedInput {
  where: SoulWhereUniqueInput!
  data: SoulUpdateDataInput!
}

input SoulUpsertWithWhereUniqueNestedInput {
  where: SoulWhereUniqueInput!
  update: SoulUpdateDataInput!
  create: SoulCreateInput!
}

input SoulWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  vulnerability_every: VulnerabilityWhereInput
  vulnerability_some: VulnerabilityWhereInput
  vulnerability_none: VulnerabilityWhereInput
  acceptance_every: AcceptanceWhereInput
  acceptance_some: AcceptanceWhereInput
  acceptance_none: AcceptanceWhereInput
  AND: [SoulWhereInput!]
  OR: [SoulWhereInput!]
  NOT: [SoulWhereInput!]
}

input SoulWhereUniqueInput {
  id: ID
}

type Sternum {
  id: ID!
  anger(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger!]
  fear(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear!]
  pride(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride!]
  selfPity(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity!]
}

type SternumConnection {
  pageInfo: PageInfo!
  edges: [SternumEdge]!
  aggregate: AggregateSternum!
}

input SternumCreateInput {
  id: ID
  anger: AngerCreateManyInput
  fear: FearCreateManyInput
  pride: PrideCreateManyInput
  selfPity: SelfPityCreateManyInput
}

input SternumCreateManyInput {
  create: [SternumCreateInput!]
  connect: [SternumWhereUniqueInput!]
}

type SternumEdge {
  node: Sternum!
  cursor: String!
}

enum SternumOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SternumPreviousValues {
  id: ID!
}

input SternumScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SternumScalarWhereInput!]
  OR: [SternumScalarWhereInput!]
  NOT: [SternumScalarWhereInput!]
}

type SternumSubscriptionPayload {
  mutation: MutationType!
  node: Sternum
  updatedFields: [String!]
  previousValues: SternumPreviousValues
}

input SternumSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SternumWhereInput
  AND: [SternumSubscriptionWhereInput!]
  OR: [SternumSubscriptionWhereInput!]
  NOT: [SternumSubscriptionWhereInput!]
}

input SternumUpdateDataInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input SternumUpdateInput {
  anger: AngerUpdateManyInput
  fear: FearUpdateManyInput
  pride: PrideUpdateManyInput
  selfPity: SelfPityUpdateManyInput
}

input SternumUpdateManyInput {
  create: [SternumCreateInput!]
  update: [SternumUpdateWithWhereUniqueNestedInput!]
  upsert: [SternumUpsertWithWhereUniqueNestedInput!]
  delete: [SternumWhereUniqueInput!]
  connect: [SternumWhereUniqueInput!]
  set: [SternumWhereUniqueInput!]
  disconnect: [SternumWhereUniqueInput!]
  deleteMany: [SternumScalarWhereInput!]
}

input SternumUpdateWithWhereUniqueNestedInput {
  where: SternumWhereUniqueInput!
  data: SternumUpdateDataInput!
}

input SternumUpsertWithWhereUniqueNestedInput {
  where: SternumWhereUniqueInput!
  update: SternumUpdateDataInput!
  create: SternumCreateInput!
}

input SternumWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  anger_every: AngerWhereInput
  anger_some: AngerWhereInput
  anger_none: AngerWhereInput
  fear_every: FearWhereInput
  fear_some: FearWhereInput
  fear_none: FearWhereInput
  pride_every: PrideWhereInput
  pride_some: PrideWhereInput
  pride_none: PrideWhereInput
  selfPity_every: SelfPityWhereInput
  selfPity_some: SelfPityWhereInput
  selfPity_none: SelfPityWhereInput
  AND: [SternumWhereInput!]
  OR: [SternumWhereInput!]
  NOT: [SternumWhereInput!]
}

input SternumWhereUniqueInput {
  id: ID
}

type Stigmata {
  id: ID!
  nail(where: NailWhereInput, orderBy: NailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Nail!]
  crown(where: CrownWhereInput, orderBy: CrownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Crown!]
  cross(where: CrossWhereInput, orderBy: CrossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cross!]
}

type StigmataConnection {
  pageInfo: PageInfo!
  edges: [StigmataEdge]!
  aggregate: AggregateStigmata!
}

input StigmataCreateInput {
  id: ID
  nail: NailCreateManyInput
  crown: CrownCreateManyInput
  cross: CrossCreateManyInput
}

input StigmataCreateManyInput {
  create: [StigmataCreateInput!]
  connect: [StigmataWhereUniqueInput!]
}

input StigmataCreateOneInput {
  create: StigmataCreateInput
  connect: StigmataWhereUniqueInput
}

type StigmataEdge {
  node: Stigmata!
  cursor: String!
}

enum StigmataOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StigmataPreviousValues {
  id: ID!
}

input StigmataScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [StigmataScalarWhereInput!]
  OR: [StigmataScalarWhereInput!]
  NOT: [StigmataScalarWhereInput!]
}

type StigmataSubscriptionPayload {
  mutation: MutationType!
  node: Stigmata
  updatedFields: [String!]
  previousValues: StigmataPreviousValues
}

input StigmataSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StigmataWhereInput
  AND: [StigmataSubscriptionWhereInput!]
  OR: [StigmataSubscriptionWhereInput!]
  NOT: [StigmataSubscriptionWhereInput!]
}

input StigmataUpdateDataInput {
  nail: NailUpdateManyInput
  crown: CrownUpdateManyInput
  cross: CrossUpdateManyInput
}

input StigmataUpdateInput {
  nail: NailUpdateManyInput
  crown: CrownUpdateManyInput
  cross: CrossUpdateManyInput
}

input StigmataUpdateManyInput {
  create: [StigmataCreateInput!]
  update: [StigmataUpdateWithWhereUniqueNestedInput!]
  upsert: [StigmataUpsertWithWhereUniqueNestedInput!]
  delete: [StigmataWhereUniqueInput!]
  connect: [StigmataWhereUniqueInput!]
  set: [StigmataWhereUniqueInput!]
  disconnect: [StigmataWhereUniqueInput!]
  deleteMany: [StigmataScalarWhereInput!]
}

input StigmataUpdateOneInput {
  create: StigmataCreateInput
  update: StigmataUpdateDataInput
  upsert: StigmataUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: StigmataWhereUniqueInput
}

input StigmataUpdateWithWhereUniqueNestedInput {
  where: StigmataWhereUniqueInput!
  data: StigmataUpdateDataInput!
}

input StigmataUpsertNestedInput {
  update: StigmataUpdateDataInput!
  create: StigmataCreateInput!
}

input StigmataUpsertWithWhereUniqueNestedInput {
  where: StigmataWhereUniqueInput!
  update: StigmataUpdateDataInput!
  create: StigmataCreateInput!
}

input StigmataWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nail_every: NailWhereInput
  nail_some: NailWhereInput
  nail_none: NailWhereInput
  crown_every: CrownWhereInput
  crown_some: CrownWhereInput
  crown_none: CrownWhereInput
  cross_every: CrossWhereInput
  cross_some: CrossWhereInput
  cross_none: CrossWhereInput
  AND: [StigmataWhereInput!]
  OR: [StigmataWhereInput!]
  NOT: [StigmataWhereInput!]
}

input StigmataWhereUniqueInput {
  id: ID
}

type Strength {
  id: ID!
  armor(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Armor!]
  boundary(where: BoundaryWhereInput, orderBy: BoundaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boundary!]
  loyalty(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Loyalty!]
  honor(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Honor!]
}

type StrengthConnection {
  pageInfo: PageInfo!
  edges: [StrengthEdge]!
  aggregate: AggregateStrength!
}

input StrengthCreateInput {
  id: ID
  armor: ArmorCreateManyInput
  boundary: BoundaryCreateManyInput
  loyalty: LoyaltyCreateManyInput
  honor: HonorCreateManyInput
}

input StrengthCreateManyInput {
  create: [StrengthCreateInput!]
  connect: [StrengthWhereUniqueInput!]
}

input StrengthCreateOneInput {
  create: StrengthCreateInput
  connect: StrengthWhereUniqueInput
}

type StrengthEdge {
  node: Strength!
  cursor: String!
}

enum StrengthOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StrengthPreviousValues {
  id: ID!
}

input StrengthScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [StrengthScalarWhereInput!]
  OR: [StrengthScalarWhereInput!]
  NOT: [StrengthScalarWhereInput!]
}

type StrengthSubscriptionPayload {
  mutation: MutationType!
  node: Strength
  updatedFields: [String!]
  previousValues: StrengthPreviousValues
}

input StrengthSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StrengthWhereInput
  AND: [StrengthSubscriptionWhereInput!]
  OR: [StrengthSubscriptionWhereInput!]
  NOT: [StrengthSubscriptionWhereInput!]
}

input StrengthUpdateDataInput {
  armor: ArmorUpdateManyInput
  boundary: BoundaryUpdateManyInput
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
}

input StrengthUpdateInput {
  armor: ArmorUpdateManyInput
  boundary: BoundaryUpdateManyInput
  loyalty: LoyaltyUpdateManyInput
  honor: HonorUpdateManyInput
}

input StrengthUpdateManyInput {
  create: [StrengthCreateInput!]
  update: [StrengthUpdateWithWhereUniqueNestedInput!]
  upsert: [StrengthUpsertWithWhereUniqueNestedInput!]
  delete: [StrengthWhereUniqueInput!]
  connect: [StrengthWhereUniqueInput!]
  set: [StrengthWhereUniqueInput!]
  disconnect: [StrengthWhereUniqueInput!]
  deleteMany: [StrengthScalarWhereInput!]
}

input StrengthUpdateOneInput {
  create: StrengthCreateInput
  update: StrengthUpdateDataInput
  upsert: StrengthUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: StrengthWhereUniqueInput
}

input StrengthUpdateWithWhereUniqueNestedInput {
  where: StrengthWhereUniqueInput!
  data: StrengthUpdateDataInput!
}

input StrengthUpsertNestedInput {
  update: StrengthUpdateDataInput!
  create: StrengthCreateInput!
}

input StrengthUpsertWithWhereUniqueNestedInput {
  where: StrengthWhereUniqueInput!
  update: StrengthUpdateDataInput!
  create: StrengthCreateInput!
}

input StrengthWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  armor_every: ArmorWhereInput
  armor_some: ArmorWhereInput
  armor_none: ArmorWhereInput
  boundary_every: BoundaryWhereInput
  boundary_some: BoundaryWhereInput
  boundary_none: BoundaryWhereInput
  loyalty_every: LoyaltyWhereInput
  loyalty_some: LoyaltyWhereInput
  loyalty_none: LoyaltyWhereInput
  honor_every: HonorWhereInput
  honor_some: HonorWhereInput
  honor_none: HonorWhereInput
  AND: [StrengthWhereInput!]
  OR: [StrengthWhereInput!]
  NOT: [StrengthWhereInput!]
}

input StrengthWhereUniqueInput {
  id: ID
}

type Subscription {
  acceptance(where: AcceptanceSubscriptionWhereInput): AcceptanceSubscriptionPayload
  act(where: ActSubscriptionWhereInput): ActSubscriptionPayload
  affliction(where: AfflictionSubscriptionWhereInput): AfflictionSubscriptionPayload
  anger(where: AngerSubscriptionWhereInput): AngerSubscriptionPayload
  armor(where: ArmorSubscriptionWhereInput): ArmorSubscriptionPayload
  body(where: BodySubscriptionWhereInput): BodySubscriptionPayload
  boundary(where: BoundarySubscriptionWhereInput): BoundarySubscriptionPayload
  brain(where: BrainSubscriptionWhereInput): BrainSubscriptionPayload
  campaign(where: CampaignSubscriptionWhereInput): CampaignSubscriptionPayload
  characters(where: CharactersSubscriptionWhereInput): CharactersSubscriptionPayload
  compassion(where: CompassionSubscriptionWhereInput): CompassionSubscriptionPayload
  confusion(where: ConfusionSubscriptionWhereInput): ConfusionSubscriptionPayload
  congregant(where: CongregantSubscriptionWhereInput): CongregantSubscriptionPayload
  construct(where: ConstructSubscriptionWhereInput): ConstructSubscriptionPayload
  courage(where: CourageSubscriptionWhereInput): CourageSubscriptionPayload
  cross(where: CrossSubscriptionWhereInput): CrossSubscriptionPayload
  crown(where: CrownSubscriptionWhereInput): CrownSubscriptionPayload
  crusade(where: CrusadeSubscriptionWhereInput): CrusadeSubscriptionPayload
  defect(where: DefectSubscriptionWhereInput): DefectSubscriptionPayload
  delirium(where: DeliriumSubscriptionWhereInput): DeliriumSubscriptionPayload
  denial(where: DenialSubscriptionWhereInput): DenialSubscriptionPayload
  discontent(where: DiscontentSubscriptionWhereInput): DiscontentSubscriptionPayload
  dream(where: DreamSubscriptionWhereInput): DreamSubscriptionPayload
  experience(where: ExperienceSubscriptionWhereInput): ExperienceSubscriptionPayload
  face(where: FaceSubscriptionWhereInput): FaceSubscriptionPayload
  fear(where: FearSubscriptionWhereInput): FearSubscriptionPayload
  feeling(where: FeelingSubscriptionWhereInput): FeelingSubscriptionPayload
  fun(where: FunSubscriptionWhereInput): FunSubscriptionPayload
  gash(where: GashSubscriptionWhereInput): GashSubscriptionPayload
  gate(where: GateSubscriptionWhereInput): GateSubscriptionPayload
  genie(where: GenieSubscriptionWhereInput): GenieSubscriptionPayload
  gratitude(where: GratitudeSubscriptionWhereInput): GratitudeSubscriptionPayload
  guardian(where: GuardianSubscriptionWhereInput): GuardianSubscriptionPayload
  gut(where: GutSubscriptionWhereInput): GutSubscriptionPayload
  has(where: HasSubscriptionWhereInput): HasSubscriptionPayload
  heart(where: HeartSubscriptionWhereInput): HeartSubscriptionPayload
  higherPower(where: HigherPowerSubscriptionWhereInput): HigherPowerSubscriptionPayload
  honor(where: HonorSubscriptionWhereInput): HonorSubscriptionPayload
  hope(where: HopeSubscriptionWhereInput): HopeSubscriptionPayload
  impatience(where: ImpatienceSubscriptionWhereInput): ImpatienceSubscriptionPayload
  infection(where: InfectionSubscriptionWhereInput): InfectionSubscriptionPayload
  inventory(where: InventorySubscriptionWhereInput): InventorySubscriptionPayload
  irritability(where: IrritabilitySubscriptionWhereInput): IrritabilitySubscriptionPayload
  joy(where: JoySubscriptionWhereInput): JoySubscriptionPayload
  love(where: LoveSubscriptionWhereInput): LoveSubscriptionPayload
  loyalty(where: LoyaltySubscriptionWhereInput): LoyaltySubscriptionPayload
  martyr(where: MartyrSubscriptionWhereInput): MartyrSubscriptionPayload
  mind(where: MindSubscriptionWhereInput): MindSubscriptionPayload
  mouth(where: MouthSubscriptionWhereInput): MouthSubscriptionPayload
  nail(where: NailSubscriptionWhereInput): NailSubscriptionPayload
  nightmare(where: NightmareSubscriptionWhereInput): NightmareSubscriptionPayload
  oath(where: OathSubscriptionWhereInput): OathSubscriptionPayload
  obsession(where: ObsessionSubscriptionWhereInput): ObsessionSubscriptionPayload
  paladin(where: PaladinSubscriptionWhereInput): PaladinSubscriptionPayload
  path(where: PathSubscriptionWhereInput): PathSubscriptionPayload
  pledge(where: PledgeSubscriptionWhereInput): PledgeSubscriptionPayload
  prayer(where: PrayerSubscriptionWhereInput): PrayerSubscriptionPayload
  pride(where: PrideSubscriptionWhereInput): PrideSubscriptionPayload
  process(where: ProcessSubscriptionWhereInput): ProcessSubscriptionPayload
  resentment(where: ResentmentSubscriptionWhereInput): ResentmentSubscriptionPayload
  sacrifice(where: SacrificeSubscriptionWhereInput): SacrificeSubscriptionPayload
  salvation(where: SalvationSubscriptionWhereInput): SalvationSubscriptionPayload
  sarcasm(where: SarcasmSubscriptionWhereInput): SarcasmSubscriptionPayload
  scar(where: ScarSubscriptionWhereInput): ScarSubscriptionPayload
  seeker(where: SeekerSubscriptionWhereInput): SeekerSubscriptionPayload
  self(where: SelfSubscriptionWhereInput): SelfSubscriptionPayload
  selfPity(where: SelfPitySubscriptionWhereInput): SelfPitySubscriptionPayload
  service(where: ServiceSubscriptionWhereInput): ServiceSubscriptionPayload
  shield(where: ShieldSubscriptionWhereInput): ShieldSubscriptionPayload
  silence(where: SilenceSubscriptionWhereInput): SilenceSubscriptionPayload
  skin(where: SkinSubscriptionWhereInput): SkinSubscriptionPayload
  smith(where: SmithSubscriptionWhereInput): SmithSubscriptionPayload
  soul(where: SoulSubscriptionWhereInput): SoulSubscriptionPayload
  sternum(where: SternumSubscriptionWhereInput): SternumSubscriptionPayload
  stigmata(where: StigmataSubscriptionWhereInput): StigmataSubscriptionPayload
  strength(where: StrengthSubscriptionWhereInput): StrengthSubscriptionPayload
  suffering(where: SufferingSubscriptionWhereInput): SufferingSubscriptionPayload
  summoner(where: SummonerSubscriptionWhereInput): SummonerSubscriptionPayload
  support(where: SupportSubscriptionWhereInput): SupportSubscriptionPayload
  tower(where: TowerSubscriptionWhereInput): TowerSubscriptionPayload
  toxicity(where: ToxicitySubscriptionWhereInput): ToxicitySubscriptionPayload
  trauma(where: TraumaSubscriptionWhereInput): TraumaSubscriptionPayload
  tremor(where: TremorSubscriptionWhereInput): TremorSubscriptionPayload
  victim(where: VictimSubscriptionWhereInput): VictimSubscriptionPayload
  virtue(where: VirtueSubscriptionWhereInput): VirtueSubscriptionPayload
  volunteer(where: VolunteerSubscriptionWhereInput): VolunteerSubscriptionPayload
  vulnerability(where: VulnerabilitySubscriptionWhereInput): VulnerabilitySubscriptionPayload
  wall(where: WallSubscriptionWhereInput): WallSubscriptionPayload
  wish(where: WishSubscriptionWhereInput): WishSubscriptionPayload
}

type Suffering {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type SufferingConnection {
  pageInfo: PageInfo!
  edges: [SufferingEdge]!
  aggregate: AggregateSuffering!
}

input SufferingCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SufferingCreateManyInput {
  create: [SufferingCreateInput!]
  connect: [SufferingWhereUniqueInput!]
}

type SufferingEdge {
  node: Suffering!
  cursor: String!
}

enum SufferingOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type SufferingPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SufferingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [SufferingScalarWhereInput!]
  OR: [SufferingScalarWhereInput!]
  NOT: [SufferingScalarWhereInput!]
}

type SufferingSubscriptionPayload {
  mutation: MutationType!
  node: Suffering
  updatedFields: [String!]
  previousValues: SufferingPreviousValues
}

input SufferingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SufferingWhereInput
  AND: [SufferingSubscriptionWhereInput!]
  OR: [SufferingSubscriptionWhereInput!]
  NOT: [SufferingSubscriptionWhereInput!]
}

input SufferingUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SufferingUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SufferingUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SufferingUpdateManyInput {
  create: [SufferingCreateInput!]
  update: [SufferingUpdateWithWhereUniqueNestedInput!]
  upsert: [SufferingUpsertWithWhereUniqueNestedInput!]
  delete: [SufferingWhereUniqueInput!]
  connect: [SufferingWhereUniqueInput!]
  set: [SufferingWhereUniqueInput!]
  disconnect: [SufferingWhereUniqueInput!]
  deleteMany: [SufferingScalarWhereInput!]
  updateMany: [SufferingUpdateManyWithWhereNestedInput!]
}

input SufferingUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SufferingUpdateManyWithWhereNestedInput {
  where: SufferingScalarWhereInput!
  data: SufferingUpdateManyDataInput!
}

input SufferingUpdateWithWhereUniqueNestedInput {
  where: SufferingWhereUniqueInput!
  data: SufferingUpdateDataInput!
}

input SufferingUpsertWithWhereUniqueNestedInput {
  where: SufferingWhereUniqueInput!
  update: SufferingUpdateDataInput!
  create: SufferingCreateInput!
}

input SufferingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [SufferingWhereInput!]
  OR: [SufferingWhereInput!]
  NOT: [SufferingWhereInput!]
}

input SufferingWhereUniqueInput {
  id: ID
}

type Summoner {
  id: ID!
}

type SummonerConnection {
  pageInfo: PageInfo!
  edges: [SummonerEdge]!
  aggregate: AggregateSummoner!
}

input SummonerCreateInput {
  id: ID
}

input SummonerCreateOneInput {
  create: SummonerCreateInput
  connect: SummonerWhereUniqueInput
}

type SummonerEdge {
  node: Summoner!
  cursor: String!
}

enum SummonerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SummonerPreviousValues {
  id: ID!
}

type SummonerSubscriptionPayload {
  mutation: MutationType!
  node: Summoner
  updatedFields: [String!]
  previousValues: SummonerPreviousValues
}

input SummonerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SummonerWhereInput
  AND: [SummonerSubscriptionWhereInput!]
  OR: [SummonerSubscriptionWhereInput!]
  NOT: [SummonerSubscriptionWhereInput!]
}

input SummonerUpdateOneInput {
  create: SummonerCreateInput
  delete: Boolean
  disconnect: Boolean
  connect: SummonerWhereUniqueInput
}

input SummonerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SummonerWhereInput!]
  OR: [SummonerWhereInput!]
  NOT: [SummonerWhereInput!]
}

input SummonerWhereUniqueInput {
  id: ID
}

type Support {
  id: ID!
  courage(where: CourageWhereInput, orderBy: CourageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Courage!]
  compassion(where: CompassionWhereInput, orderBy: CompassionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Compassion!]
}

type SupportConnection {
  pageInfo: PageInfo!
  edges: [SupportEdge]!
  aggregate: AggregateSupport!
}

input SupportCreateInput {
  id: ID
  courage: CourageCreateManyInput
  compassion: CompassionCreateManyInput
}

input SupportCreateManyInput {
  create: [SupportCreateInput!]
  connect: [SupportWhereUniqueInput!]
}

type SupportEdge {
  node: Support!
  cursor: String!
}

enum SupportOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SupportPreviousValues {
  id: ID!
}

input SupportScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [SupportScalarWhereInput!]
  OR: [SupportScalarWhereInput!]
  NOT: [SupportScalarWhereInput!]
}

type SupportSubscriptionPayload {
  mutation: MutationType!
  node: Support
  updatedFields: [String!]
  previousValues: SupportPreviousValues
}

input SupportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SupportWhereInput
  AND: [SupportSubscriptionWhereInput!]
  OR: [SupportSubscriptionWhereInput!]
  NOT: [SupportSubscriptionWhereInput!]
}

input SupportUpdateDataInput {
  courage: CourageUpdateManyInput
  compassion: CompassionUpdateManyInput
}

input SupportUpdateInput {
  courage: CourageUpdateManyInput
  compassion: CompassionUpdateManyInput
}

input SupportUpdateManyInput {
  create: [SupportCreateInput!]
  update: [SupportUpdateWithWhereUniqueNestedInput!]
  upsert: [SupportUpsertWithWhereUniqueNestedInput!]
  delete: [SupportWhereUniqueInput!]
  connect: [SupportWhereUniqueInput!]
  set: [SupportWhereUniqueInput!]
  disconnect: [SupportWhereUniqueInput!]
  deleteMany: [SupportScalarWhereInput!]
}

input SupportUpdateWithWhereUniqueNestedInput {
  where: SupportWhereUniqueInput!
  data: SupportUpdateDataInput!
}

input SupportUpsertWithWhereUniqueNestedInput {
  where: SupportWhereUniqueInput!
  update: SupportUpdateDataInput!
  create: SupportCreateInput!
}

input SupportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  courage_every: CourageWhereInput
  courage_some: CourageWhereInput
  courage_none: CourageWhereInput
  compassion_every: CompassionWhereInput
  compassion_some: CompassionWhereInput
  compassion_none: CompassionWhereInput
  AND: [SupportWhereInput!]
  OR: [SupportWhereInput!]
  NOT: [SupportWhereInput!]
}

input SupportWhereUniqueInput {
  id: ID
}

type Tower {
  id: ID!
  boundary(where: BoundaryWhereInput, orderBy: BoundaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boundary!]
}

type TowerConnection {
  pageInfo: PageInfo!
  edges: [TowerEdge]!
  aggregate: AggregateTower!
}

input TowerCreateInput {
  id: ID
  boundary: BoundaryCreateManyInput
}

input TowerCreateManyInput {
  create: [TowerCreateInput!]
  connect: [TowerWhereUniqueInput!]
}

type TowerEdge {
  node: Tower!
  cursor: String!
}

enum TowerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TowerPreviousValues {
  id: ID!
}

input TowerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [TowerScalarWhereInput!]
  OR: [TowerScalarWhereInput!]
  NOT: [TowerScalarWhereInput!]
}

type TowerSubscriptionPayload {
  mutation: MutationType!
  node: Tower
  updatedFields: [String!]
  previousValues: TowerPreviousValues
}

input TowerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TowerWhereInput
  AND: [TowerSubscriptionWhereInput!]
  OR: [TowerSubscriptionWhereInput!]
  NOT: [TowerSubscriptionWhereInput!]
}

input TowerUpdateDataInput {
  boundary: BoundaryUpdateManyInput
}

input TowerUpdateInput {
  boundary: BoundaryUpdateManyInput
}

input TowerUpdateManyInput {
  create: [TowerCreateInput!]
  update: [TowerUpdateWithWhereUniqueNestedInput!]
  upsert: [TowerUpsertWithWhereUniqueNestedInput!]
  delete: [TowerWhereUniqueInput!]
  connect: [TowerWhereUniqueInput!]
  set: [TowerWhereUniqueInput!]
  disconnect: [TowerWhereUniqueInput!]
  deleteMany: [TowerScalarWhereInput!]
}

input TowerUpdateWithWhereUniqueNestedInput {
  where: TowerWhereUniqueInput!
  data: TowerUpdateDataInput!
}

input TowerUpsertWithWhereUniqueNestedInput {
  where: TowerWhereUniqueInput!
  update: TowerUpdateDataInput!
  create: TowerCreateInput!
}

input TowerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  boundary_every: BoundaryWhereInput
  boundary_some: BoundaryWhereInput
  boundary_none: BoundaryWhereInput
  AND: [TowerWhereInput!]
  OR: [TowerWhereInput!]
  NOT: [TowerWhereInput!]
}

input TowerWhereUniqueInput {
  id: ID
}

type Toxicity {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type ToxicityConnection {
  pageInfo: PageInfo!
  edges: [ToxicityEdge]!
  aggregate: AggregateToxicity!
}

input ToxicityCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ToxicityCreateManyInput {
  create: [ToxicityCreateInput!]
  connect: [ToxicityWhereUniqueInput!]
}

type ToxicityEdge {
  node: Toxicity!
  cursor: String!
}

enum ToxicityOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type ToxicityPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ToxicityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [ToxicityScalarWhereInput!]
  OR: [ToxicityScalarWhereInput!]
  NOT: [ToxicityScalarWhereInput!]
}

type ToxicitySubscriptionPayload {
  mutation: MutationType!
  node: Toxicity
  updatedFields: [String!]
  previousValues: ToxicityPreviousValues
}

input ToxicitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ToxicityWhereInput
  AND: [ToxicitySubscriptionWhereInput!]
  OR: [ToxicitySubscriptionWhereInput!]
  NOT: [ToxicitySubscriptionWhereInput!]
}

input ToxicityUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ToxicityUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ToxicityUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ToxicityUpdateManyInput {
  create: [ToxicityCreateInput!]
  update: [ToxicityUpdateWithWhereUniqueNestedInput!]
  upsert: [ToxicityUpsertWithWhereUniqueNestedInput!]
  delete: [ToxicityWhereUniqueInput!]
  connect: [ToxicityWhereUniqueInput!]
  set: [ToxicityWhereUniqueInput!]
  disconnect: [ToxicityWhereUniqueInput!]
  deleteMany: [ToxicityScalarWhereInput!]
  updateMany: [ToxicityUpdateManyWithWhereNestedInput!]
}

input ToxicityUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ToxicityUpdateManyWithWhereNestedInput {
  where: ToxicityScalarWhereInput!
  data: ToxicityUpdateManyDataInput!
}

input ToxicityUpdateWithWhereUniqueNestedInput {
  where: ToxicityWhereUniqueInput!
  data: ToxicityUpdateDataInput!
}

input ToxicityUpsertWithWhereUniqueNestedInput {
  where: ToxicityWhereUniqueInput!
  update: ToxicityUpdateDataInput!
  create: ToxicityCreateInput!
}

input ToxicityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [ToxicityWhereInput!]
  OR: [ToxicityWhereInput!]
  NOT: [ToxicityWhereInput!]
}

input ToxicityWhereUniqueInput {
  id: ID
}

type Trauma {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type TraumaConnection {
  pageInfo: PageInfo!
  edges: [TraumaEdge]!
  aggregate: AggregateTrauma!
}

input TraumaCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input TraumaCreateManyInput {
  create: [TraumaCreateInput!]
  connect: [TraumaWhereUniqueInput!]
}

type TraumaEdge {
  node: Trauma!
  cursor: String!
}

enum TraumaOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type TraumaPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input TraumaScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [TraumaScalarWhereInput!]
  OR: [TraumaScalarWhereInput!]
  NOT: [TraumaScalarWhereInput!]
}

type TraumaSubscriptionPayload {
  mutation: MutationType!
  node: Trauma
  updatedFields: [String!]
  previousValues: TraumaPreviousValues
}

input TraumaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TraumaWhereInput
  AND: [TraumaSubscriptionWhereInput!]
  OR: [TraumaSubscriptionWhereInput!]
  NOT: [TraumaSubscriptionWhereInput!]
}

input TraumaUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input TraumaUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input TraumaUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input TraumaUpdateManyInput {
  create: [TraumaCreateInput!]
  update: [TraumaUpdateWithWhereUniqueNestedInput!]
  upsert: [TraumaUpsertWithWhereUniqueNestedInput!]
  delete: [TraumaWhereUniqueInput!]
  connect: [TraumaWhereUniqueInput!]
  set: [TraumaWhereUniqueInput!]
  disconnect: [TraumaWhereUniqueInput!]
  deleteMany: [TraumaScalarWhereInput!]
  updateMany: [TraumaUpdateManyWithWhereNestedInput!]
}

input TraumaUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input TraumaUpdateManyWithWhereNestedInput {
  where: TraumaScalarWhereInput!
  data: TraumaUpdateManyDataInput!
}

input TraumaUpdateWithWhereUniqueNestedInput {
  where: TraumaWhereUniqueInput!
  data: TraumaUpdateDataInput!
}

input TraumaUpsertWithWhereUniqueNestedInput {
  where: TraumaWhereUniqueInput!
  update: TraumaUpdateDataInput!
  create: TraumaCreateInput!
}

input TraumaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [TraumaWhereInput!]
  OR: [TraumaWhereInput!]
  NOT: [TraumaWhereInput!]
}

input TraumaWhereUniqueInput {
  id: ID
}

type Tremor {
  id: ID!
  trauma(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma!]
  toxicity(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity!]
}

type TremorConnection {
  pageInfo: PageInfo!
  edges: [TremorEdge]!
  aggregate: AggregateTremor!
}

input TremorCreateInput {
  id: ID
  trauma: TraumaCreateManyInput
  toxicity: ToxicityCreateManyInput
}

input TremorCreateManyInput {
  create: [TremorCreateInput!]
  connect: [TremorWhereUniqueInput!]
}

type TremorEdge {
  node: Tremor!
  cursor: String!
}

enum TremorOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TremorPreviousValues {
  id: ID!
}

input TremorScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [TremorScalarWhereInput!]
  OR: [TremorScalarWhereInput!]
  NOT: [TremorScalarWhereInput!]
}

type TremorSubscriptionPayload {
  mutation: MutationType!
  node: Tremor
  updatedFields: [String!]
  previousValues: TremorPreviousValues
}

input TremorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TremorWhereInput
  AND: [TremorSubscriptionWhereInput!]
  OR: [TremorSubscriptionWhereInput!]
  NOT: [TremorSubscriptionWhereInput!]
}

input TremorUpdateDataInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input TremorUpdateInput {
  trauma: TraumaUpdateManyInput
  toxicity: ToxicityUpdateManyInput
}

input TremorUpdateManyInput {
  create: [TremorCreateInput!]
  update: [TremorUpdateWithWhereUniqueNestedInput!]
  upsert: [TremorUpsertWithWhereUniqueNestedInput!]
  delete: [TremorWhereUniqueInput!]
  connect: [TremorWhereUniqueInput!]
  set: [TremorWhereUniqueInput!]
  disconnect: [TremorWhereUniqueInput!]
  deleteMany: [TremorScalarWhereInput!]
}

input TremorUpdateWithWhereUniqueNestedInput {
  where: TremorWhereUniqueInput!
  data: TremorUpdateDataInput!
}

input TremorUpsertWithWhereUniqueNestedInput {
  where: TremorWhereUniqueInput!
  update: TremorUpdateDataInput!
  create: TremorCreateInput!
}

input TremorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  trauma_every: TraumaWhereInput
  trauma_some: TraumaWhereInput
  trauma_none: TraumaWhereInput
  toxicity_every: ToxicityWhereInput
  toxicity_some: ToxicityWhereInput
  toxicity_none: ToxicityWhereInput
  AND: [TremorWhereInput!]
  OR: [TremorWhereInput!]
  NOT: [TremorWhereInput!]
}

input TremorWhereUniqueInput {
  id: ID
}

type Victim {
  id: ID!
  affliction(where: AfflictionWhereInput, orderBy: AfflictionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Affliction!]
}

type VictimConnection {
  pageInfo: PageInfo!
  edges: [VictimEdge]!
  aggregate: AggregateVictim!
}

input VictimCreateInput {
  id: ID
  affliction: AfflictionCreateManyInput
}

input VictimCreateOneInput {
  create: VictimCreateInput
  connect: VictimWhereUniqueInput
}

type VictimEdge {
  node: Victim!
  cursor: String!
}

enum VictimOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type VictimPreviousValues {
  id: ID!
}

type VictimSubscriptionPayload {
  mutation: MutationType!
  node: Victim
  updatedFields: [String!]
  previousValues: VictimPreviousValues
}

input VictimSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VictimWhereInput
  AND: [VictimSubscriptionWhereInput!]
  OR: [VictimSubscriptionWhereInput!]
  NOT: [VictimSubscriptionWhereInput!]
}

input VictimUpdateDataInput {
  affliction: AfflictionUpdateManyInput
}

input VictimUpdateInput {
  affliction: AfflictionUpdateManyInput
}

input VictimUpdateOneInput {
  create: VictimCreateInput
  update: VictimUpdateDataInput
  upsert: VictimUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: VictimWhereUniqueInput
}

input VictimUpsertNestedInput {
  update: VictimUpdateDataInput!
  create: VictimCreateInput!
}

input VictimWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  affliction_every: AfflictionWhereInput
  affliction_some: AfflictionWhereInput
  affliction_none: AfflictionWhereInput
  AND: [VictimWhereInput!]
  OR: [VictimWhereInput!]
  NOT: [VictimWhereInput!]
}

input VictimWhereUniqueInput {
  id: ID
}

type Virtue {
  id: ID!
  nail(where: NailWhereInput, orderBy: NailOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Nail!]
  crown(where: CrownWhereInput, orderBy: CrownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Crown!]
  cross(where: CrossWhereInput, orderBy: CrossOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cross!]
}

type VirtueConnection {
  pageInfo: PageInfo!
  edges: [VirtueEdge]!
  aggregate: AggregateVirtue!
}

input VirtueCreateInput {
  id: ID
  nail: NailCreateManyInput
  crown: CrownCreateManyInput
  cross: CrossCreateManyInput
}

input VirtueCreateManyInput {
  create: [VirtueCreateInput!]
  connect: [VirtueWhereUniqueInput!]
}

input VirtueCreateOneInput {
  create: VirtueCreateInput
  connect: VirtueWhereUniqueInput
}

type VirtueEdge {
  node: Virtue!
  cursor: String!
}

enum VirtueOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type VirtuePreviousValues {
  id: ID!
}

input VirtueScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [VirtueScalarWhereInput!]
  OR: [VirtueScalarWhereInput!]
  NOT: [VirtueScalarWhereInput!]
}

type VirtueSubscriptionPayload {
  mutation: MutationType!
  node: Virtue
  updatedFields: [String!]
  previousValues: VirtuePreviousValues
}

input VirtueSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VirtueWhereInput
  AND: [VirtueSubscriptionWhereInput!]
  OR: [VirtueSubscriptionWhereInput!]
  NOT: [VirtueSubscriptionWhereInput!]
}

input VirtueUpdateDataInput {
  nail: NailUpdateManyInput
  crown: CrownUpdateManyInput
  cross: CrossUpdateManyInput
}

input VirtueUpdateInput {
  nail: NailUpdateManyInput
  crown: CrownUpdateManyInput
  cross: CrossUpdateManyInput
}

input VirtueUpdateManyInput {
  create: [VirtueCreateInput!]
  update: [VirtueUpdateWithWhereUniqueNestedInput!]
  upsert: [VirtueUpsertWithWhereUniqueNestedInput!]
  delete: [VirtueWhereUniqueInput!]
  connect: [VirtueWhereUniqueInput!]
  set: [VirtueWhereUniqueInput!]
  disconnect: [VirtueWhereUniqueInput!]
  deleteMany: [VirtueScalarWhereInput!]
}

input VirtueUpdateOneInput {
  create: VirtueCreateInput
  update: VirtueUpdateDataInput
  upsert: VirtueUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: VirtueWhereUniqueInput
}

input VirtueUpdateWithWhereUniqueNestedInput {
  where: VirtueWhereUniqueInput!
  data: VirtueUpdateDataInput!
}

input VirtueUpsertNestedInput {
  update: VirtueUpdateDataInput!
  create: VirtueCreateInput!
}

input VirtueUpsertWithWhereUniqueNestedInput {
  where: VirtueWhereUniqueInput!
  update: VirtueUpdateDataInput!
  create: VirtueCreateInput!
}

input VirtueWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  nail_every: NailWhereInput
  nail_some: NailWhereInput
  nail_none: NailWhereInput
  crown_every: CrownWhereInput
  crown_some: CrownWhereInput
  crown_none: CrownWhereInput
  cross_every: CrossWhereInput
  cross_some: CrossWhereInput
  cross_none: CrossWhereInput
  AND: [VirtueWhereInput!]
  OR: [VirtueWhereInput!]
  NOT: [VirtueWhereInput!]
}

input VirtueWhereUniqueInput {
  id: ID
}

type Volunteer {
  id: ID!
  act(where: ActWhereInput, orderBy: ActOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Act!]
}

type VolunteerConnection {
  pageInfo: PageInfo!
  edges: [VolunteerEdge]!
  aggregate: AggregateVolunteer!
}

input VolunteerCreateInput {
  id: ID
  act: ActCreateManyInput
}

input VolunteerCreateOneInput {
  create: VolunteerCreateInput
  connect: VolunteerWhereUniqueInput
}

type VolunteerEdge {
  node: Volunteer!
  cursor: String!
}

enum VolunteerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type VolunteerPreviousValues {
  id: ID!
}

type VolunteerSubscriptionPayload {
  mutation: MutationType!
  node: Volunteer
  updatedFields: [String!]
  previousValues: VolunteerPreviousValues
}

input VolunteerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VolunteerWhereInput
  AND: [VolunteerSubscriptionWhereInput!]
  OR: [VolunteerSubscriptionWhereInput!]
  NOT: [VolunteerSubscriptionWhereInput!]
}

input VolunteerUpdateDataInput {
  act: ActUpdateManyInput
}

input VolunteerUpdateInput {
  act: ActUpdateManyInput
}

input VolunteerUpdateOneInput {
  create: VolunteerCreateInput
  update: VolunteerUpdateDataInput
  upsert: VolunteerUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: VolunteerWhereUniqueInput
}

input VolunteerUpsertNestedInput {
  update: VolunteerUpdateDataInput!
  create: VolunteerCreateInput!
}

input VolunteerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  act_every: ActWhereInput
  act_some: ActWhereInput
  act_none: ActWhereInput
  AND: [VolunteerWhereInput!]
  OR: [VolunteerWhereInput!]
  NOT: [VolunteerWhereInput!]
}

input VolunteerWhereUniqueInput {
  id: ID
}

type Vulnerability {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type VulnerabilityConnection {
  pageInfo: PageInfo!
  edges: [VulnerabilityEdge]!
  aggregate: AggregateVulnerability!
}

input VulnerabilityCreateInput {
  id: ID
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input VulnerabilityCreateManyInput {
  create: [VulnerabilityCreateInput!]
  connect: [VulnerabilityWhereUniqueInput!]
}

type VulnerabilityEdge {
  node: Vulnerability!
  cursor: String!
}

enum VulnerabilityOrderByInput {
  id_ASC
  id_DESC
  character_ASC
  character_DESC
  thought_ASC
  thought_DESC
  source_ASC
  source_DESC
  process_ASC
  process_DESC
  path_ASC
  path_DESC
  feeling_ASC
  feeling_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type VulnerabilityPreviousValues {
  id: ID!
  character: String!
  thought: String!
  source: String!
  process: String!
  path: String!
  feeling: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input VulnerabilityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [VulnerabilityScalarWhereInput!]
  OR: [VulnerabilityScalarWhereInput!]
  NOT: [VulnerabilityScalarWhereInput!]
}

type VulnerabilitySubscriptionPayload {
  mutation: MutationType!
  node: Vulnerability
  updatedFields: [String!]
  previousValues: VulnerabilityPreviousValues
}

input VulnerabilitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VulnerabilityWhereInput
  AND: [VulnerabilitySubscriptionWhereInput!]
  OR: [VulnerabilitySubscriptionWhereInput!]
  NOT: [VulnerabilitySubscriptionWhereInput!]
}

input VulnerabilityUpdateDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input VulnerabilityUpdateInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input VulnerabilityUpdateManyDataInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input VulnerabilityUpdateManyInput {
  create: [VulnerabilityCreateInput!]
  update: [VulnerabilityUpdateWithWhereUniqueNestedInput!]
  upsert: [VulnerabilityUpsertWithWhereUniqueNestedInput!]
  delete: [VulnerabilityWhereUniqueInput!]
  connect: [VulnerabilityWhereUniqueInput!]
  set: [VulnerabilityWhereUniqueInput!]
  disconnect: [VulnerabilityWhereUniqueInput!]
  deleteMany: [VulnerabilityScalarWhereInput!]
  updateMany: [VulnerabilityUpdateManyWithWhereNestedInput!]
}

input VulnerabilityUpdateManyMutationInput {
  character: String
  thought: String
  source: String
  process: String
  path: String
  feeling: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input VulnerabilityUpdateManyWithWhereNestedInput {
  where: VulnerabilityScalarWhereInput!
  data: VulnerabilityUpdateManyDataInput!
}

input VulnerabilityUpdateWithWhereUniqueNestedInput {
  where: VulnerabilityWhereUniqueInput!
  data: VulnerabilityUpdateDataInput!
}

input VulnerabilityUpsertWithWhereUniqueNestedInput {
  where: VulnerabilityWhereUniqueInput!
  update: VulnerabilityUpdateDataInput!
  create: VulnerabilityCreateInput!
}

input VulnerabilityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  character: String
  character_not: String
  character_in: [String!]
  character_not_in: [String!]
  character_lt: String
  character_lte: String
  character_gt: String
  character_gte: String
  character_contains: String
  character_not_contains: String
  character_starts_with: String
  character_not_starts_with: String
  character_ends_with: String
  character_not_ends_with: String
  thought: String
  thought_not: String
  thought_in: [String!]
  thought_not_in: [String!]
  thought_lt: String
  thought_lte: String
  thought_gt: String
  thought_gte: String
  thought_contains: String
  thought_not_contains: String
  thought_starts_with: String
  thought_not_starts_with: String
  thought_ends_with: String
  thought_not_ends_with: String
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  process: String
  process_not: String
  process_in: [String!]
  process_not_in: [String!]
  process_lt: String
  process_lte: String
  process_gt: String
  process_gte: String
  process_contains: String
  process_not_contains: String
  process_starts_with: String
  process_not_starts_with: String
  process_ends_with: String
  process_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  feeling: String
  feeling_not: String
  feeling_in: [String!]
  feeling_not_in: [String!]
  feeling_lt: String
  feeling_lte: String
  feeling_gt: String
  feeling_gte: String
  feeling_contains: String
  feeling_not_contains: String
  feeling_starts_with: String
  feeling_not_starts_with: String
  feeling_ends_with: String
  feeling_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [VulnerabilityWhereInput!]
  OR: [VulnerabilityWhereInput!]
  NOT: [VulnerabilityWhereInput!]
}

input VulnerabilityWhereUniqueInput {
  id: ID
}

type Wall {
  id: ID!
  boundary(where: BoundaryWhereInput, orderBy: BoundaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boundary!]
}

type WallConnection {
  pageInfo: PageInfo!
  edges: [WallEdge]!
  aggregate: AggregateWall!
}

input WallCreateInput {
  id: ID
  boundary: BoundaryCreateManyInput
}

input WallCreateManyInput {
  create: [WallCreateInput!]
  connect: [WallWhereUniqueInput!]
}

type WallEdge {
  node: Wall!
  cursor: String!
}

enum WallOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WallPreviousValues {
  id: ID!
}

input WallScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [WallScalarWhereInput!]
  OR: [WallScalarWhereInput!]
  NOT: [WallScalarWhereInput!]
}

type WallSubscriptionPayload {
  mutation: MutationType!
  node: Wall
  updatedFields: [String!]
  previousValues: WallPreviousValues
}

input WallSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WallWhereInput
  AND: [WallSubscriptionWhereInput!]
  OR: [WallSubscriptionWhereInput!]
  NOT: [WallSubscriptionWhereInput!]
}

input WallUpdateDataInput {
  boundary: BoundaryUpdateManyInput
}

input WallUpdateInput {
  boundary: BoundaryUpdateManyInput
}

input WallUpdateManyInput {
  create: [WallCreateInput!]
  update: [WallUpdateWithWhereUniqueNestedInput!]
  upsert: [WallUpsertWithWhereUniqueNestedInput!]
  delete: [WallWhereUniqueInput!]
  connect: [WallWhereUniqueInput!]
  set: [WallWhereUniqueInput!]
  disconnect: [WallWhereUniqueInput!]
  deleteMany: [WallScalarWhereInput!]
}

input WallUpdateWithWhereUniqueNestedInput {
  where: WallWhereUniqueInput!
  data: WallUpdateDataInput!
}

input WallUpsertWithWhereUniqueNestedInput {
  where: WallWhereUniqueInput!
  update: WallUpdateDataInput!
  create: WallCreateInput!
}

input WallWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  boundary_every: BoundaryWhereInput
  boundary_some: BoundaryWhereInput
  boundary_none: BoundaryWhereInput
  AND: [WallWhereInput!]
  OR: [WallWhereInput!]
  NOT: [WallWhereInput!]
}

input WallWhereUniqueInput {
  id: ID
}

type Wish {
  id: ID!
  dream(where: DreamWhereInput, orderBy: DreamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Dream!]
}

type WishConnection {
  pageInfo: PageInfo!
  edges: [WishEdge]!
  aggregate: AggregateWish!
}

input WishCreateInput {
  id: ID
  dream: DreamCreateManyInput
}

input WishCreateManyInput {
  create: [WishCreateInput!]
  connect: [WishWhereUniqueInput!]
}

input WishCreateOneInput {
  create: WishCreateInput
  connect: WishWhereUniqueInput
}

type WishEdge {
  node: Wish!
  cursor: String!
}

enum WishOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WishPreviousValues {
  id: ID!
}

input WishScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [WishScalarWhereInput!]
  OR: [WishScalarWhereInput!]
  NOT: [WishScalarWhereInput!]
}

type WishSubscriptionPayload {
  mutation: MutationType!
  node: Wish
  updatedFields: [String!]
  previousValues: WishPreviousValues
}

input WishSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WishWhereInput
  AND: [WishSubscriptionWhereInput!]
  OR: [WishSubscriptionWhereInput!]
  NOT: [WishSubscriptionWhereInput!]
}

input WishUpdateDataInput {
  dream: DreamUpdateManyInput
}

input WishUpdateInput {
  dream: DreamUpdateManyInput
}

input WishUpdateManyInput {
  create: [WishCreateInput!]
  update: [WishUpdateWithWhereUniqueNestedInput!]
  upsert: [WishUpsertWithWhereUniqueNestedInput!]
  delete: [WishWhereUniqueInput!]
  connect: [WishWhereUniqueInput!]
  set: [WishWhereUniqueInput!]
  disconnect: [WishWhereUniqueInput!]
  deleteMany: [WishScalarWhereInput!]
}

input WishUpdateOneInput {
  create: WishCreateInput
  update: WishUpdateDataInput
  upsert: WishUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: WishWhereUniqueInput
}

input WishUpdateWithWhereUniqueNestedInput {
  where: WishWhereUniqueInput!
  data: WishUpdateDataInput!
}

input WishUpsertNestedInput {
  update: WishUpdateDataInput!
  create: WishCreateInput!
}

input WishUpsertWithWhereUniqueNestedInput {
  where: WishWhereUniqueInput!
  update: WishUpdateDataInput!
  create: WishCreateInput!
}

input WishWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  dream_every: DreamWhereInput
  dream_some: DreamWhereInput
  dream_none: DreamWhereInput
  AND: [WishWhereInput!]
  OR: [WishWhereInput!]
  NOT: [WishWhereInput!]
}

input WishWhereUniqueInput {
  id: ID
}
`
      }
    