module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type Acceptance {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type AcceptanceConnection {
  pageInfo: PageInfo!
  edges: [AcceptanceEdge]!
  aggregate: AggregateAcceptance!
}

input AcceptanceCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AcceptanceCreateManyInput {
  create: [AcceptanceCreateInput!]
  connect: [AcceptanceWhereUniqueInput!]
}

type AcceptanceEdge {
  node: Acceptance!
  cursor: String!
}

enum AcceptanceOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type AcceptancePreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type AcceptanceSubscriptionPayload {
  mutation: MutationType!
  node: Acceptance
  updatedFields: [String!]
  previousValues: AcceptancePreviousValues
}

input AcceptanceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AcceptanceWhereInput
  AND: [AcceptanceSubscriptionWhereInput!]
  OR: [AcceptanceSubscriptionWhereInput!]
  NOT: [AcceptanceSubscriptionWhereInput!]
}

input AcceptanceUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AcceptanceUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AcceptanceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [AcceptanceWhereInput!]
  OR: [AcceptanceWhereInput!]
  NOT: [AcceptanceWhereInput!]
}

input AcceptanceWhereUniqueInput {
  id: ID
}

type AggregateAcceptance {
  count: Int!
}

type AggregateAnger {
  count: Int!
}

type AggregateArmor {
  count: Int!
}

type AggregateBoundary {
  count: Int!
}

type AggregateCompassion {
  count: Int!
}

type AggregateCourage {
  count: Int!
}

type AggregateDefect {
  count: Int!
}

type AggregateExperience {
  count: Int!
}

type AggregateFear {
  count: Int!
}

type AggregateHigherPower {
  count: Int!
}

type AggregateHonor {
  count: Int!
}

type AggregateHope {
  count: Int!
}

type AggregateInventory {
  count: Int!
}

type AggregateLoyalty {
  count: Int!
}

type AggregateObsession {
  count: Int!
}

type AggregatePride {
  count: Int!
}

type AggregateResentment {
  count: Int!
}

type AggregateSalvation {
  count: Int!
}

type AggregateSelfPity {
  count: Int!
}

type AggregateStrength {
  count: Int!
}

type AggregateSuffering {
  count: Int!
}

type AggregateToxicity {
  count: Int!
}

type AggregateTrauma {
  count: Int!
}

type AggregateVulnerability {
  count: Int!
}

type Anger {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type AngerConnection {
  pageInfo: PageInfo!
  edges: [AngerEdge]!
  aggregate: AggregateAnger!
}

input AngerCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AngerCreateManyInput {
  create: [AngerCreateInput!]
  connect: [AngerWhereUniqueInput!]
}

type AngerEdge {
  node: Anger!
  cursor: String!
}

enum AngerOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type AngerPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type AngerSubscriptionPayload {
  mutation: MutationType!
  node: Anger
  updatedFields: [String!]
  previousValues: AngerPreviousValues
}

input AngerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AngerWhereInput
  AND: [AngerSubscriptionWhereInput!]
  OR: [AngerSubscriptionWhereInput!]
  NOT: [AngerSubscriptionWhereInput!]
}

input AngerUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AngerUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input AngerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [AngerWhereInput!]
  OR: [AngerWhereInput!]
  NOT: [AngerWhereInput!]
}

input AngerWhereUniqueInput {
  id: ID
}

type Armor {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type ArmorConnection {
  pageInfo: PageInfo!
  edges: [ArmorEdge]!
  aggregate: AggregateArmor!
}

input ArmorCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ArmorCreateManyInput {
  create: [ArmorCreateInput!]
  connect: [ArmorWhereUniqueInput!]
}

type ArmorEdge {
  node: Armor!
  cursor: String!
}

enum ArmorOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type ArmorPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type ArmorSubscriptionPayload {
  mutation: MutationType!
  node: Armor
  updatedFields: [String!]
  previousValues: ArmorPreviousValues
}

input ArmorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ArmorWhereInput
  AND: [ArmorSubscriptionWhereInput!]
  OR: [ArmorSubscriptionWhereInput!]
  NOT: [ArmorSubscriptionWhereInput!]
}

input ArmorUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ArmorUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ArmorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [ArmorWhereInput!]
  OR: [ArmorWhereInput!]
  NOT: [ArmorWhereInput!]
}

input ArmorWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Boundary {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type BoundaryConnection {
  pageInfo: PageInfo!
  edges: [BoundaryEdge]!
  aggregate: AggregateBoundary!
}

input BoundaryCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input BoundaryCreateManyInput {
  create: [BoundaryCreateInput!]
  connect: [BoundaryWhereUniqueInput!]
}

type BoundaryEdge {
  node: Boundary!
  cursor: String!
}

enum BoundaryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type BoundaryPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type BoundarySubscriptionPayload {
  mutation: MutationType!
  node: Boundary
  updatedFields: [String!]
  previousValues: BoundaryPreviousValues
}

input BoundarySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BoundaryWhereInput
  AND: [BoundarySubscriptionWhereInput!]
  OR: [BoundarySubscriptionWhereInput!]
  NOT: [BoundarySubscriptionWhereInput!]
}

input BoundaryUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input BoundaryUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input BoundaryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [BoundaryWhereInput!]
  OR: [BoundaryWhereInput!]
  NOT: [BoundaryWhereInput!]
}

input BoundaryWhereUniqueInput {
  id: ID
}

type Compassion {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type CompassionConnection {
  pageInfo: PageInfo!
  edges: [CompassionEdge]!
  aggregate: AggregateCompassion!
}

input CompassionCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CompassionCreateManyInput {
  create: [CompassionCreateInput!]
  connect: [CompassionWhereUniqueInput!]
}

type CompassionEdge {
  node: Compassion!
  cursor: String!
}

enum CompassionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type CompassionPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type CompassionSubscriptionPayload {
  mutation: MutationType!
  node: Compassion
  updatedFields: [String!]
  previousValues: CompassionPreviousValues
}

input CompassionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CompassionWhereInput
  AND: [CompassionSubscriptionWhereInput!]
  OR: [CompassionSubscriptionWhereInput!]
  NOT: [CompassionSubscriptionWhereInput!]
}

input CompassionUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CompassionUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CompassionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [CompassionWhereInput!]
  OR: [CompassionWhereInput!]
  NOT: [CompassionWhereInput!]
}

input CompassionWhereUniqueInput {
  id: ID
}

type Courage {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type CourageConnection {
  pageInfo: PageInfo!
  edges: [CourageEdge]!
  aggregate: AggregateCourage!
}

input CourageCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CourageCreateManyInput {
  create: [CourageCreateInput!]
  connect: [CourageWhereUniqueInput!]
}

type CourageEdge {
  node: Courage!
  cursor: String!
}

enum CourageOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type CouragePreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type CourageSubscriptionPayload {
  mutation: MutationType!
  node: Courage
  updatedFields: [String!]
  previousValues: CouragePreviousValues
}

input CourageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourageWhereInput
  AND: [CourageSubscriptionWhereInput!]
  OR: [CourageSubscriptionWhereInput!]
  NOT: [CourageSubscriptionWhereInput!]
}

input CourageUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CourageUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input CourageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [CourageWhereInput!]
  OR: [CourageWhereInput!]
  NOT: [CourageWhereInput!]
}

input CourageWhereUniqueInput {
  id: ID
}

scalar DateTime

type Defect {
  trauma(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma!]
  toxicity(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity!]
  suffering(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering!]
}

type DefectConnection {
  pageInfo: PageInfo!
  edges: [DefectEdge]!
  aggregate: AggregateDefect!
}

input DefectCreateInput {
  trauma: TraumaCreateManyInput
  toxicity: ToxicityCreateManyInput
  suffering: SufferingCreateManyInput
}

input DefectCreateManyInput {
  create: [DefectCreateInput!]
}

type DefectEdge {
  node: Defect!
  cursor: String!
}

enum DefectOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DefectSubscriptionPayload {
  mutation: MutationType!
  node: Defect
  updatedFields: [String!]
}

input DefectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DefectWhereInput
  AND: [DefectSubscriptionWhereInput!]
  OR: [DefectSubscriptionWhereInput!]
  NOT: [DefectSubscriptionWhereInput!]
}

input DefectUpdateManyInput {
  create: [DefectCreateInput!]
}

input DefectWhereInput {
  trauma_every: TraumaWhereInput
  trauma_some: TraumaWhereInput
  trauma_none: TraumaWhereInput
  toxicity_every: ToxicityWhereInput
  toxicity_some: ToxicityWhereInput
  toxicity_none: ToxicityWhereInput
  suffering_every: SufferingWhereInput
  suffering_some: SufferingWhereInput
  suffering_none: SufferingWhereInput
  AND: [DefectWhereInput!]
  OR: [DefectWhereInput!]
  NOT: [DefectWhereInput!]
}

type Experience {
  compassion(where: CompassionWhereInput, orderBy: CompassionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Compassion!]
  courage(where: CourageWhereInput, orderBy: CourageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Courage!]
  acceptance(where: AcceptanceWhereInput, orderBy: AcceptanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Acceptance!]
  vulnerability(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vulnerability!]
}

type ExperienceConnection {
  pageInfo: PageInfo!
  edges: [ExperienceEdge]!
  aggregate: AggregateExperience!
}

input ExperienceCreateInput {
  compassion: CompassionCreateManyInput
  courage: CourageCreateManyInput
  acceptance: AcceptanceCreateManyInput
  vulnerability: VulnerabilityCreateManyInput
}

input ExperienceCreateManyInput {
  create: [ExperienceCreateInput!]
}

type ExperienceEdge {
  node: Experience!
  cursor: String!
}

enum ExperienceOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExperienceSubscriptionPayload {
  mutation: MutationType!
  node: Experience
  updatedFields: [String!]
}

input ExperienceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExperienceWhereInput
  AND: [ExperienceSubscriptionWhereInput!]
  OR: [ExperienceSubscriptionWhereInput!]
  NOT: [ExperienceSubscriptionWhereInput!]
}

input ExperienceUpdateManyInput {
  create: [ExperienceCreateInput!]
}

input ExperienceWhereInput {
  compassion_every: CompassionWhereInput
  compassion_some: CompassionWhereInput
  compassion_none: CompassionWhereInput
  courage_every: CourageWhereInput
  courage_some: CourageWhereInput
  courage_none: CourageWhereInput
  acceptance_every: AcceptanceWhereInput
  acceptance_some: AcceptanceWhereInput
  acceptance_none: AcceptanceWhereInput
  vulnerability_every: VulnerabilityWhereInput
  vulnerability_some: VulnerabilityWhereInput
  vulnerability_none: VulnerabilityWhereInput
  AND: [ExperienceWhereInput!]
  OR: [ExperienceWhereInput!]
  NOT: [ExperienceWhereInput!]
}

type Fear {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type FearConnection {
  pageInfo: PageInfo!
  edges: [FearEdge]!
  aggregate: AggregateFear!
}

input FearCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FearCreateManyInput {
  create: [FearCreateInput!]
  connect: [FearWhereUniqueInput!]
}

type FearEdge {
  node: Fear!
  cursor: String!
}

enum FearOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type FearPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type FearSubscriptionPayload {
  mutation: MutationType!
  node: Fear
  updatedFields: [String!]
  previousValues: FearPreviousValues
}

input FearSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FearWhereInput
  AND: [FearSubscriptionWhereInput!]
  OR: [FearSubscriptionWhereInput!]
  NOT: [FearSubscriptionWhereInput!]
}

input FearUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FearUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input FearWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [FearWhereInput!]
  OR: [FearWhereInput!]
  NOT: [FearWhereInput!]
}

input FearWhereUniqueInput {
  id: ID
}

type HigherPower {
  id: ID!
  inventory: Inventory
}

type HigherPowerConnection {
  pageInfo: PageInfo!
  edges: [HigherPowerEdge]!
  aggregate: AggregateHigherPower!
}

input HigherPowerCreateInput {
  inventory: InventoryCreateOneInput
}

type HigherPowerEdge {
  node: HigherPower!
  cursor: String!
}

enum HigherPowerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HigherPowerPreviousValues {
  id: ID!
}

type HigherPowerSubscriptionPayload {
  mutation: MutationType!
  node: HigherPower
  updatedFields: [String!]
  previousValues: HigherPowerPreviousValues
}

input HigherPowerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HigherPowerWhereInput
  AND: [HigherPowerSubscriptionWhereInput!]
  OR: [HigherPowerSubscriptionWhereInput!]
  NOT: [HigherPowerSubscriptionWhereInput!]
}

input HigherPowerUpdateInput {
  inventory: InventoryUpdateOneInput
}

input HigherPowerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  inventory: InventoryWhereInput
  AND: [HigherPowerWhereInput!]
  OR: [HigherPowerWhereInput!]
  NOT: [HigherPowerWhereInput!]
}

input HigherPowerWhereUniqueInput {
  id: ID
}

type Honor {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type HonorConnection {
  pageInfo: PageInfo!
  edges: [HonorEdge]!
  aggregate: AggregateHonor!
}

input HonorCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input HonorCreateManyInput {
  create: [HonorCreateInput!]
  connect: [HonorWhereUniqueInput!]
}

type HonorEdge {
  node: Honor!
  cursor: String!
}

enum HonorOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type HonorPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type HonorSubscriptionPayload {
  mutation: MutationType!
  node: Honor
  updatedFields: [String!]
  previousValues: HonorPreviousValues
}

input HonorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HonorWhereInput
  AND: [HonorSubscriptionWhereInput!]
  OR: [HonorSubscriptionWhereInput!]
  NOT: [HonorSubscriptionWhereInput!]
}

input HonorUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input HonorUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input HonorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [HonorWhereInput!]
  OR: [HonorWhereInput!]
  NOT: [HonorWhereInput!]
}

input HonorWhereUniqueInput {
  id: ID
}

type Hope {
  salvation(where: SalvationWhereInput, orderBy: SalvationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Salvation!]
}

type HopeConnection {
  pageInfo: PageInfo!
  edges: [HopeEdge]!
  aggregate: AggregateHope!
}

input HopeCreateInput {
  salvation: SalvationCreateManyInput
}

input HopeCreateManyInput {
  create: [HopeCreateInput!]
}

type HopeEdge {
  node: Hope!
  cursor: String!
}

enum HopeOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HopeSubscriptionPayload {
  mutation: MutationType!
  node: Hope
  updatedFields: [String!]
}

input HopeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HopeWhereInput
  AND: [HopeSubscriptionWhereInput!]
  OR: [HopeSubscriptionWhereInput!]
  NOT: [HopeSubscriptionWhereInput!]
}

input HopeUpdateManyInput {
  create: [HopeCreateInput!]
}

input HopeWhereInput {
  salvation_every: SalvationWhereInput
  salvation_some: SalvationWhereInput
  salvation_none: SalvationWhereInput
  AND: [HopeWhereInput!]
  OR: [HopeWhereInput!]
  NOT: [HopeWhereInput!]
}

type Inventory {
  defect(where: DefectWhereInput, orderBy: DefectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Defect!]
  resentment(where: ResentmentWhereInput, orderBy: ResentmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Resentment!]
  obsession(where: ObsessionWhereInput, orderBy: ObsessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Obsession!]
  experience(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience!]
  strength(where: StrengthWhereInput, orderBy: StrengthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Strength!]
  hope(where: HopeWhereInput, orderBy: HopeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hope!]
}

type InventoryConnection {
  pageInfo: PageInfo!
  edges: [InventoryEdge]!
  aggregate: AggregateInventory!
}

input InventoryCreateInput {
  defect: DefectCreateManyInput
  resentment: ResentmentCreateManyInput
  obsession: ObsessionCreateManyInput
  experience: ExperienceCreateManyInput
  strength: StrengthCreateManyInput
  hope: HopeCreateManyInput
}

input InventoryCreateOneInput {
  create: InventoryCreateInput
}

type InventoryEdge {
  node: Inventory!
  cursor: String!
}

enum InventoryOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type InventorySubscriptionPayload {
  mutation: MutationType!
  node: Inventory
  updatedFields: [String!]
}

input InventorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InventoryWhereInput
  AND: [InventorySubscriptionWhereInput!]
  OR: [InventorySubscriptionWhereInput!]
  NOT: [InventorySubscriptionWhereInput!]
}

input InventoryUpdateDataInput {
  defect: DefectUpdateManyInput
  resentment: ResentmentUpdateManyInput
  obsession: ObsessionUpdateManyInput
  experience: ExperienceUpdateManyInput
  strength: StrengthUpdateManyInput
  hope: HopeUpdateManyInput
}

input InventoryUpdateOneInput {
  create: InventoryCreateInput
  update: InventoryUpdateDataInput
  upsert: InventoryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
}

input InventoryUpsertNestedInput {
  update: InventoryUpdateDataInput!
  create: InventoryCreateInput!
}

input InventoryWhereInput {
  defect_every: DefectWhereInput
  defect_some: DefectWhereInput
  defect_none: DefectWhereInput
  resentment_every: ResentmentWhereInput
  resentment_some: ResentmentWhereInput
  resentment_none: ResentmentWhereInput
  obsession_every: ObsessionWhereInput
  obsession_some: ObsessionWhereInput
  obsession_none: ObsessionWhereInput
  experience_every: ExperienceWhereInput
  experience_some: ExperienceWhereInput
  experience_none: ExperienceWhereInput
  strength_every: StrengthWhereInput
  strength_some: StrengthWhereInput
  strength_none: StrengthWhereInput
  hope_every: HopeWhereInput
  hope_some: HopeWhereInput
  hope_none: HopeWhereInput
  AND: [InventoryWhereInput!]
  OR: [InventoryWhereInput!]
  NOT: [InventoryWhereInput!]
}

scalar Long

type Loyalty {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type LoyaltyConnection {
  pageInfo: PageInfo!
  edges: [LoyaltyEdge]!
  aggregate: AggregateLoyalty!
}

input LoyaltyCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input LoyaltyCreateManyInput {
  create: [LoyaltyCreateInput!]
  connect: [LoyaltyWhereUniqueInput!]
}

type LoyaltyEdge {
  node: Loyalty!
  cursor: String!
}

enum LoyaltyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type LoyaltyPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type LoyaltySubscriptionPayload {
  mutation: MutationType!
  node: Loyalty
  updatedFields: [String!]
  previousValues: LoyaltyPreviousValues
}

input LoyaltySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LoyaltyWhereInput
  AND: [LoyaltySubscriptionWhereInput!]
  OR: [LoyaltySubscriptionWhereInput!]
  NOT: [LoyaltySubscriptionWhereInput!]
}

input LoyaltyUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input LoyaltyUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input LoyaltyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [LoyaltyWhereInput!]
  OR: [LoyaltyWhereInput!]
  NOT: [LoyaltyWhereInput!]
}

input LoyaltyWhereUniqueInput {
  id: ID
}

type Mutation {
  createAcceptance(data: AcceptanceCreateInput!): Acceptance!
  updateAcceptance(data: AcceptanceUpdateInput!, where: AcceptanceWhereUniqueInput!): Acceptance
  updateManyAcceptances(data: AcceptanceUpdateManyMutationInput!, where: AcceptanceWhereInput): BatchPayload!
  upsertAcceptance(where: AcceptanceWhereUniqueInput!, create: AcceptanceCreateInput!, update: AcceptanceUpdateInput!): Acceptance!
  deleteAcceptance(where: AcceptanceWhereUniqueInput!): Acceptance
  deleteManyAcceptances(where: AcceptanceWhereInput): BatchPayload!
  createAnger(data: AngerCreateInput!): Anger!
  updateAnger(data: AngerUpdateInput!, where: AngerWhereUniqueInput!): Anger
  updateManyAngers(data: AngerUpdateManyMutationInput!, where: AngerWhereInput): BatchPayload!
  upsertAnger(where: AngerWhereUniqueInput!, create: AngerCreateInput!, update: AngerUpdateInput!): Anger!
  deleteAnger(where: AngerWhereUniqueInput!): Anger
  deleteManyAngers(where: AngerWhereInput): BatchPayload!
  createArmor(data: ArmorCreateInput!): Armor!
  updateArmor(data: ArmorUpdateInput!, where: ArmorWhereUniqueInput!): Armor
  updateManyArmors(data: ArmorUpdateManyMutationInput!, where: ArmorWhereInput): BatchPayload!
  upsertArmor(where: ArmorWhereUniqueInput!, create: ArmorCreateInput!, update: ArmorUpdateInput!): Armor!
  deleteArmor(where: ArmorWhereUniqueInput!): Armor
  deleteManyArmors(where: ArmorWhereInput): BatchPayload!
  createBoundary(data: BoundaryCreateInput!): Boundary!
  updateBoundary(data: BoundaryUpdateInput!, where: BoundaryWhereUniqueInput!): Boundary
  updateManyBoundaries(data: BoundaryUpdateManyMutationInput!, where: BoundaryWhereInput): BatchPayload!
  upsertBoundary(where: BoundaryWhereUniqueInput!, create: BoundaryCreateInput!, update: BoundaryUpdateInput!): Boundary!
  deleteBoundary(where: BoundaryWhereUniqueInput!): Boundary
  deleteManyBoundaries(where: BoundaryWhereInput): BatchPayload!
  createCompassion(data: CompassionCreateInput!): Compassion!
  updateCompassion(data: CompassionUpdateInput!, where: CompassionWhereUniqueInput!): Compassion
  updateManyCompassions(data: CompassionUpdateManyMutationInput!, where: CompassionWhereInput): BatchPayload!
  upsertCompassion(where: CompassionWhereUniqueInput!, create: CompassionCreateInput!, update: CompassionUpdateInput!): Compassion!
  deleteCompassion(where: CompassionWhereUniqueInput!): Compassion
  deleteManyCompassions(where: CompassionWhereInput): BatchPayload!
  createCourage(data: CourageCreateInput!): Courage!
  updateCourage(data: CourageUpdateInput!, where: CourageWhereUniqueInput!): Courage
  updateManyCourages(data: CourageUpdateManyMutationInput!, where: CourageWhereInput): BatchPayload!
  upsertCourage(where: CourageWhereUniqueInput!, create: CourageCreateInput!, update: CourageUpdateInput!): Courage!
  deleteCourage(where: CourageWhereUniqueInput!): Courage
  deleteManyCourages(where: CourageWhereInput): BatchPayload!
  createDefect(data: DefectCreateInput!): Defect!
  deleteManyDefects(where: DefectWhereInput): BatchPayload!
  createExperience(data: ExperienceCreateInput!): Experience!
  deleteManyExperiences(where: ExperienceWhereInput): BatchPayload!
  createFear(data: FearCreateInput!): Fear!
  updateFear(data: FearUpdateInput!, where: FearWhereUniqueInput!): Fear
  updateManyFears(data: FearUpdateManyMutationInput!, where: FearWhereInput): BatchPayload!
  upsertFear(where: FearWhereUniqueInput!, create: FearCreateInput!, update: FearUpdateInput!): Fear!
  deleteFear(where: FearWhereUniqueInput!): Fear
  deleteManyFears(where: FearWhereInput): BatchPayload!
  createHigherPower(data: HigherPowerCreateInput!): HigherPower!
  updateHigherPower(data: HigherPowerUpdateInput!, where: HigherPowerWhereUniqueInput!): HigherPower
  upsertHigherPower(where: HigherPowerWhereUniqueInput!, create: HigherPowerCreateInput!, update: HigherPowerUpdateInput!): HigherPower!
  deleteHigherPower(where: HigherPowerWhereUniqueInput!): HigherPower
  deleteManyHigherPowers(where: HigherPowerWhereInput): BatchPayload!
  createHonor(data: HonorCreateInput!): Honor!
  updateHonor(data: HonorUpdateInput!, where: HonorWhereUniqueInput!): Honor
  updateManyHonors(data: HonorUpdateManyMutationInput!, where: HonorWhereInput): BatchPayload!
  upsertHonor(where: HonorWhereUniqueInput!, create: HonorCreateInput!, update: HonorUpdateInput!): Honor!
  deleteHonor(where: HonorWhereUniqueInput!): Honor
  deleteManyHonors(where: HonorWhereInput): BatchPayload!
  createHope(data: HopeCreateInput!): Hope!
  deleteManyHopes(where: HopeWhereInput): BatchPayload!
  createInventory(data: InventoryCreateInput!): Inventory!
  deleteManyInventories(where: InventoryWhereInput): BatchPayload!
  createLoyalty(data: LoyaltyCreateInput!): Loyalty!
  updateLoyalty(data: LoyaltyUpdateInput!, where: LoyaltyWhereUniqueInput!): Loyalty
  updateManyLoyalties(data: LoyaltyUpdateManyMutationInput!, where: LoyaltyWhereInput): BatchPayload!
  upsertLoyalty(where: LoyaltyWhereUniqueInput!, create: LoyaltyCreateInput!, update: LoyaltyUpdateInput!): Loyalty!
  deleteLoyalty(where: LoyaltyWhereUniqueInput!): Loyalty
  deleteManyLoyalties(where: LoyaltyWhereInput): BatchPayload!
  createObsession(data: ObsessionCreateInput!): Obsession!
  deleteManyObsessions(where: ObsessionWhereInput): BatchPayload!
  createPride(data: PrideCreateInput!): Pride!
  updatePride(data: PrideUpdateInput!, where: PrideWhereUniqueInput!): Pride
  updateManyPrides(data: PrideUpdateManyMutationInput!, where: PrideWhereInput): BatchPayload!
  upsertPride(where: PrideWhereUniqueInput!, create: PrideCreateInput!, update: PrideUpdateInput!): Pride!
  deletePride(where: PrideWhereUniqueInput!): Pride
  deleteManyPrides(where: PrideWhereInput): BatchPayload!
  createResentment(data: ResentmentCreateInput!): Resentment!
  deleteManyResentments(where: ResentmentWhereInput): BatchPayload!
  createSalvation(data: SalvationCreateInput!): Salvation!
  updateSalvation(data: SalvationUpdateInput!, where: SalvationWhereUniqueInput!): Salvation
  updateManySalvations(data: SalvationUpdateManyMutationInput!, where: SalvationWhereInput): BatchPayload!
  upsertSalvation(where: SalvationWhereUniqueInput!, create: SalvationCreateInput!, update: SalvationUpdateInput!): Salvation!
  deleteSalvation(where: SalvationWhereUniqueInput!): Salvation
  deleteManySalvations(where: SalvationWhereInput): BatchPayload!
  createSelfPity(data: SelfPityCreateInput!): SelfPity!
  updateSelfPity(data: SelfPityUpdateInput!, where: SelfPityWhereUniqueInput!): SelfPity
  updateManySelfPities(data: SelfPityUpdateManyMutationInput!, where: SelfPityWhereInput): BatchPayload!
  upsertSelfPity(where: SelfPityWhereUniqueInput!, create: SelfPityCreateInput!, update: SelfPityUpdateInput!): SelfPity!
  deleteSelfPity(where: SelfPityWhereUniqueInput!): SelfPity
  deleteManySelfPities(where: SelfPityWhereInput): BatchPayload!
  createStrength(data: StrengthCreateInput!): Strength!
  deleteManyStrengths(where: StrengthWhereInput): BatchPayload!
  createSuffering(data: SufferingCreateInput!): Suffering!
  updateSuffering(data: SufferingUpdateInput!, where: SufferingWhereUniqueInput!): Suffering
  updateManySufferings(data: SufferingUpdateManyMutationInput!, where: SufferingWhereInput): BatchPayload!
  upsertSuffering(where: SufferingWhereUniqueInput!, create: SufferingCreateInput!, update: SufferingUpdateInput!): Suffering!
  deleteSuffering(where: SufferingWhereUniqueInput!): Suffering
  deleteManySufferings(where: SufferingWhereInput): BatchPayload!
  createToxicity(data: ToxicityCreateInput!): Toxicity!
  updateToxicity(data: ToxicityUpdateInput!, where: ToxicityWhereUniqueInput!): Toxicity
  updateManyToxicities(data: ToxicityUpdateManyMutationInput!, where: ToxicityWhereInput): BatchPayload!
  upsertToxicity(where: ToxicityWhereUniqueInput!, create: ToxicityCreateInput!, update: ToxicityUpdateInput!): Toxicity!
  deleteToxicity(where: ToxicityWhereUniqueInput!): Toxicity
  deleteManyToxicities(where: ToxicityWhereInput): BatchPayload!
  createTrauma(data: TraumaCreateInput!): Trauma!
  updateTrauma(data: TraumaUpdateInput!, where: TraumaWhereUniqueInput!): Trauma
  updateManyTraumas(data: TraumaUpdateManyMutationInput!, where: TraumaWhereInput): BatchPayload!
  upsertTrauma(where: TraumaWhereUniqueInput!, create: TraumaCreateInput!, update: TraumaUpdateInput!): Trauma!
  deleteTrauma(where: TraumaWhereUniqueInput!): Trauma
  deleteManyTraumas(where: TraumaWhereInput): BatchPayload!
  createVulnerability(data: VulnerabilityCreateInput!): Vulnerability!
  updateVulnerability(data: VulnerabilityUpdateInput!, where: VulnerabilityWhereUniqueInput!): Vulnerability
  updateManyVulnerabilities(data: VulnerabilityUpdateManyMutationInput!, where: VulnerabilityWhereInput): BatchPayload!
  upsertVulnerability(where: VulnerabilityWhereUniqueInput!, create: VulnerabilityCreateInput!, update: VulnerabilityUpdateInput!): Vulnerability!
  deleteVulnerability(where: VulnerabilityWhereUniqueInput!): Vulnerability
  deleteManyVulnerabilities(where: VulnerabilityWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Obsession {
  suffering(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering!]
  loyalty(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Loyalty!]
  honor(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Honor!]
  vulnerability(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vulnerability!]
}

type ObsessionConnection {
  pageInfo: PageInfo!
  edges: [ObsessionEdge]!
  aggregate: AggregateObsession!
}

input ObsessionCreateInput {
  suffering: SufferingCreateManyInput
  loyalty: LoyaltyCreateManyInput
  honor: HonorCreateManyInput
  vulnerability: VulnerabilityCreateManyInput
}

input ObsessionCreateManyInput {
  create: [ObsessionCreateInput!]
}

type ObsessionEdge {
  node: Obsession!
  cursor: String!
}

enum ObsessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ObsessionSubscriptionPayload {
  mutation: MutationType!
  node: Obsession
  updatedFields: [String!]
}

input ObsessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ObsessionWhereInput
  AND: [ObsessionSubscriptionWhereInput!]
  OR: [ObsessionSubscriptionWhereInput!]
  NOT: [ObsessionSubscriptionWhereInput!]
}

input ObsessionUpdateManyInput {
  create: [ObsessionCreateInput!]
}

input ObsessionWhereInput {
  suffering_every: SufferingWhereInput
  suffering_some: SufferingWhereInput
  suffering_none: SufferingWhereInput
  loyalty_every: LoyaltyWhereInput
  loyalty_some: LoyaltyWhereInput
  loyalty_none: LoyaltyWhereInput
  honor_every: HonorWhereInput
  honor_some: HonorWhereInput
  honor_none: HonorWhereInput
  vulnerability_every: VulnerabilityWhereInput
  vulnerability_some: VulnerabilityWhereInput
  vulnerability_none: VulnerabilityWhereInput
  AND: [ObsessionWhereInput!]
  OR: [ObsessionWhereInput!]
  NOT: [ObsessionWhereInput!]
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Pride {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type PrideConnection {
  pageInfo: PageInfo!
  edges: [PrideEdge]!
  aggregate: AggregatePride!
}

input PrideCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input PrideCreateManyInput {
  create: [PrideCreateInput!]
  connect: [PrideWhereUniqueInput!]
}

type PrideEdge {
  node: Pride!
  cursor: String!
}

enum PrideOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type PridePreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type PrideSubscriptionPayload {
  mutation: MutationType!
  node: Pride
  updatedFields: [String!]
  previousValues: PridePreviousValues
}

input PrideSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PrideWhereInput
  AND: [PrideSubscriptionWhereInput!]
  OR: [PrideSubscriptionWhereInput!]
  NOT: [PrideSubscriptionWhereInput!]
}

input PrideUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input PrideUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input PrideWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [PrideWhereInput!]
  OR: [PrideWhereInput!]
  NOT: [PrideWhereInput!]
}

input PrideWhereUniqueInput {
  id: ID
}

type Query {
  acceptance(where: AcceptanceWhereUniqueInput!): Acceptance
  acceptances(where: AcceptanceWhereInput, orderBy: AcceptanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Acceptance]!
  acceptancesConnection(where: AcceptanceWhereInput, orderBy: AcceptanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AcceptanceConnection!
  anger(where: AngerWhereUniqueInput!): Anger
  angers(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger]!
  angersConnection(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AngerConnection!
  armor(where: ArmorWhereUniqueInput!): Armor
  armors(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Armor]!
  armorsConnection(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ArmorConnection!
  boundary(where: BoundaryWhereUniqueInput!): Boundary
  boundaries(where: BoundaryWhereInput, orderBy: BoundaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boundary]!
  boundariesConnection(where: BoundaryWhereInput, orderBy: BoundaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BoundaryConnection!
  compassion(where: CompassionWhereUniqueInput!): Compassion
  compassions(where: CompassionWhereInput, orderBy: CompassionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Compassion]!
  compassionsConnection(where: CompassionWhereInput, orderBy: CompassionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CompassionConnection!
  courage(where: CourageWhereUniqueInput!): Courage
  courages(where: CourageWhereInput, orderBy: CourageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Courage]!
  couragesConnection(where: CourageWhereInput, orderBy: CourageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourageConnection!
  defects(where: DefectWhereInput, orderBy: DefectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Defect]!
  defectsConnection(where: DefectWhereInput, orderBy: DefectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DefectConnection!
  experiences(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Experience]!
  experiencesConnection(where: ExperienceWhereInput, orderBy: ExperienceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExperienceConnection!
  fear(where: FearWhereUniqueInput!): Fear
  fears(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear]!
  fearsConnection(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FearConnection!
  higherPower(where: HigherPowerWhereUniqueInput!): HigherPower
  higherPowers(where: HigherPowerWhereInput, orderBy: HigherPowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [HigherPower]!
  higherPowersConnection(where: HigherPowerWhereInput, orderBy: HigherPowerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HigherPowerConnection!
  honor(where: HonorWhereUniqueInput!): Honor
  honors(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Honor]!
  honorsConnection(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HonorConnection!
  hopes(where: HopeWhereInput, orderBy: HopeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Hope]!
  hopesConnection(where: HopeWhereInput, orderBy: HopeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HopeConnection!
  inventories(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Inventory]!
  inventoriesConnection(where: InventoryWhereInput, orderBy: InventoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InventoryConnection!
  loyalty(where: LoyaltyWhereUniqueInput!): Loyalty
  loyalties(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Loyalty]!
  loyaltiesConnection(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LoyaltyConnection!
  obsessions(where: ObsessionWhereInput, orderBy: ObsessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Obsession]!
  obsessionsConnection(where: ObsessionWhereInput, orderBy: ObsessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ObsessionConnection!
  pride(where: PrideWhereUniqueInput!): Pride
  prides(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride]!
  pridesConnection(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PrideConnection!
  resentments(where: ResentmentWhereInput, orderBy: ResentmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Resentment]!
  resentmentsConnection(where: ResentmentWhereInput, orderBy: ResentmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ResentmentConnection!
  salvation(where: SalvationWhereUniqueInput!): Salvation
  salvations(where: SalvationWhereInput, orderBy: SalvationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Salvation]!
  salvationsConnection(where: SalvationWhereInput, orderBy: SalvationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SalvationConnection!
  selfPity(where: SelfPityWhereUniqueInput!): SelfPity
  selfPities(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity]!
  selfPitiesConnection(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SelfPityConnection!
  strengths(where: StrengthWhereInput, orderBy: StrengthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Strength]!
  strengthsConnection(where: StrengthWhereInput, orderBy: StrengthOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StrengthConnection!
  suffering(where: SufferingWhereUniqueInput!): Suffering
  sufferings(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Suffering]!
  sufferingsConnection(where: SufferingWhereInput, orderBy: SufferingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SufferingConnection!
  toxicity(where: ToxicityWhereUniqueInput!): Toxicity
  toxicities(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Toxicity]!
  toxicitiesConnection(where: ToxicityWhereInput, orderBy: ToxicityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ToxicityConnection!
  trauma(where: TraumaWhereUniqueInput!): Trauma
  traumas(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Trauma]!
  traumasConnection(where: TraumaWhereInput, orderBy: TraumaOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TraumaConnection!
  vulnerability(where: VulnerabilityWhereUniqueInput!): Vulnerability
  vulnerabilities(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vulnerability]!
  vulnerabilitiesConnection(where: VulnerabilityWhereInput, orderBy: VulnerabilityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VulnerabilityConnection!
  node(id: ID!): Node
}

type Resentment {
  anger(where: AngerWhereInput, orderBy: AngerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Anger!]
  selfPity(where: SelfPityWhereInput, orderBy: SelfPityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SelfPity!]
  fear(where: FearWhereInput, orderBy: FearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Fear!]
  pride(where: PrideWhereInput, orderBy: PrideOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Pride!]
}

type ResentmentConnection {
  pageInfo: PageInfo!
  edges: [ResentmentEdge]!
  aggregate: AggregateResentment!
}

input ResentmentCreateInput {
  anger: AngerCreateManyInput
  selfPity: SelfPityCreateManyInput
  fear: FearCreateManyInput
  pride: PrideCreateManyInput
}

input ResentmentCreateManyInput {
  create: [ResentmentCreateInput!]
}

type ResentmentEdge {
  node: Resentment!
  cursor: String!
}

enum ResentmentOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ResentmentSubscriptionPayload {
  mutation: MutationType!
  node: Resentment
  updatedFields: [String!]
}

input ResentmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ResentmentWhereInput
  AND: [ResentmentSubscriptionWhereInput!]
  OR: [ResentmentSubscriptionWhereInput!]
  NOT: [ResentmentSubscriptionWhereInput!]
}

input ResentmentUpdateManyInput {
  create: [ResentmentCreateInput!]
}

input ResentmentWhereInput {
  anger_every: AngerWhereInput
  anger_some: AngerWhereInput
  anger_none: AngerWhereInput
  selfPity_every: SelfPityWhereInput
  selfPity_some: SelfPityWhereInput
  selfPity_none: SelfPityWhereInput
  fear_every: FearWhereInput
  fear_some: FearWhereInput
  fear_none: FearWhereInput
  pride_every: PrideWhereInput
  pride_some: PrideWhereInput
  pride_none: PrideWhereInput
  AND: [ResentmentWhereInput!]
  OR: [ResentmentWhereInput!]
  NOT: [ResentmentWhereInput!]
}

type Salvation {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type SalvationConnection {
  pageInfo: PageInfo!
  edges: [SalvationEdge]!
  aggregate: AggregateSalvation!
}

input SalvationCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SalvationCreateManyInput {
  create: [SalvationCreateInput!]
  connect: [SalvationWhereUniqueInput!]
}

type SalvationEdge {
  node: Salvation!
  cursor: String!
}

enum SalvationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type SalvationPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type SalvationSubscriptionPayload {
  mutation: MutationType!
  node: Salvation
  updatedFields: [String!]
  previousValues: SalvationPreviousValues
}

input SalvationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SalvationWhereInput
  AND: [SalvationSubscriptionWhereInput!]
  OR: [SalvationSubscriptionWhereInput!]
  NOT: [SalvationSubscriptionWhereInput!]
}

input SalvationUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SalvationUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SalvationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [SalvationWhereInput!]
  OR: [SalvationWhereInput!]
  NOT: [SalvationWhereInput!]
}

input SalvationWhereUniqueInput {
  id: ID
}

type SelfPity {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type SelfPityConnection {
  pageInfo: PageInfo!
  edges: [SelfPityEdge]!
  aggregate: AggregateSelfPity!
}

input SelfPityCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SelfPityCreateManyInput {
  create: [SelfPityCreateInput!]
  connect: [SelfPityWhereUniqueInput!]
}

type SelfPityEdge {
  node: SelfPity!
  cursor: String!
}

enum SelfPityOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type SelfPityPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type SelfPitySubscriptionPayload {
  mutation: MutationType!
  node: SelfPity
  updatedFields: [String!]
  previousValues: SelfPityPreviousValues
}

input SelfPitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SelfPityWhereInput
  AND: [SelfPitySubscriptionWhereInput!]
  OR: [SelfPitySubscriptionWhereInput!]
  NOT: [SelfPitySubscriptionWhereInput!]
}

input SelfPityUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SelfPityUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SelfPityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [SelfPityWhereInput!]
  OR: [SelfPityWhereInput!]
  NOT: [SelfPityWhereInput!]
}

input SelfPityWhereUniqueInput {
  id: ID
}

type Strength {
  armor(where: ArmorWhereInput, orderBy: ArmorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Armor!]
  boundary(where: BoundaryWhereInput, orderBy: BoundaryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Boundary!]
  loyalty(where: LoyaltyWhereInput, orderBy: LoyaltyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Loyalty!]
  honor(where: HonorWhereInput, orderBy: HonorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Honor!]
}

type StrengthConnection {
  pageInfo: PageInfo!
  edges: [StrengthEdge]!
  aggregate: AggregateStrength!
}

input StrengthCreateInput {
  armor: ArmorCreateManyInput
  boundary: BoundaryCreateManyInput
  loyalty: LoyaltyCreateManyInput
  honor: HonorCreateManyInput
}

input StrengthCreateManyInput {
  create: [StrengthCreateInput!]
}

type StrengthEdge {
  node: Strength!
  cursor: String!
}

enum StrengthOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type StrengthSubscriptionPayload {
  mutation: MutationType!
  node: Strength
  updatedFields: [String!]
}

input StrengthSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StrengthWhereInput
  AND: [StrengthSubscriptionWhereInput!]
  OR: [StrengthSubscriptionWhereInput!]
  NOT: [StrengthSubscriptionWhereInput!]
}

input StrengthUpdateManyInput {
  create: [StrengthCreateInput!]
}

input StrengthWhereInput {
  armor_every: ArmorWhereInput
  armor_some: ArmorWhereInput
  armor_none: ArmorWhereInput
  boundary_every: BoundaryWhereInput
  boundary_some: BoundaryWhereInput
  boundary_none: BoundaryWhereInput
  loyalty_every: LoyaltyWhereInput
  loyalty_some: LoyaltyWhereInput
  loyalty_none: LoyaltyWhereInput
  honor_every: HonorWhereInput
  honor_some: HonorWhereInput
  honor_none: HonorWhereInput
  AND: [StrengthWhereInput!]
  OR: [StrengthWhereInput!]
  NOT: [StrengthWhereInput!]
}

type Subscription {
  acceptance(where: AcceptanceSubscriptionWhereInput): AcceptanceSubscriptionPayload
  anger(where: AngerSubscriptionWhereInput): AngerSubscriptionPayload
  armor(where: ArmorSubscriptionWhereInput): ArmorSubscriptionPayload
  boundary(where: BoundarySubscriptionWhereInput): BoundarySubscriptionPayload
  compassion(where: CompassionSubscriptionWhereInput): CompassionSubscriptionPayload
  courage(where: CourageSubscriptionWhereInput): CourageSubscriptionPayload
  defect(where: DefectSubscriptionWhereInput): DefectSubscriptionPayload
  experience(where: ExperienceSubscriptionWhereInput): ExperienceSubscriptionPayload
  fear(where: FearSubscriptionWhereInput): FearSubscriptionPayload
  higherPower(where: HigherPowerSubscriptionWhereInput): HigherPowerSubscriptionPayload
  honor(where: HonorSubscriptionWhereInput): HonorSubscriptionPayload
  hope(where: HopeSubscriptionWhereInput): HopeSubscriptionPayload
  inventory(where: InventorySubscriptionWhereInput): InventorySubscriptionPayload
  loyalty(where: LoyaltySubscriptionWhereInput): LoyaltySubscriptionPayload
  obsession(where: ObsessionSubscriptionWhereInput): ObsessionSubscriptionPayload
  pride(where: PrideSubscriptionWhereInput): PrideSubscriptionPayload
  resentment(where: ResentmentSubscriptionWhereInput): ResentmentSubscriptionPayload
  salvation(where: SalvationSubscriptionWhereInput): SalvationSubscriptionPayload
  selfPity(where: SelfPitySubscriptionWhereInput): SelfPitySubscriptionPayload
  strength(where: StrengthSubscriptionWhereInput): StrengthSubscriptionPayload
  suffering(where: SufferingSubscriptionWhereInput): SufferingSubscriptionPayload
  toxicity(where: ToxicitySubscriptionWhereInput): ToxicitySubscriptionPayload
  trauma(where: TraumaSubscriptionWhereInput): TraumaSubscriptionPayload
  vulnerability(where: VulnerabilitySubscriptionWhereInput): VulnerabilitySubscriptionPayload
}

type Suffering {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type SufferingConnection {
  pageInfo: PageInfo!
  edges: [SufferingEdge]!
  aggregate: AggregateSuffering!
}

input SufferingCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SufferingCreateManyInput {
  create: [SufferingCreateInput!]
  connect: [SufferingWhereUniqueInput!]
}

type SufferingEdge {
  node: Suffering!
  cursor: String!
}

enum SufferingOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type SufferingPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type SufferingSubscriptionPayload {
  mutation: MutationType!
  node: Suffering
  updatedFields: [String!]
  previousValues: SufferingPreviousValues
}

input SufferingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SufferingWhereInput
  AND: [SufferingSubscriptionWhereInput!]
  OR: [SufferingSubscriptionWhereInput!]
  NOT: [SufferingSubscriptionWhereInput!]
}

input SufferingUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SufferingUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input SufferingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [SufferingWhereInput!]
  OR: [SufferingWhereInput!]
  NOT: [SufferingWhereInput!]
}

input SufferingWhereUniqueInput {
  id: ID
}

type Toxicity {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type ToxicityConnection {
  pageInfo: PageInfo!
  edges: [ToxicityEdge]!
  aggregate: AggregateToxicity!
}

input ToxicityCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ToxicityCreateManyInput {
  create: [ToxicityCreateInput!]
  connect: [ToxicityWhereUniqueInput!]
}

type ToxicityEdge {
  node: Toxicity!
  cursor: String!
}

enum ToxicityOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type ToxicityPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type ToxicitySubscriptionPayload {
  mutation: MutationType!
  node: Toxicity
  updatedFields: [String!]
  previousValues: ToxicityPreviousValues
}

input ToxicitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ToxicityWhereInput
  AND: [ToxicitySubscriptionWhereInput!]
  OR: [ToxicitySubscriptionWhereInput!]
  NOT: [ToxicitySubscriptionWhereInput!]
}

input ToxicityUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ToxicityUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input ToxicityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [ToxicityWhereInput!]
  OR: [ToxicityWhereInput!]
  NOT: [ToxicityWhereInput!]
}

input ToxicityWhereUniqueInput {
  id: ID
}

type Trauma {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type TraumaConnection {
  pageInfo: PageInfo!
  edges: [TraumaEdge]!
  aggregate: AggregateTrauma!
}

input TraumaCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input TraumaCreateManyInput {
  create: [TraumaCreateInput!]
  connect: [TraumaWhereUniqueInput!]
}

type TraumaEdge {
  node: Trauma!
  cursor: String!
}

enum TraumaOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type TraumaPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type TraumaSubscriptionPayload {
  mutation: MutationType!
  node: Trauma
  updatedFields: [String!]
  previousValues: TraumaPreviousValues
}

input TraumaSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TraumaWhereInput
  AND: [TraumaSubscriptionWhereInput!]
  OR: [TraumaSubscriptionWhereInput!]
  NOT: [TraumaSubscriptionWhereInput!]
}

input TraumaUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input TraumaUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input TraumaWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [TraumaWhereInput!]
  OR: [TraumaWhereInput!]
  NOT: [TraumaWhereInput!]
}

input TraumaWhereUniqueInput {
  id: ID
}

type Vulnerability {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type VulnerabilityConnection {
  pageInfo: PageInfo!
  edges: [VulnerabilityEdge]!
  aggregate: AggregateVulnerability!
}

input VulnerabilityCreateInput {
  name: String!
  description: String!
  attribute: String!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input VulnerabilityCreateManyInput {
  create: [VulnerabilityCreateInput!]
  connect: [VulnerabilityWhereUniqueInput!]
}

type VulnerabilityEdge {
  node: Vulnerability!
  cursor: String!
}

enum VulnerabilityOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  attribute_ASC
  attribute_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  sharedAt_ASC
  sharedAt_DESC
  amendedAt_ASC
  amendedAt_DESC
  resolvedAt_ASC
  resolvedAt_DESC
}

type VulnerabilityPreviousValues {
  id: ID!
  name: String!
  description: String!
  attribute: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

type VulnerabilitySubscriptionPayload {
  mutation: MutationType!
  node: Vulnerability
  updatedFields: [String!]
  previousValues: VulnerabilityPreviousValues
}

input VulnerabilitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VulnerabilityWhereInput
  AND: [VulnerabilitySubscriptionWhereInput!]
  OR: [VulnerabilitySubscriptionWhereInput!]
  NOT: [VulnerabilitySubscriptionWhereInput!]
}

input VulnerabilityUpdateInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input VulnerabilityUpdateManyMutationInput {
  name: String
  description: String
  attribute: String
  sharedAt: DateTime
  amendedAt: DateTime
  resolvedAt: DateTime
}

input VulnerabilityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  attribute: String
  attribute_not: String
  attribute_in: [String!]
  attribute_not_in: [String!]
  attribute_lt: String
  attribute_lte: String
  attribute_gt: String
  attribute_gte: String
  attribute_contains: String
  attribute_not_contains: String
  attribute_starts_with: String
  attribute_not_starts_with: String
  attribute_ends_with: String
  attribute_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  sharedAt: DateTime
  sharedAt_not: DateTime
  sharedAt_in: [DateTime!]
  sharedAt_not_in: [DateTime!]
  sharedAt_lt: DateTime
  sharedAt_lte: DateTime
  sharedAt_gt: DateTime
  sharedAt_gte: DateTime
  amendedAt: DateTime
  amendedAt_not: DateTime
  amendedAt_in: [DateTime!]
  amendedAt_not_in: [DateTime!]
  amendedAt_lt: DateTime
  amendedAt_lte: DateTime
  amendedAt_gt: DateTime
  amendedAt_gte: DateTime
  resolvedAt: DateTime
  resolvedAt_not: DateTime
  resolvedAt_in: [DateTime!]
  resolvedAt_not_in: [DateTime!]
  resolvedAt_lt: DateTime
  resolvedAt_lte: DateTime
  resolvedAt_gt: DateTime
  resolvedAt_gte: DateTime
  AND: [VulnerabilityWhereInput!]
  OR: [VulnerabilityWhereInput!]
  NOT: [VulnerabilityWhereInput!]
}

input VulnerabilityWhereUniqueInput {
  id: ID
}
`
      }
    