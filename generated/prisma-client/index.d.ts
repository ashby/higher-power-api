// Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  acceptance: (where?: AcceptanceWhereInput) => Promise<boolean>;
  act: (where?: ActWhereInput) => Promise<boolean>;
  affliction: (where?: AfflictionWhereInput) => Promise<boolean>;
  anger: (where?: AngerWhereInput) => Promise<boolean>;
  armor: (where?: ArmorWhereInput) => Promise<boolean>;
  body: (where?: BodyWhereInput) => Promise<boolean>;
  boundary: (where?: BoundaryWhereInput) => Promise<boolean>;
  brain: (where?: BrainWhereInput) => Promise<boolean>;
  campaign: (where?: CampaignWhereInput) => Promise<boolean>;
  characters: (where?: CharactersWhereInput) => Promise<boolean>;
  compassion: (where?: CompassionWhereInput) => Promise<boolean>;
  confusion: (where?: ConfusionWhereInput) => Promise<boolean>;
  congregant: (where?: CongregantWhereInput) => Promise<boolean>;
  construct: (where?: ConstructWhereInput) => Promise<boolean>;
  courage: (where?: CourageWhereInput) => Promise<boolean>;
  cross: (where?: CrossWhereInput) => Promise<boolean>;
  crown: (where?: CrownWhereInput) => Promise<boolean>;
  crusade: (where?: CrusadeWhereInput) => Promise<boolean>;
  defect: (where?: DefectWhereInput) => Promise<boolean>;
  delirium: (where?: DeliriumWhereInput) => Promise<boolean>;
  denial: (where?: DenialWhereInput) => Promise<boolean>;
  discontent: (where?: DiscontentWhereInput) => Promise<boolean>;
  dream: (where?: DreamWhereInput) => Promise<boolean>;
  experience: (where?: ExperienceWhereInput) => Promise<boolean>;
  face: (where?: FaceWhereInput) => Promise<boolean>;
  fear: (where?: FearWhereInput) => Promise<boolean>;
  feeling: (where?: FeelingWhereInput) => Promise<boolean>;
  fun: (where?: FunWhereInput) => Promise<boolean>;
  gash: (where?: GashWhereInput) => Promise<boolean>;
  gate: (where?: GateWhereInput) => Promise<boolean>;
  genie: (where?: GenieWhereInput) => Promise<boolean>;
  gratitude: (where?: GratitudeWhereInput) => Promise<boolean>;
  guardian: (where?: GuardianWhereInput) => Promise<boolean>;
  gut: (where?: GutWhereInput) => Promise<boolean>;
  has: (where?: HasWhereInput) => Promise<boolean>;
  heart: (where?: HeartWhereInput) => Promise<boolean>;
  higherPower: (where?: HigherPowerWhereInput) => Promise<boolean>;
  honor: (where?: HonorWhereInput) => Promise<boolean>;
  hope: (where?: HopeWhereInput) => Promise<boolean>;
  impatience: (where?: ImpatienceWhereInput) => Promise<boolean>;
  infection: (where?: InfectionWhereInput) => Promise<boolean>;
  inventory: (where?: InventoryWhereInput) => Promise<boolean>;
  irritability: (where?: IrritabilityWhereInput) => Promise<boolean>;
  joy: (where?: JoyWhereInput) => Promise<boolean>;
  love: (where?: LoveWhereInput) => Promise<boolean>;
  loyalty: (where?: LoyaltyWhereInput) => Promise<boolean>;
  martyr: (where?: MartyrWhereInput) => Promise<boolean>;
  mind: (where?: MindWhereInput) => Promise<boolean>;
  mouth: (where?: MouthWhereInput) => Promise<boolean>;
  nail: (where?: NailWhereInput) => Promise<boolean>;
  nightmare: (where?: NightmareWhereInput) => Promise<boolean>;
  oath: (where?: OathWhereInput) => Promise<boolean>;
  obsession: (where?: ObsessionWhereInput) => Promise<boolean>;
  paladin: (where?: PaladinWhereInput) => Promise<boolean>;
  path: (where?: PathWhereInput) => Promise<boolean>;
  pledge: (where?: PledgeWhereInput) => Promise<boolean>;
  prayer: (where?: PrayerWhereInput) => Promise<boolean>;
  pride: (where?: PrideWhereInput) => Promise<boolean>;
  process: (where?: ProcessWhereInput) => Promise<boolean>;
  resentment: (where?: ResentmentWhereInput) => Promise<boolean>;
  sacrifice: (where?: SacrificeWhereInput) => Promise<boolean>;
  salvation: (where?: SalvationWhereInput) => Promise<boolean>;
  sarcasm: (where?: SarcasmWhereInput) => Promise<boolean>;
  scar: (where?: ScarWhereInput) => Promise<boolean>;
  seeker: (where?: SeekerWhereInput) => Promise<boolean>;
  self: (where?: SelfWhereInput) => Promise<boolean>;
  selfPity: (where?: SelfPityWhereInput) => Promise<boolean>;
  service: (where?: ServiceWhereInput) => Promise<boolean>;
  shield: (where?: ShieldWhereInput) => Promise<boolean>;
  silence: (where?: SilenceWhereInput) => Promise<boolean>;
  skin: (where?: SkinWhereInput) => Promise<boolean>;
  smith: (where?: SmithWhereInput) => Promise<boolean>;
  soul: (where?: SoulWhereInput) => Promise<boolean>;
  sternum: (where?: SternumWhereInput) => Promise<boolean>;
  stigmata: (where?: StigmataWhereInput) => Promise<boolean>;
  strength: (where?: StrengthWhereInput) => Promise<boolean>;
  suffering: (where?: SufferingWhereInput) => Promise<boolean>;
  summoner: (where?: SummonerWhereInput) => Promise<boolean>;
  support: (where?: SupportWhereInput) => Promise<boolean>;
  tower: (where?: TowerWhereInput) => Promise<boolean>;
  toxicity: (where?: ToxicityWhereInput) => Promise<boolean>;
  trauma: (where?: TraumaWhereInput) => Promise<boolean>;
  tremor: (where?: TremorWhereInput) => Promise<boolean>;
  victim: (where?: VictimWhereInput) => Promise<boolean>;
  virtue: (where?: VirtueWhereInput) => Promise<boolean>;
  volunteer: (where?: VolunteerWhereInput) => Promise<boolean>;
  vulnerability: (where?: VulnerabilityWhereInput) => Promise<boolean>;
  wall: (where?: WallWhereInput) => Promise<boolean>;
  wish: (where?: WishWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  acceptance: (where: AcceptanceWhereUniqueInput) => AcceptancePromise;
  acceptances: (
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Acceptance>;
  acceptancesConnection: (
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AcceptanceConnectionPromise;
  act: (where: ActWhereUniqueInput) => ActPromise;
  acts: (
    args?: {
      where?: ActWhereInput;
      orderBy?: ActOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Act>;
  actsConnection: (
    args?: {
      where?: ActWhereInput;
      orderBy?: ActOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ActConnectionPromise;
  affliction: (where: AfflictionWhereUniqueInput) => AfflictionPromise;
  afflictions: (
    args?: {
      where?: AfflictionWhereInput;
      orderBy?: AfflictionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Affliction>;
  afflictionsConnection: (
    args?: {
      where?: AfflictionWhereInput;
      orderBy?: AfflictionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AfflictionConnectionPromise;
  anger: (where: AngerWhereUniqueInput) => AngerPromise;
  angers: (
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Anger>;
  angersConnection: (
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AngerConnectionPromise;
  armor: (where: ArmorWhereUniqueInput) => ArmorPromise;
  armors: (
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Armor>;
  armorsConnection: (
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ArmorConnectionPromise;
  body: (where: BodyWhereUniqueInput) => BodyPromise;
  bodies: (
    args?: {
      where?: BodyWhereInput;
      orderBy?: BodyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Body>;
  bodiesConnection: (
    args?: {
      where?: BodyWhereInput;
      orderBy?: BodyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BodyConnectionPromise;
  boundary: (where: BoundaryWhereUniqueInput) => BoundaryPromise;
  boundaries: (
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Boundary>;
  boundariesConnection: (
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BoundaryConnectionPromise;
  brain: (where: BrainWhereUniqueInput) => BrainPromise;
  brains: (
    args?: {
      where?: BrainWhereInput;
      orderBy?: BrainOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Brain>;
  brainsConnection: (
    args?: {
      where?: BrainWhereInput;
      orderBy?: BrainOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BrainConnectionPromise;
  campaign: (where: CampaignWhereUniqueInput) => CampaignPromise;
  campaigns: (
    args?: {
      where?: CampaignWhereInput;
      orderBy?: CampaignOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Campaign>;
  campaignsConnection: (
    args?: {
      where?: CampaignWhereInput;
      orderBy?: CampaignOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CampaignConnectionPromise;
  characters: (where: CharactersWhereUniqueInput) => CharactersPromise;
  characterses: (
    args?: {
      where?: CharactersWhereInput;
      orderBy?: CharactersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Characters>;
  charactersesConnection: (
    args?: {
      where?: CharactersWhereInput;
      orderBy?: CharactersOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CharactersConnectionPromise;
  compassion: (where: CompassionWhereUniqueInput) => CompassionPromise;
  compassions: (
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Compassion>;
  compassionsConnection: (
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompassionConnectionPromise;
  confusion: (where: ConfusionWhereUniqueInput) => ConfusionPromise;
  confusions: (
    args?: {
      where?: ConfusionWhereInput;
      orderBy?: ConfusionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Confusion>;
  confusionsConnection: (
    args?: {
      where?: ConfusionWhereInput;
      orderBy?: ConfusionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ConfusionConnectionPromise;
  congregant: (where: CongregantWhereUniqueInput) => CongregantPromise;
  congregants: (
    args?: {
      where?: CongregantWhereInput;
      orderBy?: CongregantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Congregant>;
  congregantsConnection: (
    args?: {
      where?: CongregantWhereInput;
      orderBy?: CongregantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CongregantConnectionPromise;
  construct: (where: ConstructWhereUniqueInput) => ConstructPromise;
  constructs: (
    args?: {
      where?: ConstructWhereInput;
      orderBy?: ConstructOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Construct>;
  constructsConnection: (
    args?: {
      where?: ConstructWhereInput;
      orderBy?: ConstructOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ConstructConnectionPromise;
  courage: (where: CourageWhereUniqueInput) => CouragePromise;
  courages: (
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Courage>;
  couragesConnection: (
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CourageConnectionPromise;
  cross: (where: CrossWhereUniqueInput) => CrossPromise;
  crosses: (
    args?: {
      where?: CrossWhereInput;
      orderBy?: CrossOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Cross>;
  crossesConnection: (
    args?: {
      where?: CrossWhereInput;
      orderBy?: CrossOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CrossConnectionPromise;
  crown: (where: CrownWhereUniqueInput) => CrownPromise;
  crowns: (
    args?: {
      where?: CrownWhereInput;
      orderBy?: CrownOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Crown>;
  crownsConnection: (
    args?: {
      where?: CrownWhereInput;
      orderBy?: CrownOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CrownConnectionPromise;
  crusade: (where: CrusadeWhereUniqueInput) => CrusadePromise;
  crusades: (
    args?: {
      where?: CrusadeWhereInput;
      orderBy?: CrusadeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Crusade>;
  crusadesConnection: (
    args?: {
      where?: CrusadeWhereInput;
      orderBy?: CrusadeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CrusadeConnectionPromise;
  defect: (where: DefectWhereUniqueInput) => DefectPromise;
  defects: (
    args?: {
      where?: DefectWhereInput;
      orderBy?: DefectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Defect>;
  defectsConnection: (
    args?: {
      where?: DefectWhereInput;
      orderBy?: DefectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DefectConnectionPromise;
  delirium: (where: DeliriumWhereUniqueInput) => DeliriumPromise;
  deliriums: (
    args?: {
      where?: DeliriumWhereInput;
      orderBy?: DeliriumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Delirium>;
  deliriumsConnection: (
    args?: {
      where?: DeliriumWhereInput;
      orderBy?: DeliriumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DeliriumConnectionPromise;
  denial: (where: DenialWhereUniqueInput) => DenialPromise;
  denials: (
    args?: {
      where?: DenialWhereInput;
      orderBy?: DenialOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Denial>;
  denialsConnection: (
    args?: {
      where?: DenialWhereInput;
      orderBy?: DenialOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DenialConnectionPromise;
  discontent: (where: DiscontentWhereUniqueInput) => DiscontentPromise;
  discontents: (
    args?: {
      where?: DiscontentWhereInput;
      orderBy?: DiscontentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Discontent>;
  discontentsConnection: (
    args?: {
      where?: DiscontentWhereInput;
      orderBy?: DiscontentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DiscontentConnectionPromise;
  dream: (where: DreamWhereUniqueInput) => DreamPromise;
  dreams: (
    args?: {
      where?: DreamWhereInput;
      orderBy?: DreamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Dream>;
  dreamsConnection: (
    args?: {
      where?: DreamWhereInput;
      orderBy?: DreamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DreamConnectionPromise;
  experience: (where: ExperienceWhereUniqueInput) => ExperiencePromise;
  experiences: (
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Experience>;
  experiencesConnection: (
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExperienceConnectionPromise;
  face: (where: FaceWhereUniqueInput) => FacePromise;
  faces: (
    args?: {
      where?: FaceWhereInput;
      orderBy?: FaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Face>;
  facesConnection: (
    args?: {
      where?: FaceWhereInput;
      orderBy?: FaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FaceConnectionPromise;
  fear: (where: FearWhereUniqueInput) => FearPromise;
  fears: (
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Fear>;
  fearsConnection: (
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FearConnectionPromise;
  feeling: (where: FeelingWhereUniqueInput) => FeelingPromise;
  feelings: (
    args?: {
      where?: FeelingWhereInput;
      orderBy?: FeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Feeling>;
  feelingsConnection: (
    args?: {
      where?: FeelingWhereInput;
      orderBy?: FeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FeelingConnectionPromise;
  fun: (where: FunWhereUniqueInput) => FunPromise;
  funs: (
    args?: {
      where?: FunWhereInput;
      orderBy?: FunOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Fun>;
  funsConnection: (
    args?: {
      where?: FunWhereInput;
      orderBy?: FunOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FunConnectionPromise;
  gash: (where: GashWhereUniqueInput) => GashPromise;
  gashes: (
    args?: {
      where?: GashWhereInput;
      orderBy?: GashOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Gash>;
  gashesConnection: (
    args?: {
      where?: GashWhereInput;
      orderBy?: GashOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GashConnectionPromise;
  gate: (where: GateWhereUniqueInput) => GatePromise;
  gates: (
    args?: {
      where?: GateWhereInput;
      orderBy?: GateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Gate>;
  gatesConnection: (
    args?: {
      where?: GateWhereInput;
      orderBy?: GateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GateConnectionPromise;
  genie: (where: GenieWhereUniqueInput) => GeniePromise;
  genies: (
    args?: {
      where?: GenieWhereInput;
      orderBy?: GenieOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Genie>;
  geniesConnection: (
    args?: {
      where?: GenieWhereInput;
      orderBy?: GenieOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GenieConnectionPromise;
  gratitude: (where: GratitudeWhereUniqueInput) => GratitudePromise;
  gratitudes: (
    args?: {
      where?: GratitudeWhereInput;
      orderBy?: GratitudeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Gratitude>;
  gratitudesConnection: (
    args?: {
      where?: GratitudeWhereInput;
      orderBy?: GratitudeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GratitudeConnectionPromise;
  guardian: (where: GuardianWhereUniqueInput) => GuardianPromise;
  guardians: (
    args?: {
      where?: GuardianWhereInput;
      orderBy?: GuardianOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Guardian>;
  guardiansConnection: (
    args?: {
      where?: GuardianWhereInput;
      orderBy?: GuardianOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GuardianConnectionPromise;
  gut: (where: GutWhereUniqueInput) => GutPromise;
  guts: (
    args?: {
      where?: GutWhereInput;
      orderBy?: GutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Gut>;
  gutsConnection: (
    args?: {
      where?: GutWhereInput;
      orderBy?: GutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => GutConnectionPromise;
  has: (where: HasWhereUniqueInput) => HasPromise;
  hases: (
    args?: {
      where?: HasWhereInput;
      orderBy?: HasOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Has>;
  hasesConnection: (
    args?: {
      where?: HasWhereInput;
      orderBy?: HasOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HasConnectionPromise;
  heart: (where: HeartWhereUniqueInput) => HeartPromise;
  hearts: (
    args?: {
      where?: HeartWhereInput;
      orderBy?: HeartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Heart>;
  heartsConnection: (
    args?: {
      where?: HeartWhereInput;
      orderBy?: HeartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HeartConnectionPromise;
  higherPower: (where: HigherPowerWhereUniqueInput) => HigherPowerPromise;
  higherPowers: (
    args?: {
      where?: HigherPowerWhereInput;
      orderBy?: HigherPowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HigherPower>;
  higherPowersConnection: (
    args?: {
      where?: HigherPowerWhereInput;
      orderBy?: HigherPowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HigherPowerConnectionPromise;
  honor: (where: HonorWhereUniqueInput) => HonorPromise;
  honors: (
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Honor>;
  honorsConnection: (
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HonorConnectionPromise;
  hope: (where: HopeWhereUniqueInput) => HopePromise;
  hopes: (
    args?: {
      where?: HopeWhereInput;
      orderBy?: HopeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Hope>;
  hopesConnection: (
    args?: {
      where?: HopeWhereInput;
      orderBy?: HopeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HopeConnectionPromise;
  impatience: (where: ImpatienceWhereUniqueInput) => ImpatiencePromise;
  impatiences: (
    args?: {
      where?: ImpatienceWhereInput;
      orderBy?: ImpatienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Impatience>;
  impatiencesConnection: (
    args?: {
      where?: ImpatienceWhereInput;
      orderBy?: ImpatienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ImpatienceConnectionPromise;
  infection: (where: InfectionWhereUniqueInput) => InfectionPromise;
  infections: (
    args?: {
      where?: InfectionWhereInput;
      orderBy?: InfectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Infection>;
  infectionsConnection: (
    args?: {
      where?: InfectionWhereInput;
      orderBy?: InfectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InfectionConnectionPromise;
  inventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  inventories: (
    args?: {
      where?: InventoryWhereInput;
      orderBy?: InventoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Inventory>;
  inventoriesConnection: (
    args?: {
      where?: InventoryWhereInput;
      orderBy?: InventoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InventoryConnectionPromise;
  irritability: (where: IrritabilityWhereUniqueInput) => IrritabilityPromise;
  irritabilities: (
    args?: {
      where?: IrritabilityWhereInput;
      orderBy?: IrritabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Irritability>;
  irritabilitiesConnection: (
    args?: {
      where?: IrritabilityWhereInput;
      orderBy?: IrritabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => IrritabilityConnectionPromise;
  joy: (where: JoyWhereUniqueInput) => JoyPromise;
  joys: (
    args?: {
      where?: JoyWhereInput;
      orderBy?: JoyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Joy>;
  joysConnection: (
    args?: {
      where?: JoyWhereInput;
      orderBy?: JoyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => JoyConnectionPromise;
  love: (where: LoveWhereUniqueInput) => LovePromise;
  loves: (
    args?: {
      where?: LoveWhereInput;
      orderBy?: LoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Love>;
  lovesConnection: (
    args?: {
      where?: LoveWhereInput;
      orderBy?: LoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LoveConnectionPromise;
  loyalty: (where: LoyaltyWhereUniqueInput) => LoyaltyPromise;
  loyalties: (
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Loyalty>;
  loyaltiesConnection: (
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LoyaltyConnectionPromise;
  martyr: (where: MartyrWhereUniqueInput) => MartyrPromise;
  martyrs: (
    args?: {
      where?: MartyrWhereInput;
      orderBy?: MartyrOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Martyr>;
  martyrsConnection: (
    args?: {
      where?: MartyrWhereInput;
      orderBy?: MartyrOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MartyrConnectionPromise;
  mind: (where: MindWhereUniqueInput) => MindPromise;
  minds: (
    args?: {
      where?: MindWhereInput;
      orderBy?: MindOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Mind>;
  mindsConnection: (
    args?: {
      where?: MindWhereInput;
      orderBy?: MindOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MindConnectionPromise;
  mouth: (where: MouthWhereUniqueInput) => MouthPromise;
  mouths: (
    args?: {
      where?: MouthWhereInput;
      orderBy?: MouthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Mouth>;
  mouthsConnection: (
    args?: {
      where?: MouthWhereInput;
      orderBy?: MouthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => MouthConnectionPromise;
  nail: (where: NailWhereUniqueInput) => NailPromise;
  nails: (
    args?: {
      where?: NailWhereInput;
      orderBy?: NailOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Nail>;
  nailsConnection: (
    args?: {
      where?: NailWhereInput;
      orderBy?: NailOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NailConnectionPromise;
  nightmare: (where: NightmareWhereUniqueInput) => NightmarePromise;
  nightmares: (
    args?: {
      where?: NightmareWhereInput;
      orderBy?: NightmareOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Nightmare>;
  nightmaresConnection: (
    args?: {
      where?: NightmareWhereInput;
      orderBy?: NightmareOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => NightmareConnectionPromise;
  oath: (where: OathWhereUniqueInput) => OathPromise;
  oaths: (
    args?: {
      where?: OathWhereInput;
      orderBy?: OathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Oath>;
  oathsConnection: (
    args?: {
      where?: OathWhereInput;
      orderBy?: OathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => OathConnectionPromise;
  obsession: (where: ObsessionWhereUniqueInput) => ObsessionPromise;
  obsessions: (
    args?: {
      where?: ObsessionWhereInput;
      orderBy?: ObsessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Obsession>;
  obsessionsConnection: (
    args?: {
      where?: ObsessionWhereInput;
      orderBy?: ObsessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ObsessionConnectionPromise;
  paladin: (where: PaladinWhereUniqueInput) => PaladinPromise;
  paladins: (
    args?: {
      where?: PaladinWhereInput;
      orderBy?: PaladinOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Paladin>;
  paladinsConnection: (
    args?: {
      where?: PaladinWhereInput;
      orderBy?: PaladinOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaladinConnectionPromise;
  path: (where: PathWhereUniqueInput) => PathPromise;
  paths: (
    args?: {
      where?: PathWhereInput;
      orderBy?: PathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Path>;
  pathsConnection: (
    args?: {
      where?: PathWhereInput;
      orderBy?: PathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PathConnectionPromise;
  pledge: (where: PledgeWhereUniqueInput) => PledgePromise;
  pledges: (
    args?: {
      where?: PledgeWhereInput;
      orderBy?: PledgeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Pledge>;
  pledgesConnection: (
    args?: {
      where?: PledgeWhereInput;
      orderBy?: PledgeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PledgeConnectionPromise;
  prayer: (where: PrayerWhereUniqueInput) => PrayerPromise;
  prayers: (
    args?: {
      where?: PrayerWhereInput;
      orderBy?: PrayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Prayer>;
  prayersConnection: (
    args?: {
      where?: PrayerWhereInput;
      orderBy?: PrayerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PrayerConnectionPromise;
  pride: (where: PrideWhereUniqueInput) => PridePromise;
  prides: (
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Pride>;
  pridesConnection: (
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PrideConnectionPromise;
  process: (where: ProcessWhereUniqueInput) => ProcessPromise;
  processes: (
    args?: {
      where?: ProcessWhereInput;
      orderBy?: ProcessOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Process>;
  processesConnection: (
    args?: {
      where?: ProcessWhereInput;
      orderBy?: ProcessOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProcessConnectionPromise;
  resentment: (where: ResentmentWhereUniqueInput) => ResentmentPromise;
  resentments: (
    args?: {
      where?: ResentmentWhereInput;
      orderBy?: ResentmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Resentment>;
  resentmentsConnection: (
    args?: {
      where?: ResentmentWhereInput;
      orderBy?: ResentmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ResentmentConnectionPromise;
  sacrifice: (where: SacrificeWhereUniqueInput) => SacrificePromise;
  sacrifices: (
    args?: {
      where?: SacrificeWhereInput;
      orderBy?: SacrificeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Sacrifice>;
  sacrificesConnection: (
    args?: {
      where?: SacrificeWhereInput;
      orderBy?: SacrificeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SacrificeConnectionPromise;
  salvation: (where: SalvationWhereUniqueInput) => SalvationPromise;
  salvations: (
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Salvation>;
  salvationsConnection: (
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SalvationConnectionPromise;
  sarcasm: (where: SarcasmWhereUniqueInput) => SarcasmPromise;
  sarcasms: (
    args?: {
      where?: SarcasmWhereInput;
      orderBy?: SarcasmOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Sarcasm>;
  sarcasmsConnection: (
    args?: {
      where?: SarcasmWhereInput;
      orderBy?: SarcasmOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SarcasmConnectionPromise;
  scar: (where: ScarWhereUniqueInput) => ScarPromise;
  scars: (
    args?: {
      where?: ScarWhereInput;
      orderBy?: ScarOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Scar>;
  scarsConnection: (
    args?: {
      where?: ScarWhereInput;
      orderBy?: ScarOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScarConnectionPromise;
  seeker: (where: SeekerWhereUniqueInput) => SeekerPromise;
  seekers: (
    args?: {
      where?: SeekerWhereInput;
      orderBy?: SeekerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Seeker>;
  seekersConnection: (
    args?: {
      where?: SeekerWhereInput;
      orderBy?: SeekerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SeekerConnectionPromise;
  self: (where: SelfWhereUniqueInput) => SelfPromise;
  selves: (
    args?: {
      where?: SelfWhereInput;
      orderBy?: SelfOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Self>;
  selvesConnection: (
    args?: {
      where?: SelfWhereInput;
      orderBy?: SelfOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SelfConnectionPromise;
  selfPity: (where: SelfPityWhereUniqueInput) => SelfPityPromise;
  selfPities: (
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SelfPity>;
  selfPitiesConnection: (
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SelfPityConnectionPromise;
  service: (where: ServiceWhereUniqueInput) => ServicePromise;
  services: (
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Service>;
  servicesConnection: (
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ServiceConnectionPromise;
  shield: (where: ShieldWhereUniqueInput) => ShieldPromise;
  shields: (
    args?: {
      where?: ShieldWhereInput;
      orderBy?: ShieldOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Shield>;
  shieldsConnection: (
    args?: {
      where?: ShieldWhereInput;
      orderBy?: ShieldOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ShieldConnectionPromise;
  silence: (where: SilenceWhereUniqueInput) => SilencePromise;
  silences: (
    args?: {
      where?: SilenceWhereInput;
      orderBy?: SilenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Silence>;
  silencesConnection: (
    args?: {
      where?: SilenceWhereInput;
      orderBy?: SilenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SilenceConnectionPromise;
  skin: (where: SkinWhereUniqueInput) => SkinPromise;
  skins: (
    args?: {
      where?: SkinWhereInput;
      orderBy?: SkinOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Skin>;
  skinsConnection: (
    args?: {
      where?: SkinWhereInput;
      orderBy?: SkinOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SkinConnectionPromise;
  smith: (where: SmithWhereUniqueInput) => SmithPromise;
  smiths: (
    args?: {
      where?: SmithWhereInput;
      orderBy?: SmithOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Smith>;
  smithsConnection: (
    args?: {
      where?: SmithWhereInput;
      orderBy?: SmithOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SmithConnectionPromise;
  soul: (where: SoulWhereUniqueInput) => SoulPromise;
  souls: (
    args?: {
      where?: SoulWhereInput;
      orderBy?: SoulOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Soul>;
  soulsConnection: (
    args?: {
      where?: SoulWhereInput;
      orderBy?: SoulOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SoulConnectionPromise;
  sternum: (where: SternumWhereUniqueInput) => SternumPromise;
  sternums: (
    args?: {
      where?: SternumWhereInput;
      orderBy?: SternumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Sternum>;
  sternumsConnection: (
    args?: {
      where?: SternumWhereInput;
      orderBy?: SternumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SternumConnectionPromise;
  stigmata: (where: StigmataWhereUniqueInput) => StigmataPromise;
  stigmatas: (
    args?: {
      where?: StigmataWhereInput;
      orderBy?: StigmataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Stigmata>;
  stigmatasConnection: (
    args?: {
      where?: StigmataWhereInput;
      orderBy?: StigmataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StigmataConnectionPromise;
  strength: (where: StrengthWhereUniqueInput) => StrengthPromise;
  strengths: (
    args?: {
      where?: StrengthWhereInput;
      orderBy?: StrengthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Strength>;
  strengthsConnection: (
    args?: {
      where?: StrengthWhereInput;
      orderBy?: StrengthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StrengthConnectionPromise;
  suffering: (where: SufferingWhereUniqueInput) => SufferingPromise;
  sufferings: (
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Suffering>;
  sufferingsConnection: (
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SufferingConnectionPromise;
  summoner: (where: SummonerWhereUniqueInput) => SummonerPromise;
  summoners: (
    args?: {
      where?: SummonerWhereInput;
      orderBy?: SummonerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Summoner>;
  summonersConnection: (
    args?: {
      where?: SummonerWhereInput;
      orderBy?: SummonerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SummonerConnectionPromise;
  support: (where: SupportWhereUniqueInput) => SupportPromise;
  supports: (
    args?: {
      where?: SupportWhereInput;
      orderBy?: SupportOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Support>;
  supportsConnection: (
    args?: {
      where?: SupportWhereInput;
      orderBy?: SupportOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SupportConnectionPromise;
  tower: (where: TowerWhereUniqueInput) => TowerPromise;
  towers: (
    args?: {
      where?: TowerWhereInput;
      orderBy?: TowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tower>;
  towersConnection: (
    args?: {
      where?: TowerWhereInput;
      orderBy?: TowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TowerConnectionPromise;
  toxicity: (where: ToxicityWhereUniqueInput) => ToxicityPromise;
  toxicities: (
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Toxicity>;
  toxicitiesConnection: (
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ToxicityConnectionPromise;
  trauma: (where: TraumaWhereUniqueInput) => TraumaPromise;
  traumas: (
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Trauma>;
  traumasConnection: (
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TraumaConnectionPromise;
  tremor: (where: TremorWhereUniqueInput) => TremorPromise;
  tremors: (
    args?: {
      where?: TremorWhereInput;
      orderBy?: TremorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tremor>;
  tremorsConnection: (
    args?: {
      where?: TremorWhereInput;
      orderBy?: TremorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TremorConnectionPromise;
  victim: (where: VictimWhereUniqueInput) => VictimPromise;
  victims: (
    args?: {
      where?: VictimWhereInput;
      orderBy?: VictimOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Victim>;
  victimsConnection: (
    args?: {
      where?: VictimWhereInput;
      orderBy?: VictimOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VictimConnectionPromise;
  virtue: (where: VirtueWhereUniqueInput) => VirtuePromise;
  virtues: (
    args?: {
      where?: VirtueWhereInput;
      orderBy?: VirtueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Virtue>;
  virtuesConnection: (
    args?: {
      where?: VirtueWhereInput;
      orderBy?: VirtueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VirtueConnectionPromise;
  volunteer: (where: VolunteerWhereUniqueInput) => VolunteerPromise;
  volunteers: (
    args?: {
      where?: VolunteerWhereInput;
      orderBy?: VolunteerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Volunteer>;
  volunteersConnection: (
    args?: {
      where?: VolunteerWhereInput;
      orderBy?: VolunteerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VolunteerConnectionPromise;
  vulnerability: (where: VulnerabilityWhereUniqueInput) => VulnerabilityPromise;
  vulnerabilities: (
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Vulnerability>;
  vulnerabilitiesConnection: (
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VulnerabilityConnectionPromise;
  wall: (where: WallWhereUniqueInput) => WallPromise;
  walls: (
    args?: {
      where?: WallWhereInput;
      orderBy?: WallOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Wall>;
  wallsConnection: (
    args?: {
      where?: WallWhereInput;
      orderBy?: WallOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WallConnectionPromise;
  wish: (where: WishWhereUniqueInput) => WishPromise;
  wishes: (
    args?: {
      where?: WishWhereInput;
      orderBy?: WishOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Wish>;
  wishesConnection: (
    args?: {
      where?: WishWhereInput;
      orderBy?: WishOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => WishConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAcceptance: (data: AcceptanceCreateInput) => AcceptancePromise;
  updateAcceptance: (
    args: { data: AcceptanceUpdateInput; where: AcceptanceWhereUniqueInput }
  ) => AcceptancePromise;
  updateManyAcceptances: (
    args: {
      data: AcceptanceUpdateManyMutationInput;
      where?: AcceptanceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAcceptance: (
    args: {
      where: AcceptanceWhereUniqueInput;
      create: AcceptanceCreateInput;
      update: AcceptanceUpdateInput;
    }
  ) => AcceptancePromise;
  deleteAcceptance: (where: AcceptanceWhereUniqueInput) => AcceptancePromise;
  deleteManyAcceptances: (where?: AcceptanceWhereInput) => BatchPayloadPromise;
  createAct: (data: ActCreateInput) => ActPromise;
  updateAct: (
    args: { data: ActUpdateInput; where: ActWhereUniqueInput }
  ) => ActPromise;
  upsertAct: (
    args: {
      where: ActWhereUniqueInput;
      create: ActCreateInput;
      update: ActUpdateInput;
    }
  ) => ActPromise;
  deleteAct: (where: ActWhereUniqueInput) => ActPromise;
  deleteManyActs: (where?: ActWhereInput) => BatchPayloadPromise;
  createAffliction: (data: AfflictionCreateInput) => AfflictionPromise;
  updateAffliction: (
    args: { data: AfflictionUpdateInput; where: AfflictionWhereUniqueInput }
  ) => AfflictionPromise;
  upsertAffliction: (
    args: {
      where: AfflictionWhereUniqueInput;
      create: AfflictionCreateInput;
      update: AfflictionUpdateInput;
    }
  ) => AfflictionPromise;
  deleteAffliction: (where: AfflictionWhereUniqueInput) => AfflictionPromise;
  deleteManyAfflictions: (where?: AfflictionWhereInput) => BatchPayloadPromise;
  createAnger: (data: AngerCreateInput) => AngerPromise;
  updateAnger: (
    args: { data: AngerUpdateInput; where: AngerWhereUniqueInput }
  ) => AngerPromise;
  updateManyAngers: (
    args: { data: AngerUpdateManyMutationInput; where?: AngerWhereInput }
  ) => BatchPayloadPromise;
  upsertAnger: (
    args: {
      where: AngerWhereUniqueInput;
      create: AngerCreateInput;
      update: AngerUpdateInput;
    }
  ) => AngerPromise;
  deleteAnger: (where: AngerWhereUniqueInput) => AngerPromise;
  deleteManyAngers: (where?: AngerWhereInput) => BatchPayloadPromise;
  createArmor: (data: ArmorCreateInput) => ArmorPromise;
  updateArmor: (
    args: { data: ArmorUpdateInput; where: ArmorWhereUniqueInput }
  ) => ArmorPromise;
  updateManyArmors: (
    args: { data: ArmorUpdateManyMutationInput; where?: ArmorWhereInput }
  ) => BatchPayloadPromise;
  upsertArmor: (
    args: {
      where: ArmorWhereUniqueInput;
      create: ArmorCreateInput;
      update: ArmorUpdateInput;
    }
  ) => ArmorPromise;
  deleteArmor: (where: ArmorWhereUniqueInput) => ArmorPromise;
  deleteManyArmors: (where?: ArmorWhereInput) => BatchPayloadPromise;
  createBody: (data: BodyCreateInput) => BodyPromise;
  updateBody: (
    args: { data: BodyUpdateInput; where: BodyWhereUniqueInput }
  ) => BodyPromise;
  upsertBody: (
    args: {
      where: BodyWhereUniqueInput;
      create: BodyCreateInput;
      update: BodyUpdateInput;
    }
  ) => BodyPromise;
  deleteBody: (where: BodyWhereUniqueInput) => BodyPromise;
  deleteManyBodies: (where?: BodyWhereInput) => BatchPayloadPromise;
  createBoundary: (data: BoundaryCreateInput) => BoundaryPromise;
  updateBoundary: (
    args: { data: BoundaryUpdateInput; where: BoundaryWhereUniqueInput }
  ) => BoundaryPromise;
  updateManyBoundaries: (
    args: { data: BoundaryUpdateManyMutationInput; where?: BoundaryWhereInput }
  ) => BatchPayloadPromise;
  upsertBoundary: (
    args: {
      where: BoundaryWhereUniqueInput;
      create: BoundaryCreateInput;
      update: BoundaryUpdateInput;
    }
  ) => BoundaryPromise;
  deleteBoundary: (where: BoundaryWhereUniqueInput) => BoundaryPromise;
  deleteManyBoundaries: (where?: BoundaryWhereInput) => BatchPayloadPromise;
  createBrain: (data: BrainCreateInput) => BrainPromise;
  updateBrain: (
    args: { data: BrainUpdateInput; where: BrainWhereUniqueInput }
  ) => BrainPromise;
  upsertBrain: (
    args: {
      where: BrainWhereUniqueInput;
      create: BrainCreateInput;
      update: BrainUpdateInput;
    }
  ) => BrainPromise;
  deleteBrain: (where: BrainWhereUniqueInput) => BrainPromise;
  deleteManyBrains: (where?: BrainWhereInput) => BatchPayloadPromise;
  createCampaign: (data: CampaignCreateInput) => CampaignPromise;
  updateCampaign: (
    args: { data: CampaignUpdateInput; where: CampaignWhereUniqueInput }
  ) => CampaignPromise;
  upsertCampaign: (
    args: {
      where: CampaignWhereUniqueInput;
      create: CampaignCreateInput;
      update: CampaignUpdateInput;
    }
  ) => CampaignPromise;
  deleteCampaign: (where: CampaignWhereUniqueInput) => CampaignPromise;
  deleteManyCampaigns: (where?: CampaignWhereInput) => BatchPayloadPromise;
  createCharacters: (data: CharactersCreateInput) => CharactersPromise;
  updateCharacters: (
    args: { data: CharactersUpdateInput; where: CharactersWhereUniqueInput }
  ) => CharactersPromise;
  upsertCharacters: (
    args: {
      where: CharactersWhereUniqueInput;
      create: CharactersCreateInput;
      update: CharactersUpdateInput;
    }
  ) => CharactersPromise;
  deleteCharacters: (where: CharactersWhereUniqueInput) => CharactersPromise;
  deleteManyCharacterses: (where?: CharactersWhereInput) => BatchPayloadPromise;
  createCompassion: (data: CompassionCreateInput) => CompassionPromise;
  updateCompassion: (
    args: { data: CompassionUpdateInput; where: CompassionWhereUniqueInput }
  ) => CompassionPromise;
  updateManyCompassions: (
    args: {
      data: CompassionUpdateManyMutationInput;
      where?: CompassionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCompassion: (
    args: {
      where: CompassionWhereUniqueInput;
      create: CompassionCreateInput;
      update: CompassionUpdateInput;
    }
  ) => CompassionPromise;
  deleteCompassion: (where: CompassionWhereUniqueInput) => CompassionPromise;
  deleteManyCompassions: (where?: CompassionWhereInput) => BatchPayloadPromise;
  createConfusion: (data: ConfusionCreateInput) => ConfusionPromise;
  updateConfusion: (
    args: { data: ConfusionUpdateInput; where: ConfusionWhereUniqueInput }
  ) => ConfusionPromise;
  upsertConfusion: (
    args: {
      where: ConfusionWhereUniqueInput;
      create: ConfusionCreateInput;
      update: ConfusionUpdateInput;
    }
  ) => ConfusionPromise;
  deleteConfusion: (where: ConfusionWhereUniqueInput) => ConfusionPromise;
  deleteManyConfusions: (where?: ConfusionWhereInput) => BatchPayloadPromise;
  createCongregant: (data: CongregantCreateInput) => CongregantPromise;
  deleteCongregant: (where: CongregantWhereUniqueInput) => CongregantPromise;
  deleteManyCongregants: (where?: CongregantWhereInput) => BatchPayloadPromise;
  createConstruct: (data: ConstructCreateInput) => ConstructPromise;
  updateConstruct: (
    args: { data: ConstructUpdateInput; where: ConstructWhereUniqueInput }
  ) => ConstructPromise;
  upsertConstruct: (
    args: {
      where: ConstructWhereUniqueInput;
      create: ConstructCreateInput;
      update: ConstructUpdateInput;
    }
  ) => ConstructPromise;
  deleteConstruct: (where: ConstructWhereUniqueInput) => ConstructPromise;
  deleteManyConstructs: (where?: ConstructWhereInput) => BatchPayloadPromise;
  createCourage: (data: CourageCreateInput) => CouragePromise;
  updateCourage: (
    args: { data: CourageUpdateInput; where: CourageWhereUniqueInput }
  ) => CouragePromise;
  updateManyCourages: (
    args: { data: CourageUpdateManyMutationInput; where?: CourageWhereInput }
  ) => BatchPayloadPromise;
  upsertCourage: (
    args: {
      where: CourageWhereUniqueInput;
      create: CourageCreateInput;
      update: CourageUpdateInput;
    }
  ) => CouragePromise;
  deleteCourage: (where: CourageWhereUniqueInput) => CouragePromise;
  deleteManyCourages: (where?: CourageWhereInput) => BatchPayloadPromise;
  createCross: (data: CrossCreateInput) => CrossPromise;
  updateCross: (
    args: { data: CrossUpdateInput; where: CrossWhereUniqueInput }
  ) => CrossPromise;
  upsertCross: (
    args: {
      where: CrossWhereUniqueInput;
      create: CrossCreateInput;
      update: CrossUpdateInput;
    }
  ) => CrossPromise;
  deleteCross: (where: CrossWhereUniqueInput) => CrossPromise;
  deleteManyCrosses: (where?: CrossWhereInput) => BatchPayloadPromise;
  createCrown: (data: CrownCreateInput) => CrownPromise;
  updateCrown: (
    args: { data: CrownUpdateInput; where: CrownWhereUniqueInput }
  ) => CrownPromise;
  upsertCrown: (
    args: {
      where: CrownWhereUniqueInput;
      create: CrownCreateInput;
      update: CrownUpdateInput;
    }
  ) => CrownPromise;
  deleteCrown: (where: CrownWhereUniqueInput) => CrownPromise;
  deleteManyCrowns: (where?: CrownWhereInput) => BatchPayloadPromise;
  createCrusade: (data: CrusadeCreateInput) => CrusadePromise;
  updateCrusade: (
    args: { data: CrusadeUpdateInput; where: CrusadeWhereUniqueInput }
  ) => CrusadePromise;
  upsertCrusade: (
    args: {
      where: CrusadeWhereUniqueInput;
      create: CrusadeCreateInput;
      update: CrusadeUpdateInput;
    }
  ) => CrusadePromise;
  deleteCrusade: (where: CrusadeWhereUniqueInput) => CrusadePromise;
  deleteManyCrusades: (where?: CrusadeWhereInput) => BatchPayloadPromise;
  createDefect: (data: DefectCreateInput) => DefectPromise;
  updateDefect: (
    args: { data: DefectUpdateInput; where: DefectWhereUniqueInput }
  ) => DefectPromise;
  upsertDefect: (
    args: {
      where: DefectWhereUniqueInput;
      create: DefectCreateInput;
      update: DefectUpdateInput;
    }
  ) => DefectPromise;
  deleteDefect: (where: DefectWhereUniqueInput) => DefectPromise;
  deleteManyDefects: (where?: DefectWhereInput) => BatchPayloadPromise;
  createDelirium: (data: DeliriumCreateInput) => DeliriumPromise;
  updateDelirium: (
    args: { data: DeliriumUpdateInput; where: DeliriumWhereUniqueInput }
  ) => DeliriumPromise;
  upsertDelirium: (
    args: {
      where: DeliriumWhereUniqueInput;
      create: DeliriumCreateInput;
      update: DeliriumUpdateInput;
    }
  ) => DeliriumPromise;
  deleteDelirium: (where: DeliriumWhereUniqueInput) => DeliriumPromise;
  deleteManyDeliriums: (where?: DeliriumWhereInput) => BatchPayloadPromise;
  createDenial: (data: DenialCreateInput) => DenialPromise;
  updateDenial: (
    args: { data: DenialUpdateInput; where: DenialWhereUniqueInput }
  ) => DenialPromise;
  upsertDenial: (
    args: {
      where: DenialWhereUniqueInput;
      create: DenialCreateInput;
      update: DenialUpdateInput;
    }
  ) => DenialPromise;
  deleteDenial: (where: DenialWhereUniqueInput) => DenialPromise;
  deleteManyDenials: (where?: DenialWhereInput) => BatchPayloadPromise;
  createDiscontent: (data: DiscontentCreateInput) => DiscontentPromise;
  updateDiscontent: (
    args: { data: DiscontentUpdateInput; where: DiscontentWhereUniqueInput }
  ) => DiscontentPromise;
  upsertDiscontent: (
    args: {
      where: DiscontentWhereUniqueInput;
      create: DiscontentCreateInput;
      update: DiscontentUpdateInput;
    }
  ) => DiscontentPromise;
  deleteDiscontent: (where: DiscontentWhereUniqueInput) => DiscontentPromise;
  deleteManyDiscontents: (where?: DiscontentWhereInput) => BatchPayloadPromise;
  createDream: (data: DreamCreateInput) => DreamPromise;
  updateDream: (
    args: { data: DreamUpdateInput; where: DreamWhereUniqueInput }
  ) => DreamPromise;
  upsertDream: (
    args: {
      where: DreamWhereUniqueInput;
      create: DreamCreateInput;
      update: DreamUpdateInput;
    }
  ) => DreamPromise;
  deleteDream: (where: DreamWhereUniqueInput) => DreamPromise;
  deleteManyDreams: (where?: DreamWhereInput) => BatchPayloadPromise;
  createExperience: (data: ExperienceCreateInput) => ExperiencePromise;
  updateExperience: (
    args: { data: ExperienceUpdateInput; where: ExperienceWhereUniqueInput }
  ) => ExperiencePromise;
  upsertExperience: (
    args: {
      where: ExperienceWhereUniqueInput;
      create: ExperienceCreateInput;
      update: ExperienceUpdateInput;
    }
  ) => ExperiencePromise;
  deleteExperience: (where: ExperienceWhereUniqueInput) => ExperiencePromise;
  deleteManyExperiences: (where?: ExperienceWhereInput) => BatchPayloadPromise;
  createFace: (data: FaceCreateInput) => FacePromise;
  updateFace: (
    args: { data: FaceUpdateInput; where: FaceWhereUniqueInput }
  ) => FacePromise;
  upsertFace: (
    args: {
      where: FaceWhereUniqueInput;
      create: FaceCreateInput;
      update: FaceUpdateInput;
    }
  ) => FacePromise;
  deleteFace: (where: FaceWhereUniqueInput) => FacePromise;
  deleteManyFaces: (where?: FaceWhereInput) => BatchPayloadPromise;
  createFear: (data: FearCreateInput) => FearPromise;
  updateFear: (
    args: { data: FearUpdateInput; where: FearWhereUniqueInput }
  ) => FearPromise;
  updateManyFears: (
    args: { data: FearUpdateManyMutationInput; where?: FearWhereInput }
  ) => BatchPayloadPromise;
  upsertFear: (
    args: {
      where: FearWhereUniqueInput;
      create: FearCreateInput;
      update: FearUpdateInput;
    }
  ) => FearPromise;
  deleteFear: (where: FearWhereUniqueInput) => FearPromise;
  deleteManyFears: (where?: FearWhereInput) => BatchPayloadPromise;
  createFeeling: (data: FeelingCreateInput) => FeelingPromise;
  updateFeeling: (
    args: { data: FeelingUpdateInput; where: FeelingWhereUniqueInput }
  ) => FeelingPromise;
  updateManyFeelings: (
    args: { data: FeelingUpdateManyMutationInput; where?: FeelingWhereInput }
  ) => BatchPayloadPromise;
  upsertFeeling: (
    args: {
      where: FeelingWhereUniqueInput;
      create: FeelingCreateInput;
      update: FeelingUpdateInput;
    }
  ) => FeelingPromise;
  deleteFeeling: (where: FeelingWhereUniqueInput) => FeelingPromise;
  deleteManyFeelings: (where?: FeelingWhereInput) => BatchPayloadPromise;
  createFun: (data: FunCreateInput) => FunPromise;
  updateFun: (
    args: { data: FunUpdateInput; where: FunWhereUniqueInput }
  ) => FunPromise;
  updateManyFuns: (
    args: { data: FunUpdateManyMutationInput; where?: FunWhereInput }
  ) => BatchPayloadPromise;
  upsertFun: (
    args: {
      where: FunWhereUniqueInput;
      create: FunCreateInput;
      update: FunUpdateInput;
    }
  ) => FunPromise;
  deleteFun: (where: FunWhereUniqueInput) => FunPromise;
  deleteManyFuns: (where?: FunWhereInput) => BatchPayloadPromise;
  createGash: (data: GashCreateInput) => GashPromise;
  updateGash: (
    args: { data: GashUpdateInput; where: GashWhereUniqueInput }
  ) => GashPromise;
  upsertGash: (
    args: {
      where: GashWhereUniqueInput;
      create: GashCreateInput;
      update: GashUpdateInput;
    }
  ) => GashPromise;
  deleteGash: (where: GashWhereUniqueInput) => GashPromise;
  deleteManyGashes: (where?: GashWhereInput) => BatchPayloadPromise;
  createGate: (data: GateCreateInput) => GatePromise;
  updateGate: (
    args: { data: GateUpdateInput; where: GateWhereUniqueInput }
  ) => GatePromise;
  upsertGate: (
    args: {
      where: GateWhereUniqueInput;
      create: GateCreateInput;
      update: GateUpdateInput;
    }
  ) => GatePromise;
  deleteGate: (where: GateWhereUniqueInput) => GatePromise;
  deleteManyGates: (where?: GateWhereInput) => BatchPayloadPromise;
  createGenie: (data: GenieCreateInput) => GeniePromise;
  updateGenie: (
    args: { data: GenieUpdateInput; where: GenieWhereUniqueInput }
  ) => GeniePromise;
  upsertGenie: (
    args: {
      where: GenieWhereUniqueInput;
      create: GenieCreateInput;
      update: GenieUpdateInput;
    }
  ) => GeniePromise;
  deleteGenie: (where: GenieWhereUniqueInput) => GeniePromise;
  deleteManyGenies: (where?: GenieWhereInput) => BatchPayloadPromise;
  createGratitude: (data: GratitudeCreateInput) => GratitudePromise;
  updateGratitude: (
    args: { data: GratitudeUpdateInput; where: GratitudeWhereUniqueInput }
  ) => GratitudePromise;
  updateManyGratitudes: (
    args: {
      data: GratitudeUpdateManyMutationInput;
      where?: GratitudeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertGratitude: (
    args: {
      where: GratitudeWhereUniqueInput;
      create: GratitudeCreateInput;
      update: GratitudeUpdateInput;
    }
  ) => GratitudePromise;
  deleteGratitude: (where: GratitudeWhereUniqueInput) => GratitudePromise;
  deleteManyGratitudes: (where?: GratitudeWhereInput) => BatchPayloadPromise;
  createGuardian: (data: GuardianCreateInput) => GuardianPromise;
  updateGuardian: (
    args: { data: GuardianUpdateInput; where: GuardianWhereUniqueInput }
  ) => GuardianPromise;
  upsertGuardian: (
    args: {
      where: GuardianWhereUniqueInput;
      create: GuardianCreateInput;
      update: GuardianUpdateInput;
    }
  ) => GuardianPromise;
  deleteGuardian: (where: GuardianWhereUniqueInput) => GuardianPromise;
  deleteManyGuardians: (where?: GuardianWhereInput) => BatchPayloadPromise;
  createGut: (data: GutCreateInput) => GutPromise;
  updateGut: (
    args: { data: GutUpdateInput; where: GutWhereUniqueInput }
  ) => GutPromise;
  upsertGut: (
    args: {
      where: GutWhereUniqueInput;
      create: GutCreateInput;
      update: GutUpdateInput;
    }
  ) => GutPromise;
  deleteGut: (where: GutWhereUniqueInput) => GutPromise;
  deleteManyGuts: (where?: GutWhereInput) => BatchPayloadPromise;
  createHas: (data: HasCreateInput) => HasPromise;
  updateHas: (
    args: { data: HasUpdateInput; where: HasWhereUniqueInput }
  ) => HasPromise;
  updateManyHases: (
    args: { data: HasUpdateManyMutationInput; where?: HasWhereInput }
  ) => BatchPayloadPromise;
  upsertHas: (
    args: {
      where: HasWhereUniqueInput;
      create: HasCreateInput;
      update: HasUpdateInput;
    }
  ) => HasPromise;
  deleteHas: (where: HasWhereUniqueInput) => HasPromise;
  deleteManyHases: (where?: HasWhereInput) => BatchPayloadPromise;
  createHeart: (data: HeartCreateInput) => HeartPromise;
  updateHeart: (
    args: { data: HeartUpdateInput; where: HeartWhereUniqueInput }
  ) => HeartPromise;
  upsertHeart: (
    args: {
      where: HeartWhereUniqueInput;
      create: HeartCreateInput;
      update: HeartUpdateInput;
    }
  ) => HeartPromise;
  deleteHeart: (where: HeartWhereUniqueInput) => HeartPromise;
  deleteManyHearts: (where?: HeartWhereInput) => BatchPayloadPromise;
  createHigherPower: (data: HigherPowerCreateInput) => HigherPowerPromise;
  updateHigherPower: (
    args: { data: HigherPowerUpdateInput; where: HigherPowerWhereUniqueInput }
  ) => HigherPowerPromise;
  upsertHigherPower: (
    args: {
      where: HigherPowerWhereUniqueInput;
      create: HigherPowerCreateInput;
      update: HigherPowerUpdateInput;
    }
  ) => HigherPowerPromise;
  deleteHigherPower: (where: HigherPowerWhereUniqueInput) => HigherPowerPromise;
  deleteManyHigherPowers: (
    where?: HigherPowerWhereInput
  ) => BatchPayloadPromise;
  createHonor: (data: HonorCreateInput) => HonorPromise;
  updateHonor: (
    args: { data: HonorUpdateInput; where: HonorWhereUniqueInput }
  ) => HonorPromise;
  updateManyHonors: (
    args: { data: HonorUpdateManyMutationInput; where?: HonorWhereInput }
  ) => BatchPayloadPromise;
  upsertHonor: (
    args: {
      where: HonorWhereUniqueInput;
      create: HonorCreateInput;
      update: HonorUpdateInput;
    }
  ) => HonorPromise;
  deleteHonor: (where: HonorWhereUniqueInput) => HonorPromise;
  deleteManyHonors: (where?: HonorWhereInput) => BatchPayloadPromise;
  createHope: (data: HopeCreateInput) => HopePromise;
  updateHope: (
    args: { data: HopeUpdateInput; where: HopeWhereUniqueInput }
  ) => HopePromise;
  upsertHope: (
    args: {
      where: HopeWhereUniqueInput;
      create: HopeCreateInput;
      update: HopeUpdateInput;
    }
  ) => HopePromise;
  deleteHope: (where: HopeWhereUniqueInput) => HopePromise;
  deleteManyHopes: (where?: HopeWhereInput) => BatchPayloadPromise;
  createImpatience: (data: ImpatienceCreateInput) => ImpatiencePromise;
  updateImpatience: (
    args: { data: ImpatienceUpdateInput; where: ImpatienceWhereUniqueInput }
  ) => ImpatiencePromise;
  updateManyImpatiences: (
    args: {
      data: ImpatienceUpdateManyMutationInput;
      where?: ImpatienceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertImpatience: (
    args: {
      where: ImpatienceWhereUniqueInput;
      create: ImpatienceCreateInput;
      update: ImpatienceUpdateInput;
    }
  ) => ImpatiencePromise;
  deleteImpatience: (where: ImpatienceWhereUniqueInput) => ImpatiencePromise;
  deleteManyImpatiences: (where?: ImpatienceWhereInput) => BatchPayloadPromise;
  createInfection: (data: InfectionCreateInput) => InfectionPromise;
  updateInfection: (
    args: { data: InfectionUpdateInput; where: InfectionWhereUniqueInput }
  ) => InfectionPromise;
  upsertInfection: (
    args: {
      where: InfectionWhereUniqueInput;
      create: InfectionCreateInput;
      update: InfectionUpdateInput;
    }
  ) => InfectionPromise;
  deleteInfection: (where: InfectionWhereUniqueInput) => InfectionPromise;
  deleteManyInfections: (where?: InfectionWhereInput) => BatchPayloadPromise;
  createInventory: (data: InventoryCreateInput) => InventoryPromise;
  updateInventory: (
    args: { data: InventoryUpdateInput; where: InventoryWhereUniqueInput }
  ) => InventoryPromise;
  upsertInventory: (
    args: {
      where: InventoryWhereUniqueInput;
      create: InventoryCreateInput;
      update: InventoryUpdateInput;
    }
  ) => InventoryPromise;
  deleteInventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  deleteManyInventories: (where?: InventoryWhereInput) => BatchPayloadPromise;
  createIrritability: (data: IrritabilityCreateInput) => IrritabilityPromise;
  updateIrritability: (
    args: { data: IrritabilityUpdateInput; where: IrritabilityWhereUniqueInput }
  ) => IrritabilityPromise;
  updateManyIrritabilities: (
    args: {
      data: IrritabilityUpdateManyMutationInput;
      where?: IrritabilityWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertIrritability: (
    args: {
      where: IrritabilityWhereUniqueInput;
      create: IrritabilityCreateInput;
      update: IrritabilityUpdateInput;
    }
  ) => IrritabilityPromise;
  deleteIrritability: (
    where: IrritabilityWhereUniqueInput
  ) => IrritabilityPromise;
  deleteManyIrritabilities: (
    where?: IrritabilityWhereInput
  ) => BatchPayloadPromise;
  createJoy: (data: JoyCreateInput) => JoyPromise;
  updateJoy: (
    args: { data: JoyUpdateInput; where: JoyWhereUniqueInput }
  ) => JoyPromise;
  updateManyJoys: (
    args: { data: JoyUpdateManyMutationInput; where?: JoyWhereInput }
  ) => BatchPayloadPromise;
  upsertJoy: (
    args: {
      where: JoyWhereUniqueInput;
      create: JoyCreateInput;
      update: JoyUpdateInput;
    }
  ) => JoyPromise;
  deleteJoy: (where: JoyWhereUniqueInput) => JoyPromise;
  deleteManyJoys: (where?: JoyWhereInput) => BatchPayloadPromise;
  createLove: (data: LoveCreateInput) => LovePromise;
  updateLove: (
    args: { data: LoveUpdateInput; where: LoveWhereUniqueInput }
  ) => LovePromise;
  upsertLove: (
    args: {
      where: LoveWhereUniqueInput;
      create: LoveCreateInput;
      update: LoveUpdateInput;
    }
  ) => LovePromise;
  deleteLove: (where: LoveWhereUniqueInput) => LovePromise;
  deleteManyLoves: (where?: LoveWhereInput) => BatchPayloadPromise;
  createLoyalty: (data: LoyaltyCreateInput) => LoyaltyPromise;
  updateLoyalty: (
    args: { data: LoyaltyUpdateInput; where: LoyaltyWhereUniqueInput }
  ) => LoyaltyPromise;
  updateManyLoyalties: (
    args: { data: LoyaltyUpdateManyMutationInput; where?: LoyaltyWhereInput }
  ) => BatchPayloadPromise;
  upsertLoyalty: (
    args: {
      where: LoyaltyWhereUniqueInput;
      create: LoyaltyCreateInput;
      update: LoyaltyUpdateInput;
    }
  ) => LoyaltyPromise;
  deleteLoyalty: (where: LoyaltyWhereUniqueInput) => LoyaltyPromise;
  deleteManyLoyalties: (where?: LoyaltyWhereInput) => BatchPayloadPromise;
  createMartyr: (data: MartyrCreateInput) => MartyrPromise;
  updateMartyr: (
    args: { data: MartyrUpdateInput; where: MartyrWhereUniqueInput }
  ) => MartyrPromise;
  upsertMartyr: (
    args: {
      where: MartyrWhereUniqueInput;
      create: MartyrCreateInput;
      update: MartyrUpdateInput;
    }
  ) => MartyrPromise;
  deleteMartyr: (where: MartyrWhereUniqueInput) => MartyrPromise;
  deleteManyMartyrs: (where?: MartyrWhereInput) => BatchPayloadPromise;
  createMind: (data: MindCreateInput) => MindPromise;
  updateMind: (
    args: { data: MindUpdateInput; where: MindWhereUniqueInput }
  ) => MindPromise;
  upsertMind: (
    args: {
      where: MindWhereUniqueInput;
      create: MindCreateInput;
      update: MindUpdateInput;
    }
  ) => MindPromise;
  deleteMind: (where: MindWhereUniqueInput) => MindPromise;
  deleteManyMinds: (where?: MindWhereInput) => BatchPayloadPromise;
  createMouth: (data: MouthCreateInput) => MouthPromise;
  updateMouth: (
    args: { data: MouthUpdateInput; where: MouthWhereUniqueInput }
  ) => MouthPromise;
  upsertMouth: (
    args: {
      where: MouthWhereUniqueInput;
      create: MouthCreateInput;
      update: MouthUpdateInput;
    }
  ) => MouthPromise;
  deleteMouth: (where: MouthWhereUniqueInput) => MouthPromise;
  deleteManyMouths: (where?: MouthWhereInput) => BatchPayloadPromise;
  createNail: (data: NailCreateInput) => NailPromise;
  updateNail: (
    args: { data: NailUpdateInput; where: NailWhereUniqueInput }
  ) => NailPromise;
  upsertNail: (
    args: {
      where: NailWhereUniqueInput;
      create: NailCreateInput;
      update: NailUpdateInput;
    }
  ) => NailPromise;
  deleteNail: (where: NailWhereUniqueInput) => NailPromise;
  deleteManyNails: (where?: NailWhereInput) => BatchPayloadPromise;
  createNightmare: (data: NightmareCreateInput) => NightmarePromise;
  updateNightmare: (
    args: { data: NightmareUpdateInput; where: NightmareWhereUniqueInput }
  ) => NightmarePromise;
  upsertNightmare: (
    args: {
      where: NightmareWhereUniqueInput;
      create: NightmareCreateInput;
      update: NightmareUpdateInput;
    }
  ) => NightmarePromise;
  deleteNightmare: (where: NightmareWhereUniqueInput) => NightmarePromise;
  deleteManyNightmares: (where?: NightmareWhereInput) => BatchPayloadPromise;
  createOath: (data: OathCreateInput) => OathPromise;
  updateOath: (
    args: { data: OathUpdateInput; where: OathWhereUniqueInput }
  ) => OathPromise;
  upsertOath: (
    args: {
      where: OathWhereUniqueInput;
      create: OathCreateInput;
      update: OathUpdateInput;
    }
  ) => OathPromise;
  deleteOath: (where: OathWhereUniqueInput) => OathPromise;
  deleteManyOaths: (where?: OathWhereInput) => BatchPayloadPromise;
  createObsession: (data: ObsessionCreateInput) => ObsessionPromise;
  updateObsession: (
    args: { data: ObsessionUpdateInput; where: ObsessionWhereUniqueInput }
  ) => ObsessionPromise;
  upsertObsession: (
    args: {
      where: ObsessionWhereUniqueInput;
      create: ObsessionCreateInput;
      update: ObsessionUpdateInput;
    }
  ) => ObsessionPromise;
  deleteObsession: (where: ObsessionWhereUniqueInput) => ObsessionPromise;
  deleteManyObsessions: (where?: ObsessionWhereInput) => BatchPayloadPromise;
  createPaladin: (data: PaladinCreateInput) => PaladinPromise;
  updatePaladin: (
    args: { data: PaladinUpdateInput; where: PaladinWhereUniqueInput }
  ) => PaladinPromise;
  upsertPaladin: (
    args: {
      where: PaladinWhereUniqueInput;
      create: PaladinCreateInput;
      update: PaladinUpdateInput;
    }
  ) => PaladinPromise;
  deletePaladin: (where: PaladinWhereUniqueInput) => PaladinPromise;
  deleteManyPaladins: (where?: PaladinWhereInput) => BatchPayloadPromise;
  createPath: (data: PathCreateInput) => PathPromise;
  updatePath: (
    args: { data: PathUpdateInput; where: PathWhereUniqueInput }
  ) => PathPromise;
  upsertPath: (
    args: {
      where: PathWhereUniqueInput;
      create: PathCreateInput;
      update: PathUpdateInput;
    }
  ) => PathPromise;
  deletePath: (where: PathWhereUniqueInput) => PathPromise;
  deleteManyPaths: (where?: PathWhereInput) => BatchPayloadPromise;
  createPledge: (data: PledgeCreateInput) => PledgePromise;
  updatePledge: (
    args: { data: PledgeUpdateInput; where: PledgeWhereUniqueInput }
  ) => PledgePromise;
  upsertPledge: (
    args: {
      where: PledgeWhereUniqueInput;
      create: PledgeCreateInput;
      update: PledgeUpdateInput;
    }
  ) => PledgePromise;
  deletePledge: (where: PledgeWhereUniqueInput) => PledgePromise;
  deleteManyPledges: (where?: PledgeWhereInput) => BatchPayloadPromise;
  createPrayer: (data: PrayerCreateInput) => PrayerPromise;
  updatePrayer: (
    args: { data: PrayerUpdateInput; where: PrayerWhereUniqueInput }
  ) => PrayerPromise;
  upsertPrayer: (
    args: {
      where: PrayerWhereUniqueInput;
      create: PrayerCreateInput;
      update: PrayerUpdateInput;
    }
  ) => PrayerPromise;
  deletePrayer: (where: PrayerWhereUniqueInput) => PrayerPromise;
  deleteManyPrayers: (where?: PrayerWhereInput) => BatchPayloadPromise;
  createPride: (data: PrideCreateInput) => PridePromise;
  updatePride: (
    args: { data: PrideUpdateInput; where: PrideWhereUniqueInput }
  ) => PridePromise;
  updateManyPrides: (
    args: { data: PrideUpdateManyMutationInput; where?: PrideWhereInput }
  ) => BatchPayloadPromise;
  upsertPride: (
    args: {
      where: PrideWhereUniqueInput;
      create: PrideCreateInput;
      update: PrideUpdateInput;
    }
  ) => PridePromise;
  deletePride: (where: PrideWhereUniqueInput) => PridePromise;
  deleteManyPrides: (where?: PrideWhereInput) => BatchPayloadPromise;
  createProcess: (data: ProcessCreateInput) => ProcessPromise;
  updateProcess: (
    args: { data: ProcessUpdateInput; where: ProcessWhereUniqueInput }
  ) => ProcessPromise;
  upsertProcess: (
    args: {
      where: ProcessWhereUniqueInput;
      create: ProcessCreateInput;
      update: ProcessUpdateInput;
    }
  ) => ProcessPromise;
  deleteProcess: (where: ProcessWhereUniqueInput) => ProcessPromise;
  deleteManyProcesses: (where?: ProcessWhereInput) => BatchPayloadPromise;
  createResentment: (data: ResentmentCreateInput) => ResentmentPromise;
  updateResentment: (
    args: { data: ResentmentUpdateInput; where: ResentmentWhereUniqueInput }
  ) => ResentmentPromise;
  upsertResentment: (
    args: {
      where: ResentmentWhereUniqueInput;
      create: ResentmentCreateInput;
      update: ResentmentUpdateInput;
    }
  ) => ResentmentPromise;
  deleteResentment: (where: ResentmentWhereUniqueInput) => ResentmentPromise;
  deleteManyResentments: (where?: ResentmentWhereInput) => BatchPayloadPromise;
  createSacrifice: (data: SacrificeCreateInput) => SacrificePromise;
  updateSacrifice: (
    args: { data: SacrificeUpdateInput; where: SacrificeWhereUniqueInput }
  ) => SacrificePromise;
  upsertSacrifice: (
    args: {
      where: SacrificeWhereUniqueInput;
      create: SacrificeCreateInput;
      update: SacrificeUpdateInput;
    }
  ) => SacrificePromise;
  deleteSacrifice: (where: SacrificeWhereUniqueInput) => SacrificePromise;
  deleteManySacrifices: (where?: SacrificeWhereInput) => BatchPayloadPromise;
  createSalvation: (data: SalvationCreateInput) => SalvationPromise;
  updateSalvation: (
    args: { data: SalvationUpdateInput; where: SalvationWhereUniqueInput }
  ) => SalvationPromise;
  updateManySalvations: (
    args: {
      data: SalvationUpdateManyMutationInput;
      where?: SalvationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSalvation: (
    args: {
      where: SalvationWhereUniqueInput;
      create: SalvationCreateInput;
      update: SalvationUpdateInput;
    }
  ) => SalvationPromise;
  deleteSalvation: (where: SalvationWhereUniqueInput) => SalvationPromise;
  deleteManySalvations: (where?: SalvationWhereInput) => BatchPayloadPromise;
  createSarcasm: (data: SarcasmCreateInput) => SarcasmPromise;
  updateSarcasm: (
    args: { data: SarcasmUpdateInput; where: SarcasmWhereUniqueInput }
  ) => SarcasmPromise;
  upsertSarcasm: (
    args: {
      where: SarcasmWhereUniqueInput;
      create: SarcasmCreateInput;
      update: SarcasmUpdateInput;
    }
  ) => SarcasmPromise;
  deleteSarcasm: (where: SarcasmWhereUniqueInput) => SarcasmPromise;
  deleteManySarcasms: (where?: SarcasmWhereInput) => BatchPayloadPromise;
  createScar: (data: ScarCreateInput) => ScarPromise;
  updateScar: (
    args: { data: ScarUpdateInput; where: ScarWhereUniqueInput }
  ) => ScarPromise;
  upsertScar: (
    args: {
      where: ScarWhereUniqueInput;
      create: ScarCreateInput;
      update: ScarUpdateInput;
    }
  ) => ScarPromise;
  deleteScar: (where: ScarWhereUniqueInput) => ScarPromise;
  deleteManyScars: (where?: ScarWhereInput) => BatchPayloadPromise;
  createSeeker: (data: SeekerCreateInput) => SeekerPromise;
  updateSeeker: (
    args: { data: SeekerUpdateInput; where: SeekerWhereUniqueInput }
  ) => SeekerPromise;
  upsertSeeker: (
    args: {
      where: SeekerWhereUniqueInput;
      create: SeekerCreateInput;
      update: SeekerUpdateInput;
    }
  ) => SeekerPromise;
  deleteSeeker: (where: SeekerWhereUniqueInput) => SeekerPromise;
  deleteManySeekers: (where?: SeekerWhereInput) => BatchPayloadPromise;
  createSelf: (data: SelfCreateInput) => SelfPromise;
  updateSelf: (
    args: { data: SelfUpdateInput; where: SelfWhereUniqueInput }
  ) => SelfPromise;
  upsertSelf: (
    args: {
      where: SelfWhereUniqueInput;
      create: SelfCreateInput;
      update: SelfUpdateInput;
    }
  ) => SelfPromise;
  deleteSelf: (where: SelfWhereUniqueInput) => SelfPromise;
  deleteManySelves: (where?: SelfWhereInput) => BatchPayloadPromise;
  createSelfPity: (data: SelfPityCreateInput) => SelfPityPromise;
  updateSelfPity: (
    args: { data: SelfPityUpdateInput; where: SelfPityWhereUniqueInput }
  ) => SelfPityPromise;
  updateManySelfPities: (
    args: { data: SelfPityUpdateManyMutationInput; where?: SelfPityWhereInput }
  ) => BatchPayloadPromise;
  upsertSelfPity: (
    args: {
      where: SelfPityWhereUniqueInput;
      create: SelfPityCreateInput;
      update: SelfPityUpdateInput;
    }
  ) => SelfPityPromise;
  deleteSelfPity: (where: SelfPityWhereUniqueInput) => SelfPityPromise;
  deleteManySelfPities: (where?: SelfPityWhereInput) => BatchPayloadPromise;
  createService: (data: ServiceCreateInput) => ServicePromise;
  updateService: (
    args: { data: ServiceUpdateInput; where: ServiceWhereUniqueInput }
  ) => ServicePromise;
  upsertService: (
    args: {
      where: ServiceWhereUniqueInput;
      create: ServiceCreateInput;
      update: ServiceUpdateInput;
    }
  ) => ServicePromise;
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise;
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise;
  createShield: (data: ShieldCreateInput) => ShieldPromise;
  updateShield: (
    args: { data: ShieldUpdateInput; where: ShieldWhereUniqueInput }
  ) => ShieldPromise;
  upsertShield: (
    args: {
      where: ShieldWhereUniqueInput;
      create: ShieldCreateInput;
      update: ShieldUpdateInput;
    }
  ) => ShieldPromise;
  deleteShield: (where: ShieldWhereUniqueInput) => ShieldPromise;
  deleteManyShields: (where?: ShieldWhereInput) => BatchPayloadPromise;
  createSilence: (data: SilenceCreateInput) => SilencePromise;
  updateSilence: (
    args: { data: SilenceUpdateInput; where: SilenceWhereUniqueInput }
  ) => SilencePromise;
  upsertSilence: (
    args: {
      where: SilenceWhereUniqueInput;
      create: SilenceCreateInput;
      update: SilenceUpdateInput;
    }
  ) => SilencePromise;
  deleteSilence: (where: SilenceWhereUniqueInput) => SilencePromise;
  deleteManySilences: (where?: SilenceWhereInput) => BatchPayloadPromise;
  createSkin: (data: SkinCreateInput) => SkinPromise;
  updateSkin: (
    args: { data: SkinUpdateInput; where: SkinWhereUniqueInput }
  ) => SkinPromise;
  upsertSkin: (
    args: {
      where: SkinWhereUniqueInput;
      create: SkinCreateInput;
      update: SkinUpdateInput;
    }
  ) => SkinPromise;
  deleteSkin: (where: SkinWhereUniqueInput) => SkinPromise;
  deleteManySkins: (where?: SkinWhereInput) => BatchPayloadPromise;
  createSmith: (data: SmithCreateInput) => SmithPromise;
  updateSmith: (
    args: { data: SmithUpdateInput; where: SmithWhereUniqueInput }
  ) => SmithPromise;
  upsertSmith: (
    args: {
      where: SmithWhereUniqueInput;
      create: SmithCreateInput;
      update: SmithUpdateInput;
    }
  ) => SmithPromise;
  deleteSmith: (where: SmithWhereUniqueInput) => SmithPromise;
  deleteManySmiths: (where?: SmithWhereInput) => BatchPayloadPromise;
  createSoul: (data: SoulCreateInput) => SoulPromise;
  updateSoul: (
    args: { data: SoulUpdateInput; where: SoulWhereUniqueInput }
  ) => SoulPromise;
  upsertSoul: (
    args: {
      where: SoulWhereUniqueInput;
      create: SoulCreateInput;
      update: SoulUpdateInput;
    }
  ) => SoulPromise;
  deleteSoul: (where: SoulWhereUniqueInput) => SoulPromise;
  deleteManySouls: (where?: SoulWhereInput) => BatchPayloadPromise;
  createSternum: (data: SternumCreateInput) => SternumPromise;
  updateSternum: (
    args: { data: SternumUpdateInput; where: SternumWhereUniqueInput }
  ) => SternumPromise;
  upsertSternum: (
    args: {
      where: SternumWhereUniqueInput;
      create: SternumCreateInput;
      update: SternumUpdateInput;
    }
  ) => SternumPromise;
  deleteSternum: (where: SternumWhereUniqueInput) => SternumPromise;
  deleteManySternums: (where?: SternumWhereInput) => BatchPayloadPromise;
  createStigmata: (data: StigmataCreateInput) => StigmataPromise;
  updateStigmata: (
    args: { data: StigmataUpdateInput; where: StigmataWhereUniqueInput }
  ) => StigmataPromise;
  upsertStigmata: (
    args: {
      where: StigmataWhereUniqueInput;
      create: StigmataCreateInput;
      update: StigmataUpdateInput;
    }
  ) => StigmataPromise;
  deleteStigmata: (where: StigmataWhereUniqueInput) => StigmataPromise;
  deleteManyStigmatas: (where?: StigmataWhereInput) => BatchPayloadPromise;
  createStrength: (data: StrengthCreateInput) => StrengthPromise;
  updateStrength: (
    args: { data: StrengthUpdateInput; where: StrengthWhereUniqueInput }
  ) => StrengthPromise;
  upsertStrength: (
    args: {
      where: StrengthWhereUniqueInput;
      create: StrengthCreateInput;
      update: StrengthUpdateInput;
    }
  ) => StrengthPromise;
  deleteStrength: (where: StrengthWhereUniqueInput) => StrengthPromise;
  deleteManyStrengths: (where?: StrengthWhereInput) => BatchPayloadPromise;
  createSuffering: (data: SufferingCreateInput) => SufferingPromise;
  updateSuffering: (
    args: { data: SufferingUpdateInput; where: SufferingWhereUniqueInput }
  ) => SufferingPromise;
  updateManySufferings: (
    args: {
      data: SufferingUpdateManyMutationInput;
      where?: SufferingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSuffering: (
    args: {
      where: SufferingWhereUniqueInput;
      create: SufferingCreateInput;
      update: SufferingUpdateInput;
    }
  ) => SufferingPromise;
  deleteSuffering: (where: SufferingWhereUniqueInput) => SufferingPromise;
  deleteManySufferings: (where?: SufferingWhereInput) => BatchPayloadPromise;
  createSummoner: (data: SummonerCreateInput) => SummonerPromise;
  deleteSummoner: (where: SummonerWhereUniqueInput) => SummonerPromise;
  deleteManySummoners: (where?: SummonerWhereInput) => BatchPayloadPromise;
  createSupport: (data: SupportCreateInput) => SupportPromise;
  updateSupport: (
    args: { data: SupportUpdateInput; where: SupportWhereUniqueInput }
  ) => SupportPromise;
  upsertSupport: (
    args: {
      where: SupportWhereUniqueInput;
      create: SupportCreateInput;
      update: SupportUpdateInput;
    }
  ) => SupportPromise;
  deleteSupport: (where: SupportWhereUniqueInput) => SupportPromise;
  deleteManySupports: (where?: SupportWhereInput) => BatchPayloadPromise;
  createTower: (data: TowerCreateInput) => TowerPromise;
  updateTower: (
    args: { data: TowerUpdateInput; where: TowerWhereUniqueInput }
  ) => TowerPromise;
  upsertTower: (
    args: {
      where: TowerWhereUniqueInput;
      create: TowerCreateInput;
      update: TowerUpdateInput;
    }
  ) => TowerPromise;
  deleteTower: (where: TowerWhereUniqueInput) => TowerPromise;
  deleteManyTowers: (where?: TowerWhereInput) => BatchPayloadPromise;
  createToxicity: (data: ToxicityCreateInput) => ToxicityPromise;
  updateToxicity: (
    args: { data: ToxicityUpdateInput; where: ToxicityWhereUniqueInput }
  ) => ToxicityPromise;
  updateManyToxicities: (
    args: { data: ToxicityUpdateManyMutationInput; where?: ToxicityWhereInput }
  ) => BatchPayloadPromise;
  upsertToxicity: (
    args: {
      where: ToxicityWhereUniqueInput;
      create: ToxicityCreateInput;
      update: ToxicityUpdateInput;
    }
  ) => ToxicityPromise;
  deleteToxicity: (where: ToxicityWhereUniqueInput) => ToxicityPromise;
  deleteManyToxicities: (where?: ToxicityWhereInput) => BatchPayloadPromise;
  createTrauma: (data: TraumaCreateInput) => TraumaPromise;
  updateTrauma: (
    args: { data: TraumaUpdateInput; where: TraumaWhereUniqueInput }
  ) => TraumaPromise;
  updateManyTraumas: (
    args: { data: TraumaUpdateManyMutationInput; where?: TraumaWhereInput }
  ) => BatchPayloadPromise;
  upsertTrauma: (
    args: {
      where: TraumaWhereUniqueInput;
      create: TraumaCreateInput;
      update: TraumaUpdateInput;
    }
  ) => TraumaPromise;
  deleteTrauma: (where: TraumaWhereUniqueInput) => TraumaPromise;
  deleteManyTraumas: (where?: TraumaWhereInput) => BatchPayloadPromise;
  createTremor: (data: TremorCreateInput) => TremorPromise;
  updateTremor: (
    args: { data: TremorUpdateInput; where: TremorWhereUniqueInput }
  ) => TremorPromise;
  upsertTremor: (
    args: {
      where: TremorWhereUniqueInput;
      create: TremorCreateInput;
      update: TremorUpdateInput;
    }
  ) => TremorPromise;
  deleteTremor: (where: TremorWhereUniqueInput) => TremorPromise;
  deleteManyTremors: (where?: TremorWhereInput) => BatchPayloadPromise;
  createVictim: (data: VictimCreateInput) => VictimPromise;
  updateVictim: (
    args: { data: VictimUpdateInput; where: VictimWhereUniqueInput }
  ) => VictimPromise;
  upsertVictim: (
    args: {
      where: VictimWhereUniqueInput;
      create: VictimCreateInput;
      update: VictimUpdateInput;
    }
  ) => VictimPromise;
  deleteVictim: (where: VictimWhereUniqueInput) => VictimPromise;
  deleteManyVictims: (where?: VictimWhereInput) => BatchPayloadPromise;
  createVirtue: (data: VirtueCreateInput) => VirtuePromise;
  updateVirtue: (
    args: { data: VirtueUpdateInput; where: VirtueWhereUniqueInput }
  ) => VirtuePromise;
  upsertVirtue: (
    args: {
      where: VirtueWhereUniqueInput;
      create: VirtueCreateInput;
      update: VirtueUpdateInput;
    }
  ) => VirtuePromise;
  deleteVirtue: (where: VirtueWhereUniqueInput) => VirtuePromise;
  deleteManyVirtues: (where?: VirtueWhereInput) => BatchPayloadPromise;
  createVolunteer: (data: VolunteerCreateInput) => VolunteerPromise;
  updateVolunteer: (
    args: { data: VolunteerUpdateInput; where: VolunteerWhereUniqueInput }
  ) => VolunteerPromise;
  upsertVolunteer: (
    args: {
      where: VolunteerWhereUniqueInput;
      create: VolunteerCreateInput;
      update: VolunteerUpdateInput;
    }
  ) => VolunteerPromise;
  deleteVolunteer: (where: VolunteerWhereUniqueInput) => VolunteerPromise;
  deleteManyVolunteers: (where?: VolunteerWhereInput) => BatchPayloadPromise;
  createVulnerability: (data: VulnerabilityCreateInput) => VulnerabilityPromise;
  updateVulnerability: (
    args: {
      data: VulnerabilityUpdateInput;
      where: VulnerabilityWhereUniqueInput;
    }
  ) => VulnerabilityPromise;
  updateManyVulnerabilities: (
    args: {
      data: VulnerabilityUpdateManyMutationInput;
      where?: VulnerabilityWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertVulnerability: (
    args: {
      where: VulnerabilityWhereUniqueInput;
      create: VulnerabilityCreateInput;
      update: VulnerabilityUpdateInput;
    }
  ) => VulnerabilityPromise;
  deleteVulnerability: (
    where: VulnerabilityWhereUniqueInput
  ) => VulnerabilityPromise;
  deleteManyVulnerabilities: (
    where?: VulnerabilityWhereInput
  ) => BatchPayloadPromise;
  createWall: (data: WallCreateInput) => WallPromise;
  updateWall: (
    args: { data: WallUpdateInput; where: WallWhereUniqueInput }
  ) => WallPromise;
  upsertWall: (
    args: {
      where: WallWhereUniqueInput;
      create: WallCreateInput;
      update: WallUpdateInput;
    }
  ) => WallPromise;
  deleteWall: (where: WallWhereUniqueInput) => WallPromise;
  deleteManyWalls: (where?: WallWhereInput) => BatchPayloadPromise;
  createWish: (data: WishCreateInput) => WishPromise;
  updateWish: (
    args: { data: WishUpdateInput; where: WishWhereUniqueInput }
  ) => WishPromise;
  upsertWish: (
    args: {
      where: WishWhereUniqueInput;
      create: WishCreateInput;
      update: WishUpdateInput;
    }
  ) => WishPromise;
  deleteWish: (where: WishWhereUniqueInput) => WishPromise;
  deleteManyWishes: (where?: WishWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  acceptance: (
    where?: AcceptanceSubscriptionWhereInput
  ) => AcceptanceSubscriptionPayloadSubscription;
  act: (
    where?: ActSubscriptionWhereInput
  ) => ActSubscriptionPayloadSubscription;
  affliction: (
    where?: AfflictionSubscriptionWhereInput
  ) => AfflictionSubscriptionPayloadSubscription;
  anger: (
    where?: AngerSubscriptionWhereInput
  ) => AngerSubscriptionPayloadSubscription;
  armor: (
    where?: ArmorSubscriptionWhereInput
  ) => ArmorSubscriptionPayloadSubscription;
  body: (
    where?: BodySubscriptionWhereInput
  ) => BodySubscriptionPayloadSubscription;
  boundary: (
    where?: BoundarySubscriptionWhereInput
  ) => BoundarySubscriptionPayloadSubscription;
  brain: (
    where?: BrainSubscriptionWhereInput
  ) => BrainSubscriptionPayloadSubscription;
  campaign: (
    where?: CampaignSubscriptionWhereInput
  ) => CampaignSubscriptionPayloadSubscription;
  characters: (
    where?: CharactersSubscriptionWhereInput
  ) => CharactersSubscriptionPayloadSubscription;
  compassion: (
    where?: CompassionSubscriptionWhereInput
  ) => CompassionSubscriptionPayloadSubscription;
  confusion: (
    where?: ConfusionSubscriptionWhereInput
  ) => ConfusionSubscriptionPayloadSubscription;
  congregant: (
    where?: CongregantSubscriptionWhereInput
  ) => CongregantSubscriptionPayloadSubscription;
  construct: (
    where?: ConstructSubscriptionWhereInput
  ) => ConstructSubscriptionPayloadSubscription;
  courage: (
    where?: CourageSubscriptionWhereInput
  ) => CourageSubscriptionPayloadSubscription;
  cross: (
    where?: CrossSubscriptionWhereInput
  ) => CrossSubscriptionPayloadSubscription;
  crown: (
    where?: CrownSubscriptionWhereInput
  ) => CrownSubscriptionPayloadSubscription;
  crusade: (
    where?: CrusadeSubscriptionWhereInput
  ) => CrusadeSubscriptionPayloadSubscription;
  defect: (
    where?: DefectSubscriptionWhereInput
  ) => DefectSubscriptionPayloadSubscription;
  delirium: (
    where?: DeliriumSubscriptionWhereInput
  ) => DeliriumSubscriptionPayloadSubscription;
  denial: (
    where?: DenialSubscriptionWhereInput
  ) => DenialSubscriptionPayloadSubscription;
  discontent: (
    where?: DiscontentSubscriptionWhereInput
  ) => DiscontentSubscriptionPayloadSubscription;
  dream: (
    where?: DreamSubscriptionWhereInput
  ) => DreamSubscriptionPayloadSubscription;
  experience: (
    where?: ExperienceSubscriptionWhereInput
  ) => ExperienceSubscriptionPayloadSubscription;
  face: (
    where?: FaceSubscriptionWhereInput
  ) => FaceSubscriptionPayloadSubscription;
  fear: (
    where?: FearSubscriptionWhereInput
  ) => FearSubscriptionPayloadSubscription;
  feeling: (
    where?: FeelingSubscriptionWhereInput
  ) => FeelingSubscriptionPayloadSubscription;
  fun: (
    where?: FunSubscriptionWhereInput
  ) => FunSubscriptionPayloadSubscription;
  gash: (
    where?: GashSubscriptionWhereInput
  ) => GashSubscriptionPayloadSubscription;
  gate: (
    where?: GateSubscriptionWhereInput
  ) => GateSubscriptionPayloadSubscription;
  genie: (
    where?: GenieSubscriptionWhereInput
  ) => GenieSubscriptionPayloadSubscription;
  gratitude: (
    where?: GratitudeSubscriptionWhereInput
  ) => GratitudeSubscriptionPayloadSubscription;
  guardian: (
    where?: GuardianSubscriptionWhereInput
  ) => GuardianSubscriptionPayloadSubscription;
  gut: (
    where?: GutSubscriptionWhereInput
  ) => GutSubscriptionPayloadSubscription;
  has: (
    where?: HasSubscriptionWhereInput
  ) => HasSubscriptionPayloadSubscription;
  heart: (
    where?: HeartSubscriptionWhereInput
  ) => HeartSubscriptionPayloadSubscription;
  higherPower: (
    where?: HigherPowerSubscriptionWhereInput
  ) => HigherPowerSubscriptionPayloadSubscription;
  honor: (
    where?: HonorSubscriptionWhereInput
  ) => HonorSubscriptionPayloadSubscription;
  hope: (
    where?: HopeSubscriptionWhereInput
  ) => HopeSubscriptionPayloadSubscription;
  impatience: (
    where?: ImpatienceSubscriptionWhereInput
  ) => ImpatienceSubscriptionPayloadSubscription;
  infection: (
    where?: InfectionSubscriptionWhereInput
  ) => InfectionSubscriptionPayloadSubscription;
  inventory: (
    where?: InventorySubscriptionWhereInput
  ) => InventorySubscriptionPayloadSubscription;
  irritability: (
    where?: IrritabilitySubscriptionWhereInput
  ) => IrritabilitySubscriptionPayloadSubscription;
  joy: (
    where?: JoySubscriptionWhereInput
  ) => JoySubscriptionPayloadSubscription;
  love: (
    where?: LoveSubscriptionWhereInput
  ) => LoveSubscriptionPayloadSubscription;
  loyalty: (
    where?: LoyaltySubscriptionWhereInput
  ) => LoyaltySubscriptionPayloadSubscription;
  martyr: (
    where?: MartyrSubscriptionWhereInput
  ) => MartyrSubscriptionPayloadSubscription;
  mind: (
    where?: MindSubscriptionWhereInput
  ) => MindSubscriptionPayloadSubscription;
  mouth: (
    where?: MouthSubscriptionWhereInput
  ) => MouthSubscriptionPayloadSubscription;
  nail: (
    where?: NailSubscriptionWhereInput
  ) => NailSubscriptionPayloadSubscription;
  nightmare: (
    where?: NightmareSubscriptionWhereInput
  ) => NightmareSubscriptionPayloadSubscription;
  oath: (
    where?: OathSubscriptionWhereInput
  ) => OathSubscriptionPayloadSubscription;
  obsession: (
    where?: ObsessionSubscriptionWhereInput
  ) => ObsessionSubscriptionPayloadSubscription;
  paladin: (
    where?: PaladinSubscriptionWhereInput
  ) => PaladinSubscriptionPayloadSubscription;
  path: (
    where?: PathSubscriptionWhereInput
  ) => PathSubscriptionPayloadSubscription;
  pledge: (
    where?: PledgeSubscriptionWhereInput
  ) => PledgeSubscriptionPayloadSubscription;
  prayer: (
    where?: PrayerSubscriptionWhereInput
  ) => PrayerSubscriptionPayloadSubscription;
  pride: (
    where?: PrideSubscriptionWhereInput
  ) => PrideSubscriptionPayloadSubscription;
  process: (
    where?: ProcessSubscriptionWhereInput
  ) => ProcessSubscriptionPayloadSubscription;
  resentment: (
    where?: ResentmentSubscriptionWhereInput
  ) => ResentmentSubscriptionPayloadSubscription;
  sacrifice: (
    where?: SacrificeSubscriptionWhereInput
  ) => SacrificeSubscriptionPayloadSubscription;
  salvation: (
    where?: SalvationSubscriptionWhereInput
  ) => SalvationSubscriptionPayloadSubscription;
  sarcasm: (
    where?: SarcasmSubscriptionWhereInput
  ) => SarcasmSubscriptionPayloadSubscription;
  scar: (
    where?: ScarSubscriptionWhereInput
  ) => ScarSubscriptionPayloadSubscription;
  seeker: (
    where?: SeekerSubscriptionWhereInput
  ) => SeekerSubscriptionPayloadSubscription;
  self: (
    where?: SelfSubscriptionWhereInput
  ) => SelfSubscriptionPayloadSubscription;
  selfPity: (
    where?: SelfPitySubscriptionWhereInput
  ) => SelfPitySubscriptionPayloadSubscription;
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription;
  shield: (
    where?: ShieldSubscriptionWhereInput
  ) => ShieldSubscriptionPayloadSubscription;
  silence: (
    where?: SilenceSubscriptionWhereInput
  ) => SilenceSubscriptionPayloadSubscription;
  skin: (
    where?: SkinSubscriptionWhereInput
  ) => SkinSubscriptionPayloadSubscription;
  smith: (
    where?: SmithSubscriptionWhereInput
  ) => SmithSubscriptionPayloadSubscription;
  soul: (
    where?: SoulSubscriptionWhereInput
  ) => SoulSubscriptionPayloadSubscription;
  sternum: (
    where?: SternumSubscriptionWhereInput
  ) => SternumSubscriptionPayloadSubscription;
  stigmata: (
    where?: StigmataSubscriptionWhereInput
  ) => StigmataSubscriptionPayloadSubscription;
  strength: (
    where?: StrengthSubscriptionWhereInput
  ) => StrengthSubscriptionPayloadSubscription;
  suffering: (
    where?: SufferingSubscriptionWhereInput
  ) => SufferingSubscriptionPayloadSubscription;
  summoner: (
    where?: SummonerSubscriptionWhereInput
  ) => SummonerSubscriptionPayloadSubscription;
  support: (
    where?: SupportSubscriptionWhereInput
  ) => SupportSubscriptionPayloadSubscription;
  tower: (
    where?: TowerSubscriptionWhereInput
  ) => TowerSubscriptionPayloadSubscription;
  toxicity: (
    where?: ToxicitySubscriptionWhereInput
  ) => ToxicitySubscriptionPayloadSubscription;
  trauma: (
    where?: TraumaSubscriptionWhereInput
  ) => TraumaSubscriptionPayloadSubscription;
  tremor: (
    where?: TremorSubscriptionWhereInput
  ) => TremorSubscriptionPayloadSubscription;
  victim: (
    where?: VictimSubscriptionWhereInput
  ) => VictimSubscriptionPayloadSubscription;
  virtue: (
    where?: VirtueSubscriptionWhereInput
  ) => VirtueSubscriptionPayloadSubscription;
  volunteer: (
    where?: VolunteerSubscriptionWhereInput
  ) => VolunteerSubscriptionPayloadSubscription;
  vulnerability: (
    where?: VulnerabilitySubscriptionWhereInput
  ) => VulnerabilitySubscriptionPayloadSubscription;
  wall: (
    where?: WallSubscriptionWhereInput
  ) => WallSubscriptionPayloadSubscription;
  wish: (
    where?: WishSubscriptionWhereInput
  ) => WishSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type GashOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SelfPityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type ConfusionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VictimOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DenialOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AcceptanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type InfectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SkinOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SarcasmOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SeekerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SilenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PrayerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TremorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaladinOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ShieldOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MartyrOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NightmareOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CourageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type VirtueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompassionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type CrusadeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ResentmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DeliriumOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HopeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PledgeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SacrificeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type OathOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HasOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "defect_ASC"
  | "defect_DESC"
  | "discontent_ASC"
  | "discontent_DESC"
  | "resentment_ASC"
  | "resentment_DESC"
  | "obsession_ASC"
  | "obsession_DESC"
  | "experience_ASC"
  | "experience_DESC"
  | "strength_ASC"
  | "strength_DESC"
  | "hope_ASC"
  | "hope_DESC"
  | "acceptance_ASC"
  | "acceptance_DESC"
  | "anger_ASC"
  | "anger_DESC"
  | "armor_ASC"
  | "armor_DESC"
  | "boundary_ASC"
  | "boundary_DESC"
  | "compassion_ASC"
  | "compassion_DESC"
  | "courage_ASC"
  | "courage_DESC"
  | "fear_ASC"
  | "fear_DESC"
  | "fun_ASC"
  | "fun_DESC"
  | "gratitude_ASC"
  | "gratitude_DESC"
  | "irritability_ASC"
  | "irritability_DESC"
  | "impatience_ASC"
  | "impatience_DESC"
  | "joy_ASC"
  | "joy_DESC"
  | "pride_ASC"
  | "pride_DESC"
  | "salvaltion_ASC"
  | "salvaltion_DESC"
  | "selfPity_ASC"
  | "selfPity_DESC"
  | "suffering_ASC"
  | "suffering_DESC"
  | "toxicity_ASC"
  | "toxicity_DESC"
  | "trauma_ASC"
  | "trauma_DESC"
  | "vulnerability_ASC"
  | "vulnerability_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AfflictionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GuardianOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CrossOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FunOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolveAt_ASC"
  | "resolveAt_DESC";

export type CrownOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExperienceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SufferingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type DiscontentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type NailOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScarOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StigmataOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TraumaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type WallOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ToxicityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type AngerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type CharactersOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TowerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SummonerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SelfOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ConstructOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PathOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SalvationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "character_ASC"
  | "character_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type LoveOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DreamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StrengthOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type WishOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SupportOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ArmorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type JoyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolveAt_ASC"
  | "resolveAt_DESC";

export type CampaignOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GenieOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HonorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type GratitudeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type LoyaltyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type IrritabilityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolveAt_ASC"
  | "resolveAt_DESC";

export type BoundaryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type CongregantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type BodyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SmithOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GutOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MindOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SternumOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ObsessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HeartOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ActOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VulnerabilityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type ImpatienceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolveAt_ASC"
  | "resolveAt_DESC";

export type BrainOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VolunteerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SoulOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InventoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FaceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PrideOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type MouthOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FearOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type HigherPowerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProcessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DefectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FeelingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export interface FunUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface ActScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ActScalarWhereInput[] | ActScalarWhereInput;
  OR?: ActScalarWhereInput[] | ActScalarWhereInput;
  NOT?: ActScalarWhereInput[] | ActScalarWhereInput;
}

export type SeekerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type AcceptanceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface WishCreateOneInput {
  create?: WishCreateInput;
  connect?: WishWhereUniqueInput;
}

export interface MartyrSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MartyrWhereInput;
  AND?: MartyrSubscriptionWhereInput[] | MartyrSubscriptionWhereInput;
  OR?: MartyrSubscriptionWhereInput[] | MartyrSubscriptionWhereInput;
  NOT?: MartyrSubscriptionWhereInput[] | MartyrSubscriptionWhereInput;
}

export type ScarWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface MindSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MindWhereInput;
  AND?: MindSubscriptionWhereInput[] | MindSubscriptionWhereInput;
  OR?: MindSubscriptionWhereInput[] | MindSubscriptionWhereInput;
  NOT?: MindSubscriptionWhereInput[] | MindSubscriptionWhereInput;
}

export interface DefectCreateOneInput {
  create?: DefectCreateInput;
  connect?: DefectWhereUniqueInput;
}

export interface MouthWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  anger_every?: AngerWhereInput;
  anger_some?: AngerWhereInput;
  anger_none?: AngerWhereInput;
  fear_every?: FearWhereInput;
  fear_some?: FearWhereInput;
  fear_none?: FearWhereInput;
  pride_every?: PrideWhereInput;
  pride_some?: PrideWhereInput;
  pride_none?: PrideWhereInput;
  selfPity_every?: SelfPityWhereInput;
  selfPity_some?: SelfPityWhereInput;
  selfPity_none?: SelfPityWhereInput;
  AND?: MouthWhereInput[] | MouthWhereInput;
  OR?: MouthWhereInput[] | MouthWhereInput;
  NOT?: MouthWhereInput[] | MouthWhereInput;
}

export type SarcasmWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LoveSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LoveWhereInput;
  AND?: LoveSubscriptionWhereInput[] | LoveSubscriptionWhereInput;
  OR?: LoveSubscriptionWhereInput[] | LoveSubscriptionWhereInput;
  NOT?: LoveSubscriptionWhereInput[] | LoveSubscriptionWhereInput;
}

export interface ResentmentCreateInput {
  id?: ID_Input;
  anger?: AngerCreateManyInput;
  selfPity?: SelfPityCreateManyInput;
  fear?: FearCreateManyInput;
  pride?: PrideCreateManyInput;
}

export interface VulnerabilityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: VulnerabilityWhereInput[] | VulnerabilityWhereInput;
  OR?: VulnerabilityWhereInput[] | VulnerabilityWhereInput;
  NOT?: VulnerabilityWhereInput[] | VulnerabilityWhereInput;
}

export type SalvationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface JoySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: JoyWhereInput;
  AND?: JoySubscriptionWhereInput[] | JoySubscriptionWhereInput;
  OR?: JoySubscriptionWhereInput[] | JoySubscriptionWhereInput;
  NOT?: JoySubscriptionWhereInput[] | JoySubscriptionWhereInput;
}

export type ShieldWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface IrritabilitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: IrritabilityWhereInput;
  AND?:
    | IrritabilitySubscriptionWhereInput[]
    | IrritabilitySubscriptionWhereInput;
  OR?:
    | IrritabilitySubscriptionWhereInput[]
    | IrritabilitySubscriptionWhereInput;
  NOT?:
    | IrritabilitySubscriptionWhereInput[]
    | IrritabilitySubscriptionWhereInput;
}

export interface PrayerCreateOneInput {
  create?: PrayerCreateInput;
  connect?: PrayerWhereUniqueInput;
}

export interface PrideWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: PrideWhereInput[] | PrideWhereInput;
  OR?: PrideWhereInput[] | PrideWhereInput;
  NOT?: PrideWhereInput[] | PrideWhereInput;
}

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SternumWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  anger_every?: AngerWhereInput;
  anger_some?: AngerWhereInput;
  anger_none?: AngerWhereInput;
  fear_every?: FearWhereInput;
  fear_some?: FearWhereInput;
  fear_none?: FearWhereInput;
  pride_every?: PrideWhereInput;
  pride_some?: PrideWhereInput;
  pride_none?: PrideWhereInput;
  selfPity_every?: SelfPityWhereInput;
  selfPity_some?: SelfPityWhereInput;
  selfPity_none?: SelfPityWhereInput;
  AND?: SternumWhereInput[] | SternumWhereInput;
  OR?: SternumWhereInput[] | SternumWhereInput;
  NOT?: SternumWhereInput[] | SternumWhereInput;
}

export interface ProcessCreateInput {
  id?: ID_Input;
  act?: ActCreateOneInput;
  affliction?: AfflictionCreateOneInput;
  body?: BodyCreateOneInput;
  construct?: ConstructCreateOneInput;
  oath?: OathCreateOneInput;
  shield?: ShieldCreateOneInput;
  stigmata?: StigmataCreateOneInput;
  virtue?: VirtueCreateOneInput;
  wish?: WishCreateOneInput;
}

export interface InfectionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InfectionWhereInput;
  AND?: InfectionSubscriptionWhereInput[] | InfectionSubscriptionWhereInput;
  OR?: InfectionSubscriptionWhereInput[] | InfectionSubscriptionWhereInput;
  NOT?: InfectionSubscriptionWhereInput[] | InfectionSubscriptionWhereInput;
}

export interface DenialUpdateInput {
  armor?: ArmorUpdateManyInput;
}

export interface BrainWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  anger_every?: AngerWhereInput;
  anger_some?: AngerWhereInput;
  anger_none?: AngerWhereInput;
  fear_every?: FearWhereInput;
  fear_some?: FearWhereInput;
  fear_none?: FearWhereInput;
  pride_every?: PrideWhereInput;
  pride_some?: PrideWhereInput;
  pride_none?: PrideWhereInput;
  selfPity_every?: SelfPityWhereInput;
  selfPity_some?: SelfPityWhereInput;
  selfPity_none?: SelfPityWhereInput;
  AND?: BrainWhereInput[] | BrainWhereInput;
  OR?: BrainWhereInput[] | BrainWhereInput;
  NOT?: BrainWhereInput[] | BrainWhereInput;
}

export interface DeliriumUpdateInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface BodyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  brain_every?: BrainWhereInput;
  brain_some?: BrainWhereInput;
  brain_none?: BrainWhereInput;
  face_every?: FaceWhereInput;
  face_some?: FaceWhereInput;
  face_none?: FaceWhereInput;
  mouth_every?: MouthWhereInput;
  mouth_some?: MouthWhereInput;
  mouth_none?: MouthWhereInput;
  soul_every?: SoulWhereInput;
  soul_some?: SoulWhereInput;
  soul_none?: SoulWhereInput;
  heart_every?: HeartWhereInput;
  heart_some?: HeartWhereInput;
  heart_none?: HeartWhereInput;
  sternum_every?: SternumWhereInput;
  sternum_some?: SternumWhereInput;
  sternum_none?: SternumWhereInput;
  gut_every?: GutWhereInput;
  gut_some?: GutWhereInput;
  gut_none?: GutWhereInput;
  AND?: BodyWhereInput[] | BodyWhereInput;
  OR?: BodyWhereInput[] | BodyWhereInput;
  NOT?: BodyWhereInput[] | BodyWhereInput;
}

export interface DefectUpdateInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
  suffering?: SufferingUpdateManyInput;
}

export interface HopeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HopeWhereInput;
  AND?: HopeSubscriptionWhereInput[] | HopeSubscriptionWhereInput;
  OR?: HopeSubscriptionWhereInput[] | HopeSubscriptionWhereInput;
  NOT?: HopeSubscriptionWhereInput[] | HopeSubscriptionWhereInput;
}

export type VulnerabilityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HigherPowerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HigherPowerWhereInput;
  AND?: HigherPowerSubscriptionWhereInput[] | HigherPowerSubscriptionWhereInput;
  OR?: HigherPowerSubscriptionWhereInput[] | HigherPowerSubscriptionWhereInput;
  NOT?: HigherPowerSubscriptionWhereInput[] | HigherPowerSubscriptionWhereInput;
}

export interface DefectCreateInput {
  id?: ID_Input;
  trauma?: TraumaCreateManyInput;
  toxicity?: ToxicityCreateManyInput;
  suffering?: SufferingCreateManyInput;
}

export interface HeartSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HeartWhereInput;
  AND?: HeartSubscriptionWhereInput[] | HeartSubscriptionWhereInput;
  OR?: HeartSubscriptionWhereInput[] | HeartSubscriptionWhereInput;
  NOT?: HeartSubscriptionWhereInput[] | HeartSubscriptionWhereInput;
}

export interface CrusadeUpdateInput {
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
}

export type BodyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CrownUpdateInput {
  suffering?: SufferingUpdateManyInput;
}

export interface GutSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GutWhereInput;
  AND?: GutSubscriptionWhereInput[] | GutSubscriptionWhereInput;
  OR?: GutSubscriptionWhereInput[] | GutSubscriptionWhereInput;
  NOT?: GutSubscriptionWhereInput[] | GutSubscriptionWhereInput;
}

export type WallWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type BrainWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CrossUpdateInput {
  suffering?: SufferingUpdateManyInput;
}

export interface GenieSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GenieWhereInput;
  AND?: GenieSubscriptionWhereInput[] | GenieSubscriptionWhereInput;
  OR?: GenieSubscriptionWhereInput[] | GenieSubscriptionWhereInput;
  NOT?: GenieSubscriptionWhereInput[] | GenieSubscriptionWhereInput;
}

export interface CourageUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type CampaignWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CourageUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface LoyaltyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: LoyaltyWhereInput[] | LoyaltyWhereInput;
  OR?: LoyaltyWhereInput[] | LoyaltyWhereInput;
  NOT?: LoyaltyWhereInput[] | LoyaltyWhereInput;
}

export type WishWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FunSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FunWhereInput;
  AND?: FunSubscriptionWhereInput[] | FunSubscriptionWhereInput;
  OR?: FunSubscriptionWhereInput[] | FunSubscriptionWhereInput;
  NOT?: FunSubscriptionWhereInput[] | FunSubscriptionWhereInput;
}

export interface ConstructUpdateInput {
  gate?: GateUpdateManyInput;
  tower?: TowerUpdateManyInput;
  wall?: WallUpdateManyInput;
}

export interface ObsessionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ObsessionWhereInput;
  AND?: ObsessionSubscriptionWhereInput[] | ObsessionSubscriptionWhereInput;
  OR?: ObsessionSubscriptionWhereInput[] | ObsessionSubscriptionWhereInput;
  NOT?: ObsessionSubscriptionWhereInput[] | ObsessionSubscriptionWhereInput;
}

export interface ConfusionUpdateInput {
  armor?: ArmorUpdateManyInput;
}

export interface CampaignWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  loyalty_every?: LoyaltyWhereInput;
  loyalty_some?: LoyaltyWhereInput;
  loyalty_none?: LoyaltyWhereInput;
  honor_every?: HonorWhereInput;
  honor_some?: HonorWhereInput;
  honor_none?: HonorWhereInput;
  AND?: CampaignWhereInput[] | CampaignWhereInput;
  OR?: CampaignWhereInput[] | CampaignWhereInput;
  NOT?: CampaignWhereInput[] | CampaignWhereInput;
}

export interface CompassionUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface FearSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FearWhereInput;
  AND?: FearSubscriptionWhereInput[] | FearSubscriptionWhereInput;
  OR?: FearSubscriptionWhereInput[] | FearSubscriptionWhereInput;
  NOT?: FearSubscriptionWhereInput[] | FearSubscriptionWhereInput;
}

export interface ExperienceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExperienceWhereInput;
  AND?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  OR?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  NOT?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
}

export interface DreamSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DreamWhereInput;
  AND?: DreamSubscriptionWhereInput[] | DreamSubscriptionWhereInput;
  OR?: DreamSubscriptionWhereInput[] | DreamSubscriptionWhereInput;
  NOT?: DreamSubscriptionWhereInput[] | DreamSubscriptionWhereInput;
}

export interface AcceptanceCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface DenialSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DenialWhereInput;
  AND?: DenialSubscriptionWhereInput[] | DenialSubscriptionWhereInput;
  OR?: DenialSubscriptionWhereInput[] | DenialSubscriptionWhereInput;
  NOT?: DenialSubscriptionWhereInput[] | DenialSubscriptionWhereInput;
}

export interface AcceptanceUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface DreamWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  salvation_every?: SalvationWhereInput;
  salvation_some?: SalvationWhereInput;
  salvation_none?: SalvationWhereInput;
  AND?: DreamWhereInput[] | DreamWhereInput;
  OR?: DreamWhereInput[] | DreamWhereInput;
  NOT?: DreamWhereInput[] | DreamWhereInput;
}

export interface AcceptanceUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ArmorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: ArmorWhereInput[] | ArmorWhereInput;
  OR?: ArmorWhereInput[] | ArmorWhereInput;
  NOT?: ArmorWhereInput[] | ArmorWhereInput;
}

export interface CompassionUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface PathSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PathWhereInput;
  AND?: PathSubscriptionWhereInput[] | PathSubscriptionWhereInput;
  OR?: PathSubscriptionWhereInput[] | PathSubscriptionWhereInput;
  NOT?: PathSubscriptionWhereInput[] | PathSubscriptionWhereInput;
}

export interface VolunteerUpsertNestedInput {
  update: VolunteerUpdateDataInput;
  create: VolunteerCreateInput;
}

export type ArmorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ActCreateInput {
  id?: ID_Input;
  service?: ServiceCreateManyInput;
  support?: SupportCreateManyInput;
  sacrifice?: SacrificeCreateManyInput;
}

export interface CrownSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CrownWhereInput;
  AND?: CrownSubscriptionWhereInput[] | CrownSubscriptionWhereInput;
  OR?: CrownSubscriptionWhereInput[] | CrownSubscriptionWhereInput;
  NOT?: CrownSubscriptionWhereInput[] | CrownSubscriptionWhereInput;
}

export interface ServiceCreateManyInput {
  create?: ServiceCreateInput[] | ServiceCreateInput;
  connect?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput;
}

export interface GateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  boundary_every?: BoundaryWhereInput;
  boundary_some?: BoundaryWhereInput;
  boundary_none?: BoundaryWhereInput;
  AND?: GateWhereInput[] | GateWhereInput;
  OR?: GateWhereInput[] | GateWhereInput;
  NOT?: GateWhereInput[] | GateWhereInput;
}

export interface ServiceCreateInput {
  id?: ID_Input;
  courage?: CourageCreateManyInput;
  compassion?: CompassionCreateManyInput;
}

export interface WallWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  boundary_every?: BoundaryWhereInput;
  boundary_some?: BoundaryWhereInput;
  boundary_none?: BoundaryWhereInput;
  AND?: WallWhereInput[] | WallWhereInput;
  OR?: WallWhereInput[] | WallWhereInput;
  NOT?: WallWhereInput[] | WallWhereInput;
}

export interface CourageCreateManyInput {
  create?: CourageCreateInput[] | CourageCreateInput;
  connect?: CourageWhereUniqueInput[] | CourageWhereUniqueInput;
}

export interface CrossSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CrossWhereInput;
  AND?: CrossSubscriptionWhereInput[] | CrossSubscriptionWhereInput;
  OR?: CrossSubscriptionWhereInput[] | CrossSubscriptionWhereInput;
  NOT?: CrossSubscriptionWhereInput[] | CrossSubscriptionWhereInput;
}

export interface CourageCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CourageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CourageWhereInput;
  AND?: CourageSubscriptionWhereInput[] | CourageSubscriptionWhereInput;
  OR?: CourageSubscriptionWhereInput[] | CourageSubscriptionWhereInput;
  NOT?: CourageSubscriptionWhereInput[] | CourageSubscriptionWhereInput;
}

export interface CompassionCreateManyInput {
  create?: CompassionCreateInput[] | CompassionCreateInput;
  connect?: CompassionWhereUniqueInput[] | CompassionWhereUniqueInput;
}

export interface ConstructSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ConstructWhereInput;
  AND?: ConstructSubscriptionWhereInput[] | ConstructSubscriptionWhereInput;
  OR?: ConstructSubscriptionWhereInput[] | ConstructSubscriptionWhereInput;
  NOT?: ConstructSubscriptionWhereInput[] | ConstructSubscriptionWhereInput;
}

export interface CompassionCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CongregantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CongregantWhereInput;
  AND?: CongregantSubscriptionWhereInput[] | CongregantSubscriptionWhereInput;
  OR?: CongregantSubscriptionWhereInput[] | CongregantSubscriptionWhereInput;
  NOT?: CongregantSubscriptionWhereInput[] | CongregantSubscriptionWhereInput;
}

export interface SupportCreateManyInput {
  create?: SupportCreateInput[] | SupportCreateInput;
  connect?: SupportWhereUniqueInput[] | SupportWhereUniqueInput;
}

export interface StigmataWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nail_every?: NailWhereInput;
  nail_some?: NailWhereInput;
  nail_none?: NailWhereInput;
  crown_every?: CrownWhereInput;
  crown_some?: CrownWhereInput;
  crown_none?: CrownWhereInput;
  cross_every?: CrossWhereInput;
  cross_some?: CrossWhereInput;
  cross_none?: CrossWhereInput;
  AND?: StigmataWhereInput[] | StigmataWhereInput;
  OR?: StigmataWhereInput[] | StigmataWhereInput;
  NOT?: StigmataWhereInput[] | StigmataWhereInput;
}

export interface SupportCreateInput {
  id?: ID_Input;
  courage?: CourageCreateManyInput;
  compassion?: CompassionCreateManyInput;
}

export interface SufferingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: SufferingWhereInput[] | SufferingWhereInput;
  OR?: SufferingWhereInput[] | SufferingWhereInput;
  NOT?: SufferingWhereInput[] | SufferingWhereInput;
}

export interface SacrificeCreateManyInput {
  create?: SacrificeCreateInput[] | SacrificeCreateInput;
  connect?: SacrificeWhereUniqueInput[] | SacrificeWhereUniqueInput;
}

export interface CrossWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  suffering_every?: SufferingWhereInput;
  suffering_some?: SufferingWhereInput;
  suffering_none?: SufferingWhereInput;
  AND?: CrossWhereInput[] | CrossWhereInput;
  OR?: CrossWhereInput[] | CrossWhereInput;
  NOT?: CrossWhereInput[] | CrossWhereInput;
}

export interface SacrificeCreateInput {
  id?: ID_Input;
  courage?: CourageCreateManyInput;
  compassion?: CompassionCreateManyInput;
}

export interface CompassionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompassionWhereInput;
  AND?: CompassionSubscriptionWhereInput[] | CompassionSubscriptionWhereInput;
  OR?: CompassionSubscriptionWhereInput[] | CompassionSubscriptionWhereInput;
  NOT?: CompassionSubscriptionWhereInput[] | CompassionSubscriptionWhereInput;
}

export interface ActUpdateInput {
  service?: ServiceUpdateManyInput;
  support?: SupportUpdateManyInput;
  sacrifice?: SacrificeUpdateManyInput;
}

export interface CharactersSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CharactersWhereInput;
  AND?: CharactersSubscriptionWhereInput[] | CharactersSubscriptionWhereInput;
  OR?: CharactersSubscriptionWhereInput[] | CharactersSubscriptionWhereInput;
  NOT?: CharactersSubscriptionWhereInput[] | CharactersSubscriptionWhereInput;
}

export interface ServiceUpdateManyInput {
  create?: ServiceCreateInput[] | ServiceCreateInput;
  update?:
    | ServiceUpdateWithWhereUniqueNestedInput[]
    | ServiceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ServiceUpsertWithWhereUniqueNestedInput[]
    | ServiceUpsertWithWhereUniqueNestedInput;
  delete?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput;
  connect?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput;
  set?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput;
  disconnect?: ServiceWhereUniqueInput[] | ServiceWhereUniqueInput;
  deleteMany?: ServiceScalarWhereInput[] | ServiceScalarWhereInput;
}

export interface CampaignSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CampaignWhereInput;
  AND?: CampaignSubscriptionWhereInput[] | CampaignSubscriptionWhereInput;
  OR?: CampaignSubscriptionWhereInput[] | CampaignSubscriptionWhereInput;
  NOT?: CampaignSubscriptionWhereInput[] | CampaignSubscriptionWhereInput;
}

export interface ServiceUpdateWithWhereUniqueNestedInput {
  where: ServiceWhereUniqueInput;
  data: ServiceUpdateDataInput;
}

export interface BrainSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BrainWhereInput;
  AND?: BrainSubscriptionWhereInput[] | BrainSubscriptionWhereInput;
  OR?: BrainSubscriptionWhereInput[] | BrainSubscriptionWhereInput;
  NOT?: BrainSubscriptionWhereInput[] | BrainSubscriptionWhereInput;
}

export interface ServiceUpdateDataInput {
  courage?: CourageUpdateManyInput;
  compassion?: CompassionUpdateManyInput;
}

export interface BoundarySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BoundaryWhereInput;
  AND?: BoundarySubscriptionWhereInput[] | BoundarySubscriptionWhereInput;
  OR?: BoundarySubscriptionWhereInput[] | BoundarySubscriptionWhereInput;
  NOT?: BoundarySubscriptionWhereInput[] | BoundarySubscriptionWhereInput;
}

export interface CourageUpdateManyInput {
  create?: CourageCreateInput[] | CourageCreateInput;
  update?:
    | CourageUpdateWithWhereUniqueNestedInput[]
    | CourageUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CourageUpsertWithWhereUniqueNestedInput[]
    | CourageUpsertWithWhereUniqueNestedInput;
  delete?: CourageWhereUniqueInput[] | CourageWhereUniqueInput;
  connect?: CourageWhereUniqueInput[] | CourageWhereUniqueInput;
  set?: CourageWhereUniqueInput[] | CourageWhereUniqueInput;
  disconnect?: CourageWhereUniqueInput[] | CourageWhereUniqueInput;
  deleteMany?: CourageScalarWhereInput[] | CourageScalarWhereInput;
  updateMany?:
    | CourageUpdateManyWithWhereNestedInput[]
    | CourageUpdateManyWithWhereNestedInput;
}

export interface OathWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  pledge_every?: PledgeWhereInput;
  pledge_some?: PledgeWhereInput;
  pledge_none?: PledgeWhereInput;
  campaign_every?: CampaignWhereInput;
  campaign_some?: CampaignWhereInput;
  campaign_none?: CampaignWhereInput;
  crusade_every?: CrusadeWhereInput;
  crusade_some?: CrusadeWhereInput;
  crusade_none?: CrusadeWhereInput;
  AND?: OathWhereInput[] | OathWhereInput;
  OR?: OathWhereInput[] | OathWhereInput;
  NOT?: OathWhereInput[] | OathWhereInput;
}

export interface CourageUpdateWithWhereUniqueNestedInput {
  where: CourageWhereUniqueInput;
  data: CourageUpdateDataInput;
}

export interface CrusadeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  loyalty_every?: LoyaltyWhereInput;
  loyalty_some?: LoyaltyWhereInput;
  loyalty_none?: LoyaltyWhereInput;
  honor_every?: HonorWhereInput;
  honor_some?: HonorWhereInput;
  honor_none?: HonorWhereInput;
  AND?: CrusadeWhereInput[] | CrusadeWhereInput;
  OR?: CrusadeWhereInput[] | CrusadeWhereInput;
  NOT?: CrusadeWhereInput[] | CrusadeWhereInput;
}

export interface CourageUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ArmorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArmorWhereInput;
  AND?: ArmorSubscriptionWhereInput[] | ArmorSubscriptionWhereInput;
  OR?: ArmorSubscriptionWhereInput[] | ArmorSubscriptionWhereInput;
  NOT?: ArmorSubscriptionWhereInput[] | ArmorSubscriptionWhereInput;
}

export interface CourageUpsertWithWhereUniqueNestedInput {
  where: CourageWhereUniqueInput;
  update: CourageUpdateDataInput;
  create: CourageCreateInput;
}

export interface AngerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AngerWhereInput;
  AND?: AngerSubscriptionWhereInput[] | AngerSubscriptionWhereInput;
  OR?: AngerSubscriptionWhereInput[] | AngerSubscriptionWhereInput;
  NOT?: AngerSubscriptionWhereInput[] | AngerSubscriptionWhereInput;
}

export interface CourageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: CourageScalarWhereInput[] | CourageScalarWhereInput;
  OR?: CourageScalarWhereInput[] | CourageScalarWhereInput;
  NOT?: CourageScalarWhereInput[] | CourageScalarWhereInput;
}

export interface AfflictionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AfflictionWhereInput;
  AND?: AfflictionSubscriptionWhereInput[] | AfflictionSubscriptionWhereInput;
  OR?: AfflictionSubscriptionWhereInput[] | AfflictionSubscriptionWhereInput;
  NOT?: AfflictionSubscriptionWhereInput[] | AfflictionSubscriptionWhereInput;
}

export interface CourageUpdateManyWithWhereNestedInput {
  where: CourageScalarWhereInput;
  data: CourageUpdateManyDataInput;
}

export interface VirtueWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  nail_every?: NailWhereInput;
  nail_some?: NailWhereInput;
  nail_none?: NailWhereInput;
  crown_every?: CrownWhereInput;
  crown_some?: CrownWhereInput;
  crown_none?: CrownWhereInput;
  cross_every?: CrossWhereInput;
  cross_some?: CrossWhereInput;
  cross_none?: CrossWhereInput;
  AND?: VirtueWhereInput[] | VirtueWhereInput;
  OR?: VirtueWhereInput[] | VirtueWhereInput;
  NOT?: VirtueWhereInput[] | VirtueWhereInput;
}

export interface CourageUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface NightmareWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  trauma_every?: TraumaWhereInput;
  trauma_some?: TraumaWhereInput;
  trauma_none?: TraumaWhereInput;
  toxicity_every?: ToxicityWhereInput;
  toxicity_some?: ToxicityWhereInput;
  toxicity_none?: ToxicityWhereInput;
  AND?: NightmareWhereInput[] | NightmareWhereInput;
  OR?: NightmareWhereInput[] | NightmareWhereInput;
  NOT?: NightmareWhereInput[] | NightmareWhereInput;
}

export interface CompassionUpdateManyInput {
  create?: CompassionCreateInput[] | CompassionCreateInput;
  update?:
    | CompassionUpdateWithWhereUniqueNestedInput[]
    | CompassionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CompassionUpsertWithWhereUniqueNestedInput[]
    | CompassionUpsertWithWhereUniqueNestedInput;
  delete?: CompassionWhereUniqueInput[] | CompassionWhereUniqueInput;
  connect?: CompassionWhereUniqueInput[] | CompassionWhereUniqueInput;
  set?: CompassionWhereUniqueInput[] | CompassionWhereUniqueInput;
  disconnect?: CompassionWhereUniqueInput[] | CompassionWhereUniqueInput;
  deleteMany?: CompassionScalarWhereInput[] | CompassionScalarWhereInput;
  updateMany?:
    | CompassionUpdateManyWithWhereNestedInput[]
    | CompassionUpdateManyWithWhereNestedInput;
}

export interface WishUpdateInput {
  dream?: DreamUpdateManyInput;
}

export interface CompassionUpdateWithWhereUniqueNestedInput {
  where: CompassionWhereUniqueInput;
  data: CompassionUpdateDataInput;
}

export interface SilenceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  armor_every?: ArmorWhereInput;
  armor_some?: ArmorWhereInput;
  armor_none?: ArmorWhereInput;
  AND?: SilenceWhereInput[] | SilenceWhereInput;
  OR?: SilenceWhereInput[] | SilenceWhereInput;
  NOT?: SilenceWhereInput[] | SilenceWhereInput;
}

export interface CompassionUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface DenialWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  armor_every?: ArmorWhereInput;
  armor_some?: ArmorWhereInput;
  armor_none?: ArmorWhereInput;
  AND?: DenialWhereInput[] | DenialWhereInput;
  OR?: DenialWhereInput[] | DenialWhereInput;
  NOT?: DenialWhereInput[] | DenialWhereInput;
}

export interface CompassionUpsertWithWhereUniqueNestedInput {
  where: CompassionWhereUniqueInput;
  update: CompassionUpdateDataInput;
  create: CompassionCreateInput;
}

export interface SeekerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SeekerWhereInput;
  AND?: SeekerSubscriptionWhereInput[] | SeekerSubscriptionWhereInput;
  OR?: SeekerSubscriptionWhereInput[] | SeekerSubscriptionWhereInput;
  NOT?: SeekerSubscriptionWhereInput[] | SeekerSubscriptionWhereInput;
}

export interface CompassionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: CompassionScalarWhereInput[] | CompassionScalarWhereInput;
  OR?: CompassionScalarWhereInput[] | CompassionScalarWhereInput;
  NOT?: CompassionScalarWhereInput[] | CompassionScalarWhereInput;
}

export interface TremorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  trauma_every?: TraumaWhereInput;
  trauma_some?: TraumaWhereInput;
  trauma_none?: TraumaWhereInput;
  toxicity_every?: ToxicityWhereInput;
  toxicity_some?: ToxicityWhereInput;
  toxicity_none?: ToxicityWhereInput;
  AND?: TremorWhereInput[] | TremorWhereInput;
  OR?: TremorWhereInput[] | TremorWhereInput;
  NOT?: TremorWhereInput[] | TremorWhereInput;
}

export interface CompassionUpdateManyWithWhereNestedInput {
  where: CompassionScalarWhereInput;
  data: CompassionUpdateManyDataInput;
}

export interface SelfSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SelfWhereInput;
  AND?: SelfSubscriptionWhereInput[] | SelfSubscriptionWhereInput;
  OR?: SelfSubscriptionWhereInput[] | SelfSubscriptionWhereInput;
  NOT?: SelfSubscriptionWhereInput[] | SelfSubscriptionWhereInput;
}

export interface CompassionUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface InfectionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  trauma_every?: TraumaWhereInput;
  trauma_some?: TraumaWhereInput;
  trauma_none?: TraumaWhereInput;
  toxicity_every?: ToxicityWhereInput;
  toxicity_some?: ToxicityWhereInput;
  toxicity_none?: ToxicityWhereInput;
  AND?: InfectionWhereInput[] | InfectionWhereInput;
  OR?: InfectionWhereInput[] | InfectionWhereInput;
  NOT?: InfectionWhereInput[] | InfectionWhereInput;
}

export interface ServiceUpsertWithWhereUniqueNestedInput {
  where: ServiceWhereUniqueInput;
  update: ServiceUpdateDataInput;
  create: ServiceCreateInput;
}

export interface SelfPitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SelfPityWhereInput;
  AND?: SelfPitySubscriptionWhereInput[] | SelfPitySubscriptionWhereInput;
  OR?: SelfPitySubscriptionWhereInput[] | SelfPitySubscriptionWhereInput;
  NOT?: SelfPitySubscriptionWhereInput[] | SelfPitySubscriptionWhereInput;
}

export interface ServiceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ServiceScalarWhereInput[] | ServiceScalarWhereInput;
  OR?: ServiceScalarWhereInput[] | ServiceScalarWhereInput;
  NOT?: ServiceScalarWhereInput[] | ServiceScalarWhereInput;
}

export interface VictimUpdateInput {
  affliction?: AfflictionUpdateManyInput;
}

export interface SupportUpdateManyInput {
  create?: SupportCreateInput[] | SupportCreateInput;
  update?:
    | SupportUpdateWithWhereUniqueNestedInput[]
    | SupportUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SupportUpsertWithWhereUniqueNestedInput[]
    | SupportUpsertWithWhereUniqueNestedInput;
  delete?: SupportWhereUniqueInput[] | SupportWhereUniqueInput;
  connect?: SupportWhereUniqueInput[] | SupportWhereUniqueInput;
  set?: SupportWhereUniqueInput[] | SupportWhereUniqueInput;
  disconnect?: SupportWhereUniqueInput[] | SupportWhereUniqueInput;
  deleteMany?: SupportScalarWhereInput[] | SupportScalarWhereInput;
}

export interface TraumaUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SupportUpdateWithWhereUniqueNestedInput {
  where: SupportWhereUniqueInput;
  data: SupportUpdateDataInput;
}

export interface CongregantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: CongregantWhereInput[] | CongregantWhereInput;
  OR?: CongregantWhereInput[] | CongregantWhereInput;
  NOT?: CongregantWhereInput[] | CongregantWhereInput;
}

export interface SupportUpdateDataInput {
  courage?: CourageUpdateManyInput;
  compassion?: CompassionUpdateManyInput;
}

export interface GuardianWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  construct_every?: ConstructWhereInput;
  construct_some?: ConstructWhereInput;
  construct_none?: ConstructWhereInput;
  AND?: GuardianWhereInput[] | GuardianWhereInput;
  OR?: GuardianWhereInput[] | GuardianWhereInput;
  NOT?: GuardianWhereInput[] | GuardianWhereInput;
}

export interface SupportUpsertWithWhereUniqueNestedInput {
  where: SupportWhereUniqueInput;
  update: SupportUpdateDataInput;
  create: SupportCreateInput;
}

export interface PaladinWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  oath_every?: OathWhereInput;
  oath_some?: OathWhereInput;
  oath_none?: OathWhereInput;
  AND?: PaladinWhereInput[] | PaladinWhereInput;
  OR?: PaladinWhereInput[] | PaladinWhereInput;
  NOT?: PaladinWhereInput[] | PaladinWhereInput;
}

export interface SupportScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: SupportScalarWhereInput[] | SupportScalarWhereInput;
  OR?: SupportScalarWhereInput[] | SupportScalarWhereInput;
  NOT?: SupportScalarWhereInput[] | SupportScalarWhereInput;
}

export interface SelfWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  body_every?: BodyWhereInput;
  body_some?: BodyWhereInput;
  body_none?: BodyWhereInput;
  AND?: SelfWhereInput[] | SelfWhereInput;
  OR?: SelfWhereInput[] | SelfWhereInput;
  NOT?: SelfWhereInput[] | SelfWhereInput;
}

export interface SacrificeUpdateManyInput {
  create?: SacrificeCreateInput[] | SacrificeCreateInput;
  update?:
    | SacrificeUpdateWithWhereUniqueNestedInput[]
    | SacrificeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SacrificeUpsertWithWhereUniqueNestedInput[]
    | SacrificeUpsertWithWhereUniqueNestedInput;
  delete?: SacrificeWhereUniqueInput[] | SacrificeWhereUniqueInput;
  connect?: SacrificeWhereUniqueInput[] | SacrificeWhereUniqueInput;
  set?: SacrificeWhereUniqueInput[] | SacrificeWhereUniqueInput;
  disconnect?: SacrificeWhereUniqueInput[] | SacrificeWhereUniqueInput;
  deleteMany?: SacrificeScalarWhereInput[] | SacrificeScalarWhereInput;
}

export interface SummonerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: SummonerWhereInput[] | SummonerWhereInput;
  OR?: SummonerWhereInput[] | SummonerWhereInput;
  NOT?: SummonerWhereInput[] | SummonerWhereInput;
}

export interface SacrificeUpdateWithWhereUniqueNestedInput {
  where: SacrificeWhereUniqueInput;
  data: SacrificeUpdateDataInput;
}

export interface VolunteerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  act_every?: ActWhereInput;
  act_some?: ActWhereInput;
  act_none?: ActWhereInput;
  AND?: VolunteerWhereInput[] | VolunteerWhereInput;
  OR?: VolunteerWhereInput[] | VolunteerWhereInput;
  NOT?: VolunteerWhereInput[] | VolunteerWhereInput;
}

export interface SacrificeUpdateDataInput {
  courage?: CourageUpdateManyInput;
  compassion?: CompassionUpdateManyInput;
}

export interface TraumaUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SacrificeUpsertWithWhereUniqueNestedInput {
  where: SacrificeWhereUniqueInput;
  update: SacrificeUpdateDataInput;
  create: SacrificeCreateInput;
}

export interface ToxicityUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SacrificeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: SacrificeScalarWhereInput[] | SacrificeScalarWhereInput;
  OR?: SacrificeScalarWhereInput[] | SacrificeScalarWhereInput;
  NOT?: SacrificeScalarWhereInput[] | SacrificeScalarWhereInput;
}

export interface TowerUpdateInput {
  boundary?: BoundaryUpdateManyInput;
}

export interface AfflictionCreateInput {
  id?: ID_Input;
  scar?: ScarCreateManyInput;
  gash?: GashCreateManyInput;
  infection?: InfectionCreateManyInput;
  tremor?: TremorCreateManyInput;
  nightmare?: NightmareCreateManyInput;
  delirium?: DeliriumCreateManyInput;
}

export interface SufferingUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ScarCreateManyInput {
  create?: ScarCreateInput[] | ScarCreateInput;
  connect?: ScarWhereUniqueInput[] | ScarWhereUniqueInput;
}

export interface SufferingUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ScarCreateInput {
  id?: ID_Input;
  trauma?: TraumaCreateManyInput;
  toxicity?: ToxicityCreateManyInput;
}

export interface StigmataUpdateInput {
  nail?: NailUpdateManyInput;
  crown?: CrownUpdateManyInput;
  cross?: CrossUpdateManyInput;
}

export interface TraumaCreateManyInput {
  create?: TraumaCreateInput[] | TraumaCreateInput;
  connect?: TraumaWhereUniqueInput[] | TraumaWhereUniqueInput;
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ServiceWhereInput;
  AND?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
  OR?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
  NOT?: ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput;
}

export interface TraumaCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SoulUpdateInput {
  vulnerability?: VulnerabilityUpdateManyInput;
  acceptance?: AcceptanceUpdateManyInput;
}

export interface ToxicityCreateManyInput {
  create?: ToxicityCreateInput[] | ToxicityCreateInput;
  connect?: ToxicityWhereUniqueInput[] | ToxicityWhereUniqueInput;
}

export type ConstructWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ToxicityCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SkinCreateInput {
  id?: ID_Input;
  anger?: AngerCreateManyInput;
  fear?: FearCreateManyInput;
  pride?: PrideCreateManyInput;
  selfPity?: SelfPityCreateManyInput;
}

export interface GashCreateManyInput {
  create?: GashCreateInput[] | GashCreateInput;
  connect?: GashWhereUniqueInput[] | GashWhereUniqueInput;
}

export type CourageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GashCreateInput {
  id?: ID_Input;
  trauma?: TraumaCreateManyInput;
  toxicity?: ToxicityCreateManyInput;
}

export interface ServiceUpdateInput {
  courage?: CourageUpdateManyInput;
  compassion?: CompassionUpdateManyInput;
}

export interface InfectionCreateManyInput {
  create?: InfectionCreateInput[] | InfectionCreateInput;
  connect?: InfectionWhereUniqueInput[] | InfectionWhereUniqueInput;
}

export type CrossWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface InfectionCreateInput {
  id?: ID_Input;
  trauma?: TraumaCreateManyInput;
  toxicity?: ToxicityCreateManyInput;
}

export interface SelfUpdateInput {
  body?: BodyUpdateManyInput;
}

export interface TremorCreateManyInput {
  create?: TremorCreateInput[] | TremorCreateInput;
  connect?: TremorWhereUniqueInput[] | TremorWhereUniqueInput;
}

export type CrownWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TremorCreateInput {
  id?: ID_Input;
  trauma?: TraumaCreateManyInput;
  toxicity?: ToxicityCreateManyInput;
}

export interface SarcasmUpdateInput {
  armor?: ArmorUpdateManyInput;
}

export interface NightmareCreateManyInput {
  create?: NightmareCreateInput[] | NightmareCreateInput;
  connect?: NightmareWhereUniqueInput[] | NightmareWhereUniqueInput;
}

export type CrusadeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NightmareCreateInput {
  id?: ID_Input;
  trauma?: TraumaCreateManyInput;
  toxicity?: ToxicityCreateManyInput;
}

export interface SacrificeUpdateInput {
  courage?: CourageUpdateManyInput;
  compassion?: CompassionUpdateManyInput;
}

export interface DeliriumCreateManyInput {
  create?: DeliriumCreateInput[] | DeliriumCreateInput;
  connect?: DeliriumWhereUniqueInput[] | DeliriumWhereUniqueInput;
}

export type DefectWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DeliriumCreateInput {
  id?: ID_Input;
  trauma?: TraumaCreateManyInput;
  toxicity?: ToxicityCreateManyInput;
}

export interface DefectWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  trauma_every?: TraumaWhereInput;
  trauma_some?: TraumaWhereInput;
  trauma_none?: TraumaWhereInput;
  toxicity_every?: ToxicityWhereInput;
  toxicity_some?: ToxicityWhereInput;
  toxicity_none?: ToxicityWhereInput;
  suffering_every?: SufferingWhereInput;
  suffering_some?: SufferingWhereInput;
  suffering_none?: SufferingWhereInput;
  AND?: DefectWhereInput[] | DefectWhereInput;
  OR?: DefectWhereInput[] | DefectWhereInput;
  NOT?: DefectWhereInput[] | DefectWhereInput;
}

export interface AfflictionUpdateInput {
  scar?: ScarUpdateManyInput;
  gash?: GashUpdateManyInput;
  infection?: InfectionUpdateManyInput;
  tremor?: TremorUpdateManyInput;
  nightmare?: NightmareUpdateManyInput;
  delirium?: DeliriumUpdateManyInput;
}

export interface PrideUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ScarUpdateManyInput {
  create?: ScarCreateInput[] | ScarCreateInput;
  update?:
    | ScarUpdateWithWhereUniqueNestedInput[]
    | ScarUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ScarUpsertWithWhereUniqueNestedInput[]
    | ScarUpsertWithWhereUniqueNestedInput;
  delete?: ScarWhereUniqueInput[] | ScarWhereUniqueInput;
  connect?: ScarWhereUniqueInput[] | ScarWhereUniqueInput;
  set?: ScarWhereUniqueInput[] | ScarWhereUniqueInput;
  disconnect?: ScarWhereUniqueInput[] | ScarWhereUniqueInput;
  deleteMany?: ScarScalarWhereInput[] | ScarScalarWhereInput;
}

export interface PrayerUpdateInput {
  process?: ProcessUpdateOneInput;
  path?: PathUpdateOneInput;
}

export interface ScarUpdateWithWhereUniqueNestedInput {
  where: ScarWhereUniqueInput;
  data: ScarUpdateDataInput;
}

export interface PledgeUpdateInput {
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
}

export interface ScarUpdateDataInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface PaladinUpdateInput {
  oath?: OathUpdateManyInput;
}

export interface TraumaUpdateManyInput {
  create?: TraumaCreateInput[] | TraumaCreateInput;
  update?:
    | TraumaUpdateWithWhereUniqueNestedInput[]
    | TraumaUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TraumaUpsertWithWhereUniqueNestedInput[]
    | TraumaUpsertWithWhereUniqueNestedInput;
  delete?: TraumaWhereUniqueInput[] | TraumaWhereUniqueInput;
  connect?: TraumaWhereUniqueInput[] | TraumaWhereUniqueInput;
  set?: TraumaWhereUniqueInput[] | TraumaWhereUniqueInput;
  disconnect?: TraumaWhereUniqueInput[] | TraumaWhereUniqueInput;
  deleteMany?: TraumaScalarWhereInput[] | TraumaScalarWhereInput;
  updateMany?:
    | TraumaUpdateManyWithWhereNestedInput[]
    | TraumaUpdateManyWithWhereNestedInput;
}

export interface ObsessionUpdateInput {
  suffering?: SufferingUpdateManyInput;
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
  vulnerability?: VulnerabilityUpdateManyInput;
}

export interface TraumaUpdateWithWhereUniqueNestedInput {
  where: TraumaWhereUniqueInput;
  data: TraumaUpdateDataInput;
}

export interface NightmareUpdateInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface TraumaUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface NailUpdateInput {
  suffering?: SufferingUpdateManyInput;
}

export interface TraumaUpsertWithWhereUniqueNestedInput {
  where: TraumaWhereUniqueInput;
  update: TraumaUpdateDataInput;
  create: TraumaCreateInput;
}

export interface SilenceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SilenceWhereInput;
  AND?: SilenceSubscriptionWhereInput[] | SilenceSubscriptionWhereInput;
  OR?: SilenceSubscriptionWhereInput[] | SilenceSubscriptionWhereInput;
  NOT?: SilenceSubscriptionWhereInput[] | SilenceSubscriptionWhereInput;
}

export interface TraumaScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: TraumaScalarWhereInput[] | TraumaScalarWhereInput;
  OR?: TraumaScalarWhereInput[] | TraumaScalarWhereInput;
  NOT?: TraumaScalarWhereInput[] | TraumaScalarWhereInput;
}

export interface ImpatienceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolveAt?: DateTimeInput;
  resolveAt_not?: DateTimeInput;
  resolveAt_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_lt?: DateTimeInput;
  resolveAt_lte?: DateTimeInput;
  resolveAt_gt?: DateTimeInput;
  resolveAt_gte?: DateTimeInput;
  AND?: ImpatienceWhereInput[] | ImpatienceWhereInput;
  OR?: ImpatienceWhereInput[] | ImpatienceWhereInput;
  NOT?: ImpatienceWhereInput[] | ImpatienceWhereInput;
}

export interface TraumaUpdateManyWithWhereNestedInput {
  where: TraumaScalarWhereInput;
  data: TraumaUpdateManyDataInput;
}

export interface MindUpdateInput {
  vulnerability?: VulnerabilityUpdateManyInput;
  acceptance?: AcceptanceUpdateManyInput;
}

export interface TraumaUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface TraumaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: TraumaWhereInput[] | TraumaWhereInput;
  OR?: TraumaWhereInput[] | TraumaWhereInput;
  NOT?: TraumaWhereInput[] | TraumaWhereInput;
}

export interface ToxicityUpdateManyInput {
  create?: ToxicityCreateInput[] | ToxicityCreateInput;
  update?:
    | ToxicityUpdateWithWhereUniqueNestedInput[]
    | ToxicityUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ToxicityUpsertWithWhereUniqueNestedInput[]
    | ToxicityUpsertWithWhereUniqueNestedInput;
  delete?: ToxicityWhereUniqueInput[] | ToxicityWhereUniqueInput;
  connect?: ToxicityWhereUniqueInput[] | ToxicityWhereUniqueInput;
  set?: ToxicityWhereUniqueInput[] | ToxicityWhereUniqueInput;
  disconnect?: ToxicityWhereUniqueInput[] | ToxicityWhereUniqueInput;
  deleteMany?: ToxicityScalarWhereInput[] | ToxicityScalarWhereInput;
  updateMany?:
    | ToxicityUpdateManyWithWhereNestedInput[]
    | ToxicityUpdateManyWithWhereNestedInput;
}

export interface MartyrUpdateInput {
  stigmata?: StigmataUpdateManyInput;
}

export interface ToxicityUpdateWithWhereUniqueNestedInput {
  where: ToxicityWhereUniqueInput;
  data: ToxicityUpdateDataInput;
}

export type DreamWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ToxicityUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface LoveUpdateInput {
  vulnerability?: VulnerabilityUpdateManyInput;
  acceptance?: AcceptanceUpdateManyInput;
}

export interface ToxicityUpsertWithWhereUniqueNestedInput {
  where: ToxicityWhereUniqueInput;
  update: ToxicityUpdateDataInput;
  create: ToxicityCreateInput;
}

export type ExperienceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ToxicityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: ToxicityScalarWhereInput[] | ToxicityScalarWhereInput;
  OR?: ToxicityScalarWhereInput[] | ToxicityScalarWhereInput;
  NOT?: ToxicityScalarWhereInput[] | ToxicityScalarWhereInput;
}

export interface GratitudeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: GratitudeWhereInput[] | GratitudeWhereInput;
  OR?: GratitudeWhereInput[] | GratitudeWhereInput;
  NOT?: GratitudeWhereInput[] | GratitudeWhereInput;
}

export interface ToxicityUpdateManyWithWhereNestedInput {
  where: ToxicityScalarWhereInput;
  data: ToxicityUpdateManyDataInput;
}

export interface JoyUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface ToxicityUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SkinSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SkinWhereInput;
  AND?: SkinSubscriptionWhereInput[] | SkinSubscriptionWhereInput;
  OR?: SkinSubscriptionWhereInput[] | SkinSubscriptionWhereInput;
  NOT?: SkinSubscriptionWhereInput[] | SkinSubscriptionWhereInput;
}

export interface ScarUpsertWithWhereUniqueNestedInput {
  where: ScarWhereUniqueInput;
  update: ScarUpdateDataInput;
  create: ScarCreateInput;
}

export interface IrritabilityUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface ScarScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ScarScalarWhereInput[] | ScarScalarWhereInput;
  OR?: ScarScalarWhereInput[] | ScarScalarWhereInput;
  NOT?: ScarScalarWhereInput[] | ScarScalarWhereInput;
}

export type FaceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GashUpdateManyInput {
  create?: GashCreateInput[] | GashCreateInput;
  update?:
    | GashUpdateWithWhereUniqueNestedInput[]
    | GashUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GashUpsertWithWhereUniqueNestedInput[]
    | GashUpsertWithWhereUniqueNestedInput;
  delete?: GashWhereUniqueInput[] | GashWhereUniqueInput;
  connect?: GashWhereUniqueInput[] | GashWhereUniqueInput;
  set?: GashWhereUniqueInput[] | GashWhereUniqueInput;
  disconnect?: GashWhereUniqueInput[] | GashWhereUniqueInput;
  deleteMany?: GashScalarWhereInput[] | GashScalarWhereInput;
}

export interface HopeUpdateWithWhereUniqueNestedInput {
  where: HopeWhereUniqueInput;
  data: HopeUpdateDataInput;
}

export interface GashUpdateWithWhereUniqueNestedInput {
  where: GashWhereUniqueInput;
  data: GashUpdateDataInput;
}

export type FearWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GashUpdateDataInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface StrengthUpsertWithWhereUniqueNestedInput {
  where: StrengthWhereUniqueInput;
  update: StrengthUpdateDataInput;
  create: StrengthCreateInput;
}

export interface GashUpsertWithWhereUniqueNestedInput {
  where: GashWhereUniqueInput;
  update: GashUpdateDataInput;
  create: GashCreateInput;
}

export type FeelingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GashScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: GashScalarWhereInput[] | GashScalarWhereInput;
  OR?: GashScalarWhereInput[] | GashScalarWhereInput;
  NOT?: GashScalarWhereInput[] | GashScalarWhereInput;
}

export interface FeelingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: FeelingWhereInput[] | FeelingWhereInput;
  OR?: FeelingWhereInput[] | FeelingWhereInput;
  NOT?: FeelingWhereInput[] | FeelingWhereInput;
}

export interface InfectionUpdateManyInput {
  create?: InfectionCreateInput[] | InfectionCreateInput;
  update?:
    | InfectionUpdateWithWhereUniqueNestedInput[]
    | InfectionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | InfectionUpsertWithWhereUniqueNestedInput[]
    | InfectionUpsertWithWhereUniqueNestedInput;
  delete?: InfectionWhereUniqueInput[] | InfectionWhereUniqueInput;
  connect?: InfectionWhereUniqueInput[] | InfectionWhereUniqueInput;
  set?: InfectionWhereUniqueInput[] | InfectionWhereUniqueInput;
  disconnect?: InfectionWhereUniqueInput[] | InfectionWhereUniqueInput;
  deleteMany?: InfectionScalarWhereInput[] | InfectionScalarWhereInput;
}

export interface ExperienceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ExperienceScalarWhereInput[] | ExperienceScalarWhereInput;
  OR?: ExperienceScalarWhereInput[] | ExperienceScalarWhereInput;
  NOT?: ExperienceScalarWhereInput[] | ExperienceScalarWhereInput;
}

export interface InfectionUpdateWithWhereUniqueNestedInput {
  where: InfectionWhereUniqueInput;
  data: InfectionUpdateDataInput;
}

export interface ExperienceUpdateWithWhereUniqueNestedInput {
  where: ExperienceWhereUniqueInput;
  data: ExperienceUpdateDataInput;
}

export interface InfectionUpdateDataInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface ExperienceUpdateManyInput {
  create?: ExperienceCreateInput[] | ExperienceCreateInput;
  update?:
    | ExperienceUpdateWithWhereUniqueNestedInput[]
    | ExperienceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ExperienceUpsertWithWhereUniqueNestedInput[]
    | ExperienceUpsertWithWhereUniqueNestedInput;
  delete?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  connect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  set?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  disconnect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
  deleteMany?: ExperienceScalarWhereInput[] | ExperienceScalarWhereInput;
}

export interface InfectionUpsertWithWhereUniqueNestedInput {
  where: InfectionWhereUniqueInput;
  update: InfectionUpdateDataInput;
  create: InfectionCreateInput;
}

export interface SmithSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SmithWhereInput;
  AND?: SmithSubscriptionWhereInput[] | SmithSubscriptionWhereInput;
  OR?: SmithSubscriptionWhereInput[] | SmithSubscriptionWhereInput;
  NOT?: SmithSubscriptionWhereInput[] | SmithSubscriptionWhereInput;
}

export interface InfectionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: InfectionScalarWhereInput[] | InfectionScalarWhereInput;
  OR?: InfectionScalarWhereInput[] | InfectionScalarWhereInput;
  NOT?: InfectionScalarWhereInput[] | InfectionScalarWhereInput;
}

export interface ObsessionUpsertWithWhereUniqueNestedInput {
  where: ObsessionWhereUniqueInput;
  update: ObsessionUpdateDataInput;
  create: ObsessionCreateInput;
}

export interface TremorUpdateManyInput {
  create?: TremorCreateInput[] | TremorCreateInput;
  update?:
    | TremorUpdateWithWhereUniqueNestedInput[]
    | TremorUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TremorUpsertWithWhereUniqueNestedInput[]
    | TremorUpsertWithWhereUniqueNestedInput;
  delete?: TremorWhereUniqueInput[] | TremorWhereUniqueInput;
  connect?: TremorWhereUniqueInput[] | TremorWhereUniqueInput;
  set?: TremorWhereUniqueInput[] | TremorWhereUniqueInput;
  disconnect?: TremorWhereUniqueInput[] | TremorWhereUniqueInput;
  deleteMany?: TremorScalarWhereInput[] | TremorScalarWhereInput;
}

export type GashWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TremorUpdateWithWhereUniqueNestedInput {
  where: TremorWhereUniqueInput;
  data: TremorUpdateDataInput;
}

export interface ResentmentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ResentmentScalarWhereInput[] | ResentmentScalarWhereInput;
  OR?: ResentmentScalarWhereInput[] | ResentmentScalarWhereInput;
  NOT?: ResentmentScalarWhereInput[] | ResentmentScalarWhereInput;
}

export interface TremorUpdateDataInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export type GateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TremorUpsertWithWhereUniqueNestedInput {
  where: TremorWhereUniqueInput;
  update: TremorUpdateDataInput;
  create: TremorCreateInput;
}

export interface ResentmentUpdateManyInput {
  create?: ResentmentCreateInput[] | ResentmentCreateInput;
  update?:
    | ResentmentUpdateWithWhereUniqueNestedInput[]
    | ResentmentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ResentmentUpsertWithWhereUniqueNestedInput[]
    | ResentmentUpsertWithWhereUniqueNestedInput;
  delete?: ResentmentWhereUniqueInput[] | ResentmentWhereUniqueInput;
  connect?: ResentmentWhereUniqueInput[] | ResentmentWhereUniqueInput;
  set?: ResentmentWhereUniqueInput[] | ResentmentWhereUniqueInput;
  disconnect?: ResentmentWhereUniqueInput[] | ResentmentWhereUniqueInput;
  deleteMany?: ResentmentScalarWhereInput[] | ResentmentScalarWhereInput;
}

export interface TremorScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: TremorScalarWhereInput[] | TremorScalarWhereInput;
  OR?: TremorScalarWhereInput[] | TremorScalarWhereInput;
  NOT?: TremorScalarWhereInput[] | TremorScalarWhereInput;
}

export type GenieWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NightmareUpdateManyInput {
  create?: NightmareCreateInput[] | NightmareCreateInput;
  update?:
    | NightmareUpdateWithWhereUniqueNestedInput[]
    | NightmareUpdateWithWhereUniqueNestedInput;
  upsert?:
    | NightmareUpsertWithWhereUniqueNestedInput[]
    | NightmareUpsertWithWhereUniqueNestedInput;
  delete?: NightmareWhereUniqueInput[] | NightmareWhereUniqueInput;
  connect?: NightmareWhereUniqueInput[] | NightmareWhereUniqueInput;
  set?: NightmareWhereUniqueInput[] | NightmareWhereUniqueInput;
  disconnect?: NightmareWhereUniqueInput[] | NightmareWhereUniqueInput;
  deleteMany?: NightmareScalarWhereInput[] | NightmareScalarWhereInput;
}

export interface DiscontentUpsertWithWhereUniqueNestedInput {
  where: DiscontentWhereUniqueInput;
  update: DiscontentUpdateDataInput;
  create: DiscontentCreateInput;
}

export interface NightmareUpdateWithWhereUniqueNestedInput {
  where: NightmareWhereUniqueInput;
  data: NightmareUpdateDataInput;
}

export interface DiscontentUpdateManyInput {
  create?: DiscontentCreateInput[] | DiscontentCreateInput;
  update?:
    | DiscontentUpdateWithWhereUniqueNestedInput[]
    | DiscontentUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DiscontentUpsertWithWhereUniqueNestedInput[]
    | DiscontentUpsertWithWhereUniqueNestedInput;
  delete?: DiscontentWhereUniqueInput[] | DiscontentWhereUniqueInput;
  connect?: DiscontentWhereUniqueInput[] | DiscontentWhereUniqueInput;
  set?: DiscontentWhereUniqueInput[] | DiscontentWhereUniqueInput;
  disconnect?: DiscontentWhereUniqueInput[] | DiscontentWhereUniqueInput;
  deleteMany?: DiscontentScalarWhereInput[] | DiscontentScalarWhereInput;
}

export interface NightmareUpdateDataInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface DefectScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: DefectScalarWhereInput[] | DefectScalarWhereInput;
  OR?: DefectScalarWhereInput[] | DefectScalarWhereInput;
  NOT?: DefectScalarWhereInput[] | DefectScalarWhereInput;
}

export interface NightmareUpsertWithWhereUniqueNestedInput {
  where: NightmareWhereUniqueInput;
  update: NightmareUpdateDataInput;
  create: NightmareCreateInput;
}

export interface DefectUpdateWithWhereUniqueNestedInput {
  where: DefectWhereUniqueInput;
  data: DefectUpdateDataInput;
}

export interface NightmareScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: NightmareScalarWhereInput[] | NightmareScalarWhereInput;
  OR?: NightmareScalarWhereInput[] | NightmareScalarWhereInput;
  NOT?: NightmareScalarWhereInput[] | NightmareScalarWhereInput;
}

export interface SternumSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SternumWhereInput;
  AND?: SternumSubscriptionWhereInput[] | SternumSubscriptionWhereInput;
  OR?: SternumSubscriptionWhereInput[] | SternumSubscriptionWhereInput;
  NOT?: SternumSubscriptionWhereInput[] | SternumSubscriptionWhereInput;
}

export interface DeliriumUpdateManyInput {
  create?: DeliriumCreateInput[] | DeliriumCreateInput;
  update?:
    | DeliriumUpdateWithWhereUniqueNestedInput[]
    | DeliriumUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DeliriumUpsertWithWhereUniqueNestedInput[]
    | DeliriumUpsertWithWhereUniqueNestedInput;
  delete?: DeliriumWhereUniqueInput[] | DeliriumWhereUniqueInput;
  connect?: DeliriumWhereUniqueInput[] | DeliriumWhereUniqueInput;
  set?: DeliriumWhereUniqueInput[] | DeliriumWhereUniqueInput;
  disconnect?: DeliriumWhereUniqueInput[] | DeliriumWhereUniqueInput;
  deleteMany?: DeliriumScalarWhereInput[] | DeliriumScalarWhereInput;
}

export interface InventoryUpdateInput {
  defect?: DefectUpdateManyInput;
  discontent?: DiscontentUpdateManyInput;
  resentment?: ResentmentUpdateManyInput;
  obsession?: ObsessionUpdateManyInput;
  experience?: ExperienceUpdateManyInput;
  strength?: StrengthUpdateManyInput;
  hope?: HopeUpdateManyInput;
}

export interface DeliriumUpdateWithWhereUniqueNestedInput {
  where: DeliriumWhereUniqueInput;
  data: DeliriumUpdateDataInput;
}

export type GutWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DeliriumUpdateDataInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface ExperienceCreateManyInput {
  create?: ExperienceCreateInput[] | ExperienceCreateInput;
  connect?: ExperienceWhereUniqueInput[] | ExperienceWhereUniqueInput;
}

export interface DeliriumUpsertWithWhereUniqueNestedInput {
  where: DeliriumWhereUniqueInput;
  update: DeliriumUpdateDataInput;
  create: DeliriumCreateInput;
}

export type HasWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DeliriumScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: DeliriumScalarWhereInput[] | DeliriumScalarWhereInput;
  OR?: DeliriumScalarWhereInput[] | DeliriumScalarWhereInput;
  NOT?: DeliriumScalarWhereInput[] | DeliriumScalarWhereInput;
}

export interface HasWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  defect?: Boolean;
  defect_not?: Boolean;
  discontent?: Boolean;
  discontent_not?: Boolean;
  resentment?: Boolean;
  resentment_not?: Boolean;
  obsession?: Boolean;
  obsession_not?: Boolean;
  experience?: Boolean;
  experience_not?: Boolean;
  strength?: Boolean;
  strength_not?: Boolean;
  hope?: Boolean;
  hope_not?: Boolean;
  acceptance?: Boolean;
  acceptance_not?: Boolean;
  anger?: Boolean;
  anger_not?: Boolean;
  armor?: Boolean;
  armor_not?: Boolean;
  boundary?: Boolean;
  boundary_not?: Boolean;
  compassion?: Boolean;
  compassion_not?: Boolean;
  courage?: Boolean;
  courage_not?: Boolean;
  fear?: Boolean;
  fear_not?: Boolean;
  fun?: Boolean;
  fun_not?: Boolean;
  gratitude?: Boolean;
  gratitude_not?: Boolean;
  irritability?: Boolean;
  irritability_not?: Boolean;
  impatience?: Boolean;
  impatience_not?: Boolean;
  joy?: Boolean;
  joy_not?: Boolean;
  pride?: Boolean;
  pride_not?: Boolean;
  salvaltion?: Boolean;
  salvaltion_not?: Boolean;
  selfPity?: Boolean;
  selfPity_not?: Boolean;
  suffering?: Boolean;
  suffering_not?: Boolean;
  toxicity?: Boolean;
  toxicity_not?: Boolean;
  trauma?: Boolean;
  trauma_not?: Boolean;
  vulnerability?: Boolean;
  vulnerability_not?: Boolean;
  AND?: HasWhereInput[] | HasWhereInput;
  OR?: HasWhereInput[] | HasWhereInput;
  NOT?: HasWhereInput[] | HasWhereInput;
}

export interface AngerCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface DiscontentCreateManyInput {
  create?: DiscontentCreateInput[] | DiscontentCreateInput;
  connect?: DiscontentWhereUniqueInput[] | DiscontentWhereUniqueInput;
}

export interface AngerUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface InventoryCreateInput {
  id?: ID_Input;
  defect?: DefectCreateManyInput;
  discontent?: DiscontentCreateManyInput;
  resentment?: ResentmentCreateManyInput;
  obsession?: ObsessionCreateManyInput;
  experience?: ExperienceCreateManyInput;
  strength?: StrengthCreateManyInput;
  hope?: HopeCreateManyInput;
}

export interface AngerUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface InfectionUpdateInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface ArmorCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ImpatienceUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface ArmorUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface HopeUpdateInput {
  salvation?: SalvationUpdateManyInput;
  fun?: FunUpdateManyInput;
  joy?: JoyUpdateManyInput;
}

export interface ArmorUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface HonorUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface BodyCreateInput {
  id?: ID_Input;
  brain?: BrainCreateManyInput;
  face?: FaceCreateManyInput;
  mouth?: MouthCreateManyInput;
  soul?: SoulCreateManyInput;
  heart?: HeartCreateManyInput;
  sternum?: SternumCreateManyInput;
  gut?: GutCreateManyInput;
}

export interface CharactersUpdateDataInput {
  congregant?: CongregantUpdateOneInput;
  genie?: GenieUpdateOneInput;
  guardian?: GuardianUpdateOneInput;
  martyr?: MartyrUpdateOneInput;
  paladin?: PaladinUpdateOneInput;
  seeker?: SeekerUpdateOneInput;
  self?: SelfUpdateOneInput;
  smith?: SmithUpdateOneInput;
  summoner?: SummonerUpdateOneInput;
  victim?: VictimUpdateOneInput;
  volunteer?: VolunteerUpdateOneInput;
}

export interface BrainCreateManyInput {
  create?: BrainCreateInput[] | BrainCreateInput;
  connect?: BrainWhereUniqueInput[] | BrainWhereUniqueInput;
}

export interface FeelingUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface BrainCreateInput {
  id?: ID_Input;
  anger?: AngerCreateManyInput;
  fear?: FearCreateManyInput;
  pride?: PrideCreateManyInput;
  selfPity?: SelfPityCreateManyInput;
}

export interface JoyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolveAt?: DateTimeInput;
  resolveAt_not?: DateTimeInput;
  resolveAt_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_lt?: DateTimeInput;
  resolveAt_lte?: DateTimeInput;
  resolveAt_gt?: DateTimeInput;
  resolveAt_gte?: DateTimeInput;
  AND?: JoyWhereInput[] | JoyWhereInput;
  OR?: JoyWhereInput[] | JoyWhereInput;
  NOT?: JoyWhereInput[] | JoyWhereInput;
}

export interface AngerCreateManyInput {
  create?: AngerCreateInput[] | AngerCreateInput;
  connect?: AngerWhereUniqueInput[] | AngerWhereUniqueInput;
}

export interface FeelingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: FeelingScalarWhereInput[] | FeelingScalarWhereInput;
  OR?: FeelingScalarWhereInput[] | FeelingScalarWhereInput;
  NOT?: FeelingScalarWhereInput[] | FeelingScalarWhereInput;
}

export interface FearCreateManyInput {
  create?: FearCreateInput[] | FearCreateInput;
  connect?: FearWhereUniqueInput[] | FearWhereUniqueInput;
}

export interface PrayerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  process?: ProcessWhereInput;
  path?: PathWhereInput;
  AND?: PrayerWhereInput[] | PrayerWhereInput;
  OR?: PrayerWhereInput[] | PrayerWhereInput;
  NOT?: PrayerWhereInput[] | PrayerWhereInput;
}

export interface FearCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface PathWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  defect?: DefectWhereInput;
  discontent?: DiscontentWhereInput;
  resentment?: ResentmentWhereInput;
  obsession?: ObsessionWhereInput;
  experience?: ExperienceWhereInput;
  strength?: StrengthWhereInput;
  hope?: HopeWhereInput;
  AND?: PathWhereInput[] | PathWhereInput;
  OR?: PathWhereInput[] | PathWhereInput;
  NOT?: PathWhereInput[] | PathWhereInput;
}

export interface PrideCreateManyInput {
  create?: PrideCreateInput[] | PrideCreateInput;
  connect?: PrideWhereUniqueInput[] | PrideWhereUniqueInput;
}

export interface ObsessionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  suffering_every?: SufferingWhereInput;
  suffering_some?: SufferingWhereInput;
  suffering_none?: SufferingWhereInput;
  loyalty_every?: LoyaltyWhereInput;
  loyalty_some?: LoyaltyWhereInput;
  loyalty_none?: LoyaltyWhereInput;
  honor_every?: HonorWhereInput;
  honor_some?: HonorWhereInput;
  honor_none?: HonorWhereInput;
  vulnerability_every?: VulnerabilityWhereInput;
  vulnerability_some?: VulnerabilityWhereInput;
  vulnerability_none?: VulnerabilityWhereInput;
  AND?: ObsessionWhereInput[] | ObsessionWhereInput;
  OR?: ObsessionWhereInput[] | ObsessionWhereInput;
  NOT?: ObsessionWhereInput[] | ObsessionWhereInput;
}

export interface PrideCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface HopeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  salvation_every?: SalvationWhereInput;
  salvation_some?: SalvationWhereInput;
  salvation_none?: SalvationWhereInput;
  fun_every?: FunWhereInput;
  fun_some?: FunWhereInput;
  fun_none?: FunWhereInput;
  joy_every?: JoyWhereInput;
  joy_some?: JoyWhereInput;
  joy_none?: JoyWhereInput;
  AND?: HopeWhereInput[] | HopeWhereInput;
  OR?: HopeWhereInput[] | HopeWhereInput;
  NOT?: HopeWhereInput[] | HopeWhereInput;
}

export interface SelfPityCreateManyInput {
  create?: SelfPityCreateInput[] | SelfPityCreateInput;
  connect?: SelfPityWhereUniqueInput[] | SelfPityWhereUniqueInput;
}

export interface FeelingUpsertWithWhereUniqueNestedInput {
  where: FeelingWhereUniqueInput;
  update: FeelingUpdateDataInput;
  create: FeelingCreateInput;
}

export interface SelfPityCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface FeelingUpdateWithWhereUniqueNestedInput {
  where: FeelingWhereUniqueInput;
  data: FeelingUpdateDataInput;
}

export interface FaceCreateManyInput {
  create?: FaceCreateInput[] | FaceCreateInput;
  connect?: FaceWhereUniqueInput[] | FaceWhereUniqueInput;
}

export interface FeelingUpdateManyInput {
  create?: FeelingCreateInput[] | FeelingCreateInput;
  update?:
    | FeelingUpdateWithWhereUniqueNestedInput[]
    | FeelingUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FeelingUpsertWithWhereUniqueNestedInput[]
    | FeelingUpsertWithWhereUniqueNestedInput;
  delete?: FeelingWhereUniqueInput[] | FeelingWhereUniqueInput;
  connect?: FeelingWhereUniqueInput[] | FeelingWhereUniqueInput;
  set?: FeelingWhereUniqueInput[] | FeelingWhereUniqueInput;
  disconnect?: FeelingWhereUniqueInput[] | FeelingWhereUniqueInput;
  deleteMany?: FeelingScalarWhereInput[] | FeelingScalarWhereInput;
  updateMany?:
    | FeelingUpdateManyWithWhereNestedInput[]
    | FeelingUpdateManyWithWhereNestedInput;
}

export interface FaceCreateInput {
  id?: ID_Input;
  anger?: AngerCreateManyInput;
  fear?: FearCreateManyInput;
  pride?: PrideCreateManyInput;
  selfPity?: SelfPityCreateManyInput;
}

export interface PathUpsertNestedInput {
  update: PathUpdateDataInput;
  create: PathCreateInput;
}

export interface MouthCreateManyInput {
  create?: MouthCreateInput[] | MouthCreateInput;
  connect?: MouthWhereUniqueInput[] | MouthWhereUniqueInput;
}

export interface StrengthSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StrengthWhereInput;
  AND?: StrengthSubscriptionWhereInput[] | StrengthSubscriptionWhereInput;
  OR?: StrengthSubscriptionWhereInput[] | StrengthSubscriptionWhereInput;
  NOT?: StrengthSubscriptionWhereInput[] | StrengthSubscriptionWhereInput;
}

export interface MouthCreateInput {
  id?: ID_Input;
  anger?: AngerCreateManyInput;
  fear?: FearCreateManyInput;
  pride?: PrideCreateManyInput;
  selfPity?: SelfPityCreateManyInput;
}

export interface JoyUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface SoulCreateManyInput {
  create?: SoulCreateInput[] | SoulCreateInput;
  connect?: SoulWhereUniqueInput[] | SoulWhereUniqueInput;
}

export type ImpatienceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SoulCreateInput {
  id?: ID_Input;
  vulnerability?: VulnerabilityCreateManyInput;
  acceptance?: AcceptanceCreateManyInput;
}

export interface JoyUpsertWithWhereUniqueNestedInput {
  where: JoyWhereUniqueInput;
  update: JoyUpdateDataInput;
  create: JoyCreateInput;
}

export interface VulnerabilityCreateManyInput {
  create?: VulnerabilityCreateInput[] | VulnerabilityCreateInput;
  connect?: VulnerabilityWhereUniqueInput[] | VulnerabilityWhereUniqueInput;
}

export type InfectionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VulnerabilityCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface JoyUpdateManyInput {
  create?: JoyCreateInput[] | JoyCreateInput;
  update?:
    | JoyUpdateWithWhereUniqueNestedInput[]
    | JoyUpdateWithWhereUniqueNestedInput;
  upsert?:
    | JoyUpsertWithWhereUniqueNestedInput[]
    | JoyUpsertWithWhereUniqueNestedInput;
  delete?: JoyWhereUniqueInput[] | JoyWhereUniqueInput;
  connect?: JoyWhereUniqueInput[] | JoyWhereUniqueInput;
  set?: JoyWhereUniqueInput[] | JoyWhereUniqueInput;
  disconnect?: JoyWhereUniqueInput[] | JoyWhereUniqueInput;
  deleteMany?: JoyScalarWhereInput[] | JoyScalarWhereInput;
  updateMany?:
    | JoyUpdateManyWithWhereNestedInput[]
    | JoyUpdateManyWithWhereNestedInput;
}

export interface AcceptanceCreateManyInput {
  create?: AcceptanceCreateInput[] | AcceptanceCreateInput;
  connect?: AcceptanceWhereUniqueInput[] | AcceptanceWhereUniqueInput;
}

export type InventoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HeartCreateManyInput {
  create?: HeartCreateInput[] | HeartCreateInput;
  connect?: HeartWhereUniqueInput[] | HeartWhereUniqueInput;
}

export interface SupportWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  courage_every?: CourageWhereInput;
  courage_some?: CourageWhereInput;
  courage_none?: CourageWhereInput;
  compassion_every?: CompassionWhereInput;
  compassion_some?: CompassionWhereInput;
  compassion_none?: CompassionWhereInput;
  AND?: SupportWhereInput[] | SupportWhereInput;
  OR?: SupportWhereInput[] | SupportWhereInput;
  NOT?: SupportWhereInput[] | SupportWhereInput;
}

export interface HeartCreateInput {
  id?: ID_Input;
  anger?: AngerCreateManyInput;
  fear?: FearCreateManyInput;
  pride?: PrideCreateManyInput;
  selfPity?: SelfPityCreateManyInput;
}

export interface SummonerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SummonerWhereInput;
  AND?: SummonerSubscriptionWhereInput[] | SummonerSubscriptionWhereInput;
  OR?: SummonerSubscriptionWhereInput[] | SummonerSubscriptionWhereInput;
  NOT?: SummonerSubscriptionWhereInput[] | SummonerSubscriptionWhereInput;
}

export interface SternumCreateManyInput {
  create?: SternumCreateInput[] | SternumCreateInput;
  connect?: SternumWhereUniqueInput[] | SternumWhereUniqueInput;
}

export interface SupportSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SupportWhereInput;
  AND?: SupportSubscriptionWhereInput[] | SupportSubscriptionWhereInput;
  OR?: SupportSubscriptionWhereInput[] | SupportSubscriptionWhereInput;
  NOT?: SupportSubscriptionWhereInput[] | SupportSubscriptionWhereInput;
}

export interface SternumCreateInput {
  id?: ID_Input;
  anger?: AngerCreateManyInput;
  fear?: FearCreateManyInput;
  pride?: PrideCreateManyInput;
  selfPity?: SelfPityCreateManyInput;
}

export interface FunUpsertWithWhereUniqueNestedInput {
  where: FunWhereUniqueInput;
  update: FunUpdateDataInput;
  create: FunCreateInput;
}

export interface GutCreateManyInput {
  create?: GutCreateInput[] | GutCreateInput;
  connect?: GutWhereUniqueInput[] | GutWhereUniqueInput;
}

export type IrritabilityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GutCreateInput {
  id?: ID_Input;
  anger?: AngerCreateManyInput;
  fear?: FearCreateManyInput;
  pride?: PrideCreateManyInput;
  selfPity?: SelfPityCreateManyInput;
}

export interface FunUpdateManyInput {
  create?: FunCreateInput[] | FunCreateInput;
  update?:
    | FunUpdateWithWhereUniqueNestedInput[]
    | FunUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FunUpsertWithWhereUniqueNestedInput[]
    | FunUpsertWithWhereUniqueNestedInput;
  delete?: FunWhereUniqueInput[] | FunWhereUniqueInput;
  connect?: FunWhereUniqueInput[] | FunWhereUniqueInput;
  set?: FunWhereUniqueInput[] | FunWhereUniqueInput;
  disconnect?: FunWhereUniqueInput[] | FunWhereUniqueInput;
  deleteMany?: FunScalarWhereInput[] | FunScalarWhereInput;
  updateMany?:
    | FunUpdateManyWithWhereNestedInput[]
    | FunUpdateManyWithWhereNestedInput;
}

export interface BodyUpdateInput {
  brain?: BrainUpdateManyInput;
  face?: FaceUpdateManyInput;
  mouth?: MouthUpdateManyInput;
  soul?: SoulUpdateManyInput;
  heart?: HeartUpdateManyInput;
  sternum?: SternumUpdateManyInput;
  gut?: GutUpdateManyInput;
}

export type JoyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BrainUpdateManyInput {
  create?: BrainCreateInput[] | BrainCreateInput;
  update?:
    | BrainUpdateWithWhereUniqueNestedInput[]
    | BrainUpdateWithWhereUniqueNestedInput;
  upsert?:
    | BrainUpsertWithWhereUniqueNestedInput[]
    | BrainUpsertWithWhereUniqueNestedInput;
  delete?: BrainWhereUniqueInput[] | BrainWhereUniqueInput;
  connect?: BrainWhereUniqueInput[] | BrainWhereUniqueInput;
  set?: BrainWhereUniqueInput[] | BrainWhereUniqueInput;
  disconnect?: BrainWhereUniqueInput[] | BrainWhereUniqueInput;
  deleteMany?: BrainScalarWhereInput[] | BrainScalarWhereInput;
}

export interface StrengthUpsertNestedInput {
  update: StrengthUpdateDataInput;
  create: StrengthCreateInput;
}

export interface BrainUpdateWithWhereUniqueNestedInput {
  where: BrainWhereUniqueInput;
  data: BrainUpdateDataInput;
}

export type LoveWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BrainUpdateDataInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface LoveWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  vulnerability_every?: VulnerabilityWhereInput;
  vulnerability_some?: VulnerabilityWhereInput;
  vulnerability_none?: VulnerabilityWhereInput;
  acceptance_every?: AcceptanceWhereInput;
  acceptance_some?: AcceptanceWhereInput;
  acceptance_none?: AcceptanceWhereInput;
  AND?: LoveWhereInput[] | LoveWhereInput;
  OR?: LoveWhereInput[] | LoveWhereInput;
  NOT?: LoveWhereInput[] | LoveWhereInput;
}

export interface AngerUpdateManyInput {
  create?: AngerCreateInput[] | AngerCreateInput;
  update?:
    | AngerUpdateWithWhereUniqueNestedInput[]
    | AngerUpdateWithWhereUniqueNestedInput;
  upsert?:
    | AngerUpsertWithWhereUniqueNestedInput[]
    | AngerUpsertWithWhereUniqueNestedInput;
  delete?: AngerWhereUniqueInput[] | AngerWhereUniqueInput;
  connect?: AngerWhereUniqueInput[] | AngerWhereUniqueInput;
  set?: AngerWhereUniqueInput[] | AngerWhereUniqueInput;
  disconnect?: AngerWhereUniqueInput[] | AngerWhereUniqueInput;
  deleteMany?: AngerScalarWhereInput[] | AngerScalarWhereInput;
  updateMany?:
    | AngerUpdateManyWithWhereNestedInput[]
    | AngerUpdateManyWithWhereNestedInput;
}

export interface ExperienceUpsertNestedInput {
  update: ExperienceUpdateDataInput;
  create: ExperienceCreateInput;
}

export interface AngerUpdateWithWhereUniqueNestedInput {
  where: AngerWhereUniqueInput;
  data: AngerUpdateDataInput;
}

export interface ExperienceUpdateOneInput {
  create?: ExperienceCreateInput;
  update?: ExperienceUpdateDataInput;
  upsert?: ExperienceUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExperienceWhereUniqueInput;
}

export interface AngerUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ObsessionUpsertNestedInput {
  update: ObsessionUpdateDataInput;
  create: ObsessionCreateInput;
}

export interface AngerUpsertWithWhereUniqueNestedInput {
  where: AngerWhereUniqueInput;
  update: AngerUpdateDataInput;
  create: AngerCreateInput;
}

export interface ObsessionUpdateOneInput {
  create?: ObsessionCreateInput;
  update?: ObsessionUpdateDataInput;
  upsert?: ObsessionUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ObsessionWhereUniqueInput;
}

export interface AngerScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: AngerScalarWhereInput[] | AngerScalarWhereInput;
  OR?: AngerScalarWhereInput[] | AngerScalarWhereInput;
  NOT?: AngerScalarWhereInput[] | AngerScalarWhereInput;
}

export interface CourageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: CourageWhereInput[] | CourageWhereInput;
  OR?: CourageWhereInput[] | CourageWhereInput;
  NOT?: CourageWhereInput[] | CourageWhereInput;
}

export interface AngerUpdateManyWithWhereNestedInput {
  where: AngerScalarWhereInput;
  data: AngerUpdateManyDataInput;
}

export interface ResentmentUpdateDataInput {
  anger?: AngerUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
}

export interface AngerUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type MindWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FearUpdateManyInput {
  create?: FearCreateInput[] | FearCreateInput;
  update?:
    | FearUpdateWithWhereUniqueNestedInput[]
    | FearUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FearUpsertWithWhereUniqueNestedInput[]
    | FearUpsertWithWhereUniqueNestedInput;
  delete?: FearWhereUniqueInput[] | FearWhereUniqueInput;
  connect?: FearWhereUniqueInput[] | FearWhereUniqueInput;
  set?: FearWhereUniqueInput[] | FearWhereUniqueInput;
  disconnect?: FearWhereUniqueInput[] | FearWhereUniqueInput;
  deleteMany?: FearScalarWhereInput[] | FearScalarWhereInput;
  updateMany?:
    | FearUpdateManyWithWhereNestedInput[]
    | FearUpdateManyWithWhereNestedInput;
}

export interface MindWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  vulnerability_every?: VulnerabilityWhereInput;
  vulnerability_some?: VulnerabilityWhereInput;
  vulnerability_none?: VulnerabilityWhereInput;
  acceptance_every?: AcceptanceWhereInput;
  acceptance_some?: AcceptanceWhereInput;
  acceptance_none?: AcceptanceWhereInput;
  AND?: MindWhereInput[] | MindWhereInput;
  OR?: MindWhereInput[] | MindWhereInput;
  NOT?: MindWhereInput[] | MindWhereInput;
}

export interface FearUpdateWithWhereUniqueNestedInput {
  where: FearWhereUniqueInput;
  data: FearUpdateDataInput;
}

export interface DiscontentUpdateDataInput {
  irritability?: IrritabilityUpdateManyInput;
  impatience?: ImpatienceUpdateManyInput;
}

export interface FearUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface DefectUpsertNestedInput {
  update: DefectUpdateDataInput;
  create: DefectCreateInput;
}

export interface FearUpsertWithWhereUniqueNestedInput {
  where: FearWhereUniqueInput;
  update: FearUpdateDataInput;
  create: FearCreateInput;
}

export interface DefectUpdateDataInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
  suffering?: SufferingUpdateManyInput;
}

export interface FearScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: FearScalarWhereInput[] | FearScalarWhereInput;
  OR?: FearScalarWhereInput[] | FearScalarWhereInput;
  NOT?: FearScalarWhereInput[] | FearScalarWhereInput;
}

export interface PathUpdateDataInput {
  defect?: DefectUpdateOneInput;
  discontent?: DiscontentUpdateOneInput;
  resentment?: ResentmentUpdateOneInput;
  obsession?: ObsessionUpdateOneInput;
  experience?: ExperienceUpdateOneInput;
  strength?: StrengthUpdateOneInput;
  hope?: HopeUpdateOneInput;
}

export interface FearUpdateManyWithWhereNestedInput {
  where: FearScalarWhereInput;
  data: FearUpdateManyDataInput;
}

export interface PathUpdateOneInput {
  create?: PathCreateInput;
  update?: PathUpdateDataInput;
  upsert?: PathUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PathWhereUniqueInput;
}

export interface FearUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface WishUpsertNestedInput {
  update: WishUpdateDataInput;
  create: WishCreateInput;
}

export interface PrideUpdateManyInput {
  create?: PrideCreateInput[] | PrideCreateInput;
  update?:
    | PrideUpdateWithWhereUniqueNestedInput[]
    | PrideUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PrideUpsertWithWhereUniqueNestedInput[]
    | PrideUpsertWithWhereUniqueNestedInput;
  delete?: PrideWhereUniqueInput[] | PrideWhereUniqueInput;
  connect?: PrideWhereUniqueInput[] | PrideWhereUniqueInput;
  set?: PrideWhereUniqueInput[] | PrideWhereUniqueInput;
  disconnect?: PrideWhereUniqueInput[] | PrideWhereUniqueInput;
  deleteMany?: PrideScalarWhereInput[] | PrideScalarWhereInput;
  updateMany?:
    | PrideUpdateManyWithWhereNestedInput[]
    | PrideUpdateManyWithWhereNestedInput;
}

export interface WishUpdateOneInput {
  create?: WishCreateInput;
  update?: WishUpdateDataInput;
  upsert?: WishUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: WishWhereUniqueInput;
}

export interface PrideUpdateWithWhereUniqueNestedInput {
  where: PrideWhereUniqueInput;
  data: PrideUpdateDataInput;
}

export interface VirtueUpdateOneInput {
  create?: VirtueCreateInput;
  update?: VirtueUpdateDataInput;
  upsert?: VirtueUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VirtueWhereUniqueInput;
}

export interface PrideUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface StigmataUpsertNestedInput {
  update: StigmataUpdateDataInput;
  create: StigmataCreateInput;
}

export interface PrideUpsertWithWhereUniqueNestedInput {
  where: PrideWhereUniqueInput;
  update: PrideUpdateDataInput;
  create: PrideCreateInput;
}

export interface ShieldUpsertNestedInput {
  update: ShieldUpdateDataInput;
  create: ShieldCreateInput;
}

export interface PrideScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: PrideScalarWhereInput[] | PrideScalarWhereInput;
  OR?: PrideScalarWhereInput[] | PrideScalarWhereInput;
  NOT?: PrideScalarWhereInput[] | PrideScalarWhereInput;
}

export interface ShieldUpdateOneInput {
  create?: ShieldCreateInput;
  update?: ShieldUpdateDataInput;
  upsert?: ShieldUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ShieldWhereUniqueInput;
}

export interface PrideUpdateManyWithWhereNestedInput {
  where: PrideScalarWhereInput;
  data: PrideUpdateManyDataInput;
}

export interface OathUpdateOneInput {
  create?: OathCreateInput;
  update?: OathUpdateDataInput;
  upsert?: OathUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: OathWhereUniqueInput;
}

export interface PrideUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface TowerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TowerWhereInput;
  AND?: TowerSubscriptionWhereInput[] | TowerSubscriptionWhereInput;
  OR?: TowerSubscriptionWhereInput[] | TowerSubscriptionWhereInput;
  NOT?: TowerSubscriptionWhereInput[] | TowerSubscriptionWhereInput;
}

export interface SelfPityUpdateManyInput {
  create?: SelfPityCreateInput[] | SelfPityCreateInput;
  update?:
    | SelfPityUpdateWithWhereUniqueNestedInput[]
    | SelfPityUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SelfPityUpsertWithWhereUniqueNestedInput[]
    | SelfPityUpsertWithWhereUniqueNestedInput;
  delete?: SelfPityWhereUniqueInput[] | SelfPityWhereUniqueInput;
  connect?: SelfPityWhereUniqueInput[] | SelfPityWhereUniqueInput;
  set?: SelfPityWhereUniqueInput[] | SelfPityWhereUniqueInput;
  disconnect?: SelfPityWhereUniqueInput[] | SelfPityWhereUniqueInput;
  deleteMany?: SelfPityScalarWhereInput[] | SelfPityScalarWhereInput;
  updateMany?:
    | SelfPityUpdateManyWithWhereNestedInput[]
    | SelfPityUpdateManyWithWhereNestedInput;
}

export interface ConstructUpdateOneInput {
  create?: ConstructCreateInput;
  update?: ConstructUpdateDataInput;
  upsert?: ConstructUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ConstructWhereUniqueInput;
}

export interface SelfPityUpdateWithWhereUniqueNestedInput {
  where: SelfPityWhereUniqueInput;
  data: SelfPityUpdateDataInput;
}

export type PathWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SelfPityUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface BodyUpdateOneInput {
  create?: BodyCreateInput;
  update?: BodyUpdateDataInput;
  upsert?: BodyUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: BodyWhereUniqueInput;
}

export interface SelfPityUpsertWithWhereUniqueNestedInput {
  where: SelfPityWhereUniqueInput;
  update: SelfPityUpdateDataInput;
  create: SelfPityCreateInput;
}

export interface AfflictionUpdateOneInput {
  create?: AfflictionCreateInput;
  update?: AfflictionUpdateDataInput;
  upsert?: AfflictionUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: AfflictionWhereUniqueInput;
}

export interface SelfPityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: SelfPityScalarWhereInput[] | SelfPityScalarWhereInput;
  OR?: SelfPityScalarWhereInput[] | SelfPityScalarWhereInput;
  NOT?: SelfPityScalarWhereInput[] | SelfPityScalarWhereInput;
}

export interface ActUpsertNestedInput {
  update: ActUpdateDataInput;
  create: ActCreateInput;
}

export interface SelfPityUpdateManyWithWhereNestedInput {
  where: SelfPityScalarWhereInput;
  data: SelfPityUpdateManyDataInput;
}

export interface ProcessUpdateDataInput {
  act?: ActUpdateOneInput;
  affliction?: AfflictionUpdateOneInput;
  body?: BodyUpdateOneInput;
  construct?: ConstructUpdateOneInput;
  oath?: OathUpdateOneInput;
  shield?: ShieldUpdateOneInput;
  stigmata?: StigmataUpdateOneInput;
  virtue?: VirtueUpdateOneInput;
  wish?: WishUpdateOneInput;
}

export interface SelfPityUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ToxicitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ToxicityWhereInput;
  AND?: ToxicitySubscriptionWhereInput[] | ToxicitySubscriptionWhereInput;
  OR?: ToxicitySubscriptionWhereInput[] | ToxicitySubscriptionWhereInput;
  NOT?: ToxicitySubscriptionWhereInput[] | ToxicitySubscriptionWhereInput;
}

export interface BrainUpsertWithWhereUniqueNestedInput {
  where: BrainWhereUniqueInput;
  update: BrainUpdateDataInput;
  create: BrainCreateInput;
}

export interface PrayerUpdateDataInput {
  process?: ProcessUpdateOneInput;
  path?: PathUpdateOneInput;
}

export interface BrainScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: BrainScalarWhereInput[] | BrainScalarWhereInput;
  OR?: BrainScalarWhereInput[] | BrainScalarWhereInput;
  NOT?: BrainScalarWhereInput[] | BrainScalarWhereInput;
}

export type PrideWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FaceUpdateManyInput {
  create?: FaceCreateInput[] | FaceCreateInput;
  update?:
    | FaceUpdateWithWhereUniqueNestedInput[]
    | FaceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | FaceUpsertWithWhereUniqueNestedInput[]
    | FaceUpsertWithWhereUniqueNestedInput;
  delete?: FaceWhereUniqueInput[] | FaceWhereUniqueInput;
  connect?: FaceWhereUniqueInput[] | FaceWhereUniqueInput;
  set?: FaceWhereUniqueInput[] | FaceWhereUniqueInput;
  disconnect?: FaceWhereUniqueInput[] | FaceWhereUniqueInput;
  deleteMany?: FaceScalarWhereInput[] | FaceScalarWhereInput;
}

export interface CharactersCreateOneInput {
  create?: CharactersCreateInput;
  connect?: CharactersWhereUniqueInput;
}

export interface FaceUpdateWithWhereUniqueNestedInput {
  where: FaceWhereUniqueInput;
  data: FaceUpdateDataInput;
}

export type ProcessWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FaceUpdateDataInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface JoyCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface FaceUpsertWithWhereUniqueNestedInput {
  where: FaceWhereUniqueInput;
  update: FaceUpdateDataInput;
  create: FaceCreateInput;
}

export interface FunCreateManyInput {
  create?: FunCreateInput[] | FunCreateInput;
  connect?: FunWhereUniqueInput[] | FunWhereUniqueInput;
}

export interface FaceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: FaceScalarWhereInput[] | FaceScalarWhereInput;
  OR?: FaceScalarWhereInput[] | FaceScalarWhereInput;
  NOT?: FaceScalarWhereInput[] | FaceScalarWhereInput;
}

export interface HopeCreateInput {
  id?: ID_Input;
  salvation?: SalvationCreateManyInput;
  fun?: FunCreateManyInput;
  joy?: JoyCreateManyInput;
}

export interface MouthUpdateManyInput {
  create?: MouthCreateInput[] | MouthCreateInput;
  update?:
    | MouthUpdateWithWhereUniqueNestedInput[]
    | MouthUpdateWithWhereUniqueNestedInput;
  upsert?:
    | MouthUpsertWithWhereUniqueNestedInput[]
    | MouthUpsertWithWhereUniqueNestedInput;
  delete?: MouthWhereUniqueInput[] | MouthWhereUniqueInput;
  connect?: MouthWhereUniqueInput[] | MouthWhereUniqueInput;
  set?: MouthWhereUniqueInput[] | MouthWhereUniqueInput;
  disconnect?: MouthWhereUniqueInput[] | MouthWhereUniqueInput;
  deleteMany?: MouthScalarWhereInput[] | MouthScalarWhereInput;
}

export interface StrengthCreateInput {
  id?: ID_Input;
  armor?: ArmorCreateManyInput;
  boundary?: BoundaryCreateManyInput;
  loyalty?: LoyaltyCreateManyInput;
  honor?: HonorCreateManyInput;
}

export interface MouthUpdateWithWhereUniqueNestedInput {
  where: MouthWhereUniqueInput;
  data: MouthUpdateDataInput;
}

export interface StrengthCreateOneInput {
  create?: StrengthCreateInput;
  connect?: StrengthWhereUniqueInput;
}

export interface MouthUpdateDataInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface ObsessionCreateInput {
  id?: ID_Input;
  suffering?: SufferingCreateManyInput;
  loyalty?: LoyaltyCreateManyInput;
  honor?: HonorCreateManyInput;
  vulnerability?: VulnerabilityCreateManyInput;
}

export interface MouthUpsertWithWhereUniqueNestedInput {
  where: MouthWhereUniqueInput;
  update: MouthUpdateDataInput;
  create: MouthCreateInput;
}

export interface ObsessionCreateOneInput {
  create?: ObsessionCreateInput;
  connect?: ObsessionWhereUniqueInput;
}

export interface MouthScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: MouthScalarWhereInput[] | MouthScalarWhereInput;
  OR?: MouthScalarWhereInput[] | MouthScalarWhereInput;
  NOT?: MouthScalarWhereInput[] | MouthScalarWhereInput;
}

export interface ResentmentCreateOneInput {
  create?: ResentmentCreateInput;
  connect?: ResentmentWhereUniqueInput;
}

export interface SoulUpdateManyInput {
  create?: SoulCreateInput[] | SoulCreateInput;
  update?:
    | SoulUpdateWithWhereUniqueNestedInput[]
    | SoulUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SoulUpsertWithWhereUniqueNestedInput[]
    | SoulUpsertWithWhereUniqueNestedInput;
  delete?: SoulWhereUniqueInput[] | SoulWhereUniqueInput;
  connect?: SoulWhereUniqueInput[] | SoulWhereUniqueInput;
  set?: SoulWhereUniqueInput[] | SoulWhereUniqueInput;
  disconnect?: SoulWhereUniqueInput[] | SoulWhereUniqueInput;
  deleteMany?: SoulScalarWhereInput[] | SoulScalarWhereInput;
}

export interface DiscontentCreateOneInput {
  create?: DiscontentCreateInput;
  connect?: DiscontentWhereUniqueInput;
}

export interface SoulUpdateWithWhereUniqueNestedInput {
  where: SoulWhereUniqueInput;
  data: SoulUpdateDataInput;
}

export interface PathCreateInput {
  id?: ID_Input;
  defect?: DefectCreateOneInput;
  discontent?: DiscontentCreateOneInput;
  resentment?: ResentmentCreateOneInput;
  obsession?: ObsessionCreateOneInput;
  experience?: ExperienceCreateOneInput;
  strength?: StrengthCreateOneInput;
  hope?: HopeCreateOneInput;
}

export interface SoulUpdateDataInput {
  vulnerability?: VulnerabilityUpdateManyInput;
  acceptance?: AcceptanceUpdateManyInput;
}

export interface PathCreateOneInput {
  create?: PathCreateInput;
  connect?: PathWhereUniqueInput;
}

export interface VulnerabilityUpdateManyInput {
  create?: VulnerabilityCreateInput[] | VulnerabilityCreateInput;
  update?:
    | VulnerabilityUpdateWithWhereUniqueNestedInput[]
    | VulnerabilityUpdateWithWhereUniqueNestedInput;
  upsert?:
    | VulnerabilityUpsertWithWhereUniqueNestedInput[]
    | VulnerabilityUpsertWithWhereUniqueNestedInput;
  delete?: VulnerabilityWhereUniqueInput[] | VulnerabilityWhereUniqueInput;
  connect?: VulnerabilityWhereUniqueInput[] | VulnerabilityWhereUniqueInput;
  set?: VulnerabilityWhereUniqueInput[] | VulnerabilityWhereUniqueInput;
  disconnect?: VulnerabilityWhereUniqueInput[] | VulnerabilityWhereUniqueInput;
  deleteMany?: VulnerabilityScalarWhereInput[] | VulnerabilityScalarWhereInput;
  updateMany?:
    | VulnerabilityUpdateManyWithWhereNestedInput[]
    | VulnerabilityUpdateManyWithWhereNestedInput;
}

export interface VirtueCreateOneInput {
  create?: VirtueCreateInput;
  connect?: VirtueWhereUniqueInput;
}

export interface VulnerabilityUpdateWithWhereUniqueNestedInput {
  where: VulnerabilityWhereUniqueInput;
  data: VulnerabilityUpdateDataInput;
}

export interface TremorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TremorWhereInput;
  AND?: TremorSubscriptionWhereInput[] | TremorSubscriptionWhereInput;
  OR?: TremorSubscriptionWhereInput[] | TremorSubscriptionWhereInput;
  NOT?: TremorSubscriptionWhereInput[] | TremorSubscriptionWhereInput;
}

export interface VulnerabilityUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ShieldCreateOneInput {
  create?: ShieldCreateInput;
  connect?: ShieldWhereUniqueInput;
}

export interface VulnerabilityUpsertWithWhereUniqueNestedInput {
  where: VulnerabilityWhereUniqueInput;
  update: VulnerabilityUpdateDataInput;
  create: VulnerabilityCreateInput;
}

export type SelfWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VulnerabilityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: VulnerabilityScalarWhereInput[] | VulnerabilityScalarWhereInput;
  OR?: VulnerabilityScalarWhereInput[] | VulnerabilityScalarWhereInput;
  NOT?: VulnerabilityScalarWhereInput[] | VulnerabilityScalarWhereInput;
}

export interface ConstructCreateOneInput {
  create?: ConstructCreateInput;
  connect?: ConstructWhereUniqueInput;
}

export interface VulnerabilityUpdateManyWithWhereNestedInput {
  where: VulnerabilityScalarWhereInput;
  data: VulnerabilityUpdateManyDataInput;
}

export interface AfflictionCreateOneInput {
  create?: AfflictionCreateInput;
  connect?: AfflictionWhereUniqueInput;
}

export interface VulnerabilityUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ActCreateOneInput {
  create?: ActCreateInput;
  connect?: ActWhereUniqueInput;
}

export interface AcceptanceUpdateManyInput {
  create?: AcceptanceCreateInput[] | AcceptanceCreateInput;
  update?:
    | AcceptanceUpdateWithWhereUniqueNestedInput[]
    | AcceptanceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | AcceptanceUpsertWithWhereUniqueNestedInput[]
    | AcceptanceUpsertWithWhereUniqueNestedInput;
  delete?: AcceptanceWhereUniqueInput[] | AcceptanceWhereUniqueInput;
  connect?: AcceptanceWhereUniqueInput[] | AcceptanceWhereUniqueInput;
  set?: AcceptanceWhereUniqueInput[] | AcceptanceWhereUniqueInput;
  disconnect?: AcceptanceWhereUniqueInput[] | AcceptanceWhereUniqueInput;
  deleteMany?: AcceptanceScalarWhereInput[] | AcceptanceScalarWhereInput;
  updateMany?:
    | AcceptanceUpdateManyWithWhereNestedInput[]
    | AcceptanceUpdateManyWithWhereNestedInput;
}

export interface ProcessCreateOneInput {
  create?: ProcessCreateInput;
  connect?: ProcessWhereUniqueInput;
}

export interface AcceptanceUpdateWithWhereUniqueNestedInput {
  where: AcceptanceWhereUniqueInput;
  data: AcceptanceUpdateDataInput;
}

export interface PrayerCreateInput {
  id?: ID_Input;
  process?: ProcessCreateOneInput;
  path?: PathCreateOneInput;
}

export interface AcceptanceUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface HigherPowerCreateInput {
  id?: ID_Input;
  prayer?: PrayerCreateOneInput;
  inventory?: FeelingCreateManyInput;
  character?: CharactersCreateOneInput;
}

export interface AcceptanceUpsertWithWhereUniqueNestedInput {
  where: AcceptanceWhereUniqueInput;
  update: AcceptanceUpdateDataInput;
  create: AcceptanceCreateInput;
}

export interface HeartUpdateInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface AcceptanceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: AcceptanceScalarWhereInput[] | AcceptanceScalarWhereInput;
  OR?: AcceptanceScalarWhereInput[] | AcceptanceScalarWhereInput;
  NOT?: AcceptanceScalarWhereInput[] | AcceptanceScalarWhereInput;
}

export interface HasUpdateInput {
  defect?: Boolean;
  discontent?: Boolean;
  resentment?: Boolean;
  obsession?: Boolean;
  experience?: Boolean;
  strength?: Boolean;
  hope?: Boolean;
  acceptance?: Boolean;
  anger?: Boolean;
  armor?: Boolean;
  boundary?: Boolean;
  compassion?: Boolean;
  courage?: Boolean;
  fear?: Boolean;
  fun?: Boolean;
  gratitude?: Boolean;
  irritability?: Boolean;
  impatience?: Boolean;
  joy?: Boolean;
  pride?: Boolean;
  salvaltion?: Boolean;
  selfPity?: Boolean;
  suffering?: Boolean;
  toxicity?: Boolean;
  trauma?: Boolean;
  vulnerability?: Boolean;
}

export interface AcceptanceUpdateManyWithWhereNestedInput {
  where: AcceptanceScalarWhereInput;
  data: AcceptanceUpdateManyDataInput;
}

export interface HasCreateInput {
  id?: ID_Input;
  defect?: Boolean;
  discontent?: Boolean;
  resentment?: Boolean;
  obsession?: Boolean;
  experience?: Boolean;
  strength?: Boolean;
  hope?: Boolean;
  acceptance?: Boolean;
  anger?: Boolean;
  armor?: Boolean;
  boundary?: Boolean;
  compassion?: Boolean;
  courage?: Boolean;
  fear?: Boolean;
  fun?: Boolean;
  gratitude?: Boolean;
  irritability?: Boolean;
  impatience?: Boolean;
  joy?: Boolean;
  pride?: Boolean;
  salvaltion?: Boolean;
  selfPity?: Boolean;
  suffering?: Boolean;
  toxicity?: Boolean;
  trauma?: Boolean;
  vulnerability?: Boolean;
}

export interface AcceptanceUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface GuardianUpdateInput {
  construct?: ConstructUpdateManyInput;
}

export interface SoulUpsertWithWhereUniqueNestedInput {
  where: SoulWhereUniqueInput;
  update: SoulUpdateDataInput;
  create: SoulCreateInput;
}

export interface GratitudeUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SoulScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: SoulScalarWhereInput[] | SoulScalarWhereInput;
  OR?: SoulScalarWhereInput[] | SoulScalarWhereInput;
  NOT?: SoulScalarWhereInput[] | SoulScalarWhereInput;
}

export interface VirtueSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VirtueWhereInput;
  AND?: VirtueSubscriptionWhereInput[] | VirtueSubscriptionWhereInput;
  OR?: VirtueSubscriptionWhereInput[] | VirtueSubscriptionWhereInput;
  NOT?: VirtueSubscriptionWhereInput[] | VirtueSubscriptionWhereInput;
}

export interface HeartUpdateManyInput {
  create?: HeartCreateInput[] | HeartCreateInput;
  update?:
    | HeartUpdateWithWhereUniqueNestedInput[]
    | HeartUpdateWithWhereUniqueNestedInput;
  upsert?:
    | HeartUpsertWithWhereUniqueNestedInput[]
    | HeartUpsertWithWhereUniqueNestedInput;
  delete?: HeartWhereUniqueInput[] | HeartWhereUniqueInput;
  connect?: HeartWhereUniqueInput[] | HeartWhereUniqueInput;
  set?: HeartWhereUniqueInput[] | HeartWhereUniqueInput;
  disconnect?: HeartWhereUniqueInput[] | HeartWhereUniqueInput;
  deleteMany?: HeartScalarWhereInput[] | HeartScalarWhereInput;
}

export interface GenieUpdateInput {
  wish?: WishUpdateManyInput;
}

export interface HeartUpdateWithWhereUniqueNestedInput {
  where: HeartWhereUniqueInput;
  data: HeartUpdateDataInput;
}

export type SmithWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HeartUpdateDataInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface GashUpdateInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface HeartUpsertWithWhereUniqueNestedInput {
  where: HeartWhereUniqueInput;
  update: HeartUpdateDataInput;
  create: HeartCreateInput;
}

export interface FunUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface HeartScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: HeartScalarWhereInput[] | HeartScalarWhereInput;
  OR?: HeartScalarWhereInput[] | HeartScalarWhereInput;
  NOT?: HeartScalarWhereInput[] | HeartScalarWhereInput;
}

export interface FunCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface SternumUpdateManyInput {
  create?: SternumCreateInput[] | SternumCreateInput;
  update?:
    | SternumUpdateWithWhereUniqueNestedInput[]
    | SternumUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SternumUpsertWithWhereUniqueNestedInput[]
    | SternumUpsertWithWhereUniqueNestedInput;
  delete?: SternumWhereUniqueInput[] | SternumWhereUniqueInput;
  connect?: SternumWhereUniqueInput[] | SternumWhereUniqueInput;
  set?: SternumWhereUniqueInput[] | SternumWhereUniqueInput;
  disconnect?: SternumWhereUniqueInput[] | SternumWhereUniqueInput;
  deleteMany?: SternumScalarWhereInput[] | SternumScalarWhereInput;
}

export interface FeelingUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SternumUpdateWithWhereUniqueNestedInput {
  where: SternumWhereUniqueInput;
  data: SternumUpdateDataInput;
}

export interface FeelingCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SternumUpdateDataInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface FearUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SternumUpsertWithWhereUniqueNestedInput {
  where: SternumWhereUniqueInput;
  update: SternumUpdateDataInput;
  create: SternumCreateInput;
}

export interface FaceUpdateInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface SternumScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: SternumScalarWhereInput[] | SternumScalarWhereInput;
  OR?: SternumScalarWhereInput[] | SternumScalarWhereInput;
  NOT?: SternumScalarWhereInput[] | SternumScalarWhereInput;
}

export interface GratitudeUpdateManyWithWhereNestedInput {
  where: GratitudeScalarWhereInput;
  data: GratitudeUpdateManyDataInput;
}

export interface GutUpdateManyInput {
  create?: GutCreateInput[] | GutCreateInput;
  update?:
    | GutUpdateWithWhereUniqueNestedInput[]
    | GutUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GutUpsertWithWhereUniqueNestedInput[]
    | GutUpsertWithWhereUniqueNestedInput;
  delete?: GutWhereUniqueInput[] | GutWhereUniqueInput;
  connect?: GutWhereUniqueInput[] | GutWhereUniqueInput;
  set?: GutWhereUniqueInput[] | GutWhereUniqueInput;
  disconnect?: GutWhereUniqueInput[] | GutWhereUniqueInput;
  deleteMany?: GutScalarWhereInput[] | GutScalarWhereInput;
}

export interface GratitudeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: GratitudeScalarWhereInput[] | GratitudeScalarWhereInput;
  OR?: GratitudeScalarWhereInput[] | GratitudeScalarWhereInput;
  NOT?: GratitudeScalarWhereInput[] | GratitudeScalarWhereInput;
}

export interface GutUpdateWithWhereUniqueNestedInput {
  where: GutWhereUniqueInput;
  data: GutUpdateDataInput;
}

export interface GratitudeUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface GutUpdateDataInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface GratitudeUpdateWithWhereUniqueNestedInput {
  where: GratitudeWhereUniqueInput;
  data: GratitudeUpdateDataInput;
}

export interface GutUpsertWithWhereUniqueNestedInput {
  where: GutWhereUniqueInput;
  update: GutUpdateDataInput;
  create: GutCreateInput;
}

export interface ExperienceUpdateInput {
  compassion?: CompassionUpdateManyInput;
  courage?: CourageUpdateManyInput;
  acceptance?: AcceptanceUpdateManyInput;
  vulnerability?: VulnerabilityUpdateManyInput;
  gratitude?: GratitudeUpdateManyInput;
  suffering?: SufferingUpdateManyInput;
}

export interface GutScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: GutScalarWhereInput[] | GutScalarWhereInput;
  OR?: GutScalarWhereInput[] | GutScalarWhereInput;
  NOT?: GutScalarWhereInput[] | GutScalarWhereInput;
}

export interface AcceptanceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: AcceptanceWhereInput[] | AcceptanceWhereInput;
  OR?: AcceptanceWhereInput[] | AcceptanceWhereInput;
  NOT?: AcceptanceWhereInput[] | AcceptanceWhereInput;
}

export interface BoundaryCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface GratitudeCreateManyInput {
  create?: GratitudeCreateInput[] | GratitudeCreateInput;
  connect?: GratitudeWhereUniqueInput[] | GratitudeWhereUniqueInput;
}

export interface BoundaryUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type SupportWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BoundaryUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ImpatienceUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface BrainUpdateInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export type TowerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CampaignCreateInput {
  id?: ID_Input;
  loyalty?: LoyaltyCreateManyInput;
  honor?: HonorCreateManyInput;
}

export interface ImpatienceUpsertWithWhereUniqueNestedInput {
  where: ImpatienceWhereUniqueInput;
  update: ImpatienceUpdateDataInput;
  create: ImpatienceCreateInput;
}

export interface LoyaltyCreateManyInput {
  create?: LoyaltyCreateInput[] | LoyaltyCreateInput;
  connect?: LoyaltyWhereUniqueInput[] | LoyaltyWhereUniqueInput;
}

export type ToxicityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LoyaltyCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ImpatienceUpdateManyInput {
  create?: ImpatienceCreateInput[] | ImpatienceCreateInput;
  update?:
    | ImpatienceUpdateWithWhereUniqueNestedInput[]
    | ImpatienceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ImpatienceUpsertWithWhereUniqueNestedInput[]
    | ImpatienceUpsertWithWhereUniqueNestedInput;
  delete?: ImpatienceWhereUniqueInput[] | ImpatienceWhereUniqueInput;
  connect?: ImpatienceWhereUniqueInput[] | ImpatienceWhereUniqueInput;
  set?: ImpatienceWhereUniqueInput[] | ImpatienceWhereUniqueInput;
  disconnect?: ImpatienceWhereUniqueInput[] | ImpatienceWhereUniqueInput;
  deleteMany?: ImpatienceScalarWhereInput[] | ImpatienceScalarWhereInput;
  updateMany?:
    | ImpatienceUpdateManyWithWhereNestedInput[]
    | ImpatienceUpdateManyWithWhereNestedInput;
}

export interface HonorCreateManyInput {
  create?: HonorCreateInput[] | HonorCreateInput;
  connect?: HonorWhereUniqueInput[] | HonorWhereUniqueInput;
}

export type TraumaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HonorCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface IrritabilityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolveAt?: DateTimeInput;
  resolveAt_not?: DateTimeInput;
  resolveAt_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_lt?: DateTimeInput;
  resolveAt_lte?: DateTimeInput;
  resolveAt_gt?: DateTimeInput;
  resolveAt_gte?: DateTimeInput;
  AND?: IrritabilityScalarWhereInput[] | IrritabilityScalarWhereInput;
  OR?: IrritabilityScalarWhereInput[] | IrritabilityScalarWhereInput;
  NOT?: IrritabilityScalarWhereInput[] | IrritabilityScalarWhereInput;
}

export interface CampaignUpdateInput {
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
}

export type TremorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LoyaltyUpdateManyInput {
  create?: LoyaltyCreateInput[] | LoyaltyCreateInput;
  update?:
    | LoyaltyUpdateWithWhereUniqueNestedInput[]
    | LoyaltyUpdateWithWhereUniqueNestedInput;
  upsert?:
    | LoyaltyUpsertWithWhereUniqueNestedInput[]
    | LoyaltyUpsertWithWhereUniqueNestedInput;
  delete?: LoyaltyWhereUniqueInput[] | LoyaltyWhereUniqueInput;
  connect?: LoyaltyWhereUniqueInput[] | LoyaltyWhereUniqueInput;
  set?: LoyaltyWhereUniqueInput[] | LoyaltyWhereUniqueInput;
  disconnect?: LoyaltyWhereUniqueInput[] | LoyaltyWhereUniqueInput;
  deleteMany?: LoyaltyScalarWhereInput[] | LoyaltyScalarWhereInput;
  updateMany?:
    | LoyaltyUpdateManyWithWhereNestedInput[]
    | LoyaltyUpdateManyWithWhereNestedInput;
}

export interface IrritabilityUpdateWithWhereUniqueNestedInput {
  where: IrritabilityWhereUniqueInput;
  data: IrritabilityUpdateDataInput;
}

export interface LoyaltyUpdateWithWhereUniqueNestedInput {
  where: LoyaltyWhereUniqueInput;
  data: LoyaltyUpdateDataInput;
}

export type VictimWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LoyaltyUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface DiscontentUpdateInput {
  irritability?: IrritabilityUpdateManyInput;
  impatience?: ImpatienceUpdateManyInput;
}

export interface LoyaltyUpsertWithWhereUniqueNestedInput {
  where: LoyaltyWhereUniqueInput;
  update: LoyaltyUpdateDataInput;
  create: LoyaltyCreateInput;
}

export interface ImpatienceCreateManyInput {
  create?: ImpatienceCreateInput[] | ImpatienceCreateInput;
  connect?: ImpatienceWhereUniqueInput[] | ImpatienceWhereUniqueInput;
}

export interface LoyaltyScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: LoyaltyScalarWhereInput[] | LoyaltyScalarWhereInput;
  OR?: LoyaltyScalarWhereInput[] | LoyaltyScalarWhereInput;
  NOT?: LoyaltyScalarWhereInput[] | LoyaltyScalarWhereInput;
}

export interface IrritabilityCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface LoyaltyUpdateManyWithWhereNestedInput {
  where: LoyaltyScalarWhereInput;
  data: LoyaltyUpdateManyDataInput;
}

export interface DiscontentCreateInput {
  id?: ID_Input;
  irritability?: IrritabilityCreateManyInput;
  impatience?: ImpatienceCreateManyInput;
}

export interface LoyaltyUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface WallSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WallWhereInput;
  AND?: WallSubscriptionWhereInput[] | WallSubscriptionWhereInput;
  OR?: WallSubscriptionWhereInput[] | WallSubscriptionWhereInput;
  NOT?: WallSubscriptionWhereInput[] | WallSubscriptionWhereInput;
}

export interface HonorUpdateManyInput {
  create?: HonorCreateInput[] | HonorCreateInput;
  update?:
    | HonorUpdateWithWhereUniqueNestedInput[]
    | HonorUpdateWithWhereUniqueNestedInput;
  upsert?:
    | HonorUpsertWithWhereUniqueNestedInput[]
    | HonorUpsertWithWhereUniqueNestedInput;
  delete?: HonorWhereUniqueInput[] | HonorWhereUniqueInput;
  connect?: HonorWhereUniqueInput[] | HonorWhereUniqueInput;
  set?: HonorWhereUniqueInput[] | HonorWhereUniqueInput;
  disconnect?: HonorWhereUniqueInput[] | HonorWhereUniqueInput;
  deleteMany?: HonorScalarWhereInput[] | HonorScalarWhereInput;
  updateMany?:
    | HonorUpdateManyWithWhereNestedInput[]
    | HonorUpdateManyWithWhereNestedInput;
}

export interface HonorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HonorWhereInput;
  AND?: HonorSubscriptionWhereInput[] | HonorSubscriptionWhereInput;
  OR?: HonorSubscriptionWhereInput[] | HonorSubscriptionWhereInput;
  NOT?: HonorSubscriptionWhereInput[] | HonorSubscriptionWhereInput;
}

export interface HonorUpdateWithWhereUniqueNestedInput {
  where: HonorWhereUniqueInput;
  data: HonorUpdateDataInput;
}

export interface BoundaryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: BoundaryWhereInput[] | BoundaryWhereInput;
  OR?: BoundaryWhereInput[] | BoundaryWhereInput;
  NOT?: BoundaryWhereInput[] | BoundaryWhereInput;
}

export interface HonorUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface GuardianSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GuardianWhereInput;
  AND?: GuardianSubscriptionWhereInput[] | GuardianSubscriptionWhereInput;
  OR?: GuardianSubscriptionWhereInput[] | GuardianSubscriptionWhereInput;
  NOT?: GuardianSubscriptionWhereInput[] | GuardianSubscriptionWhereInput;
}

export interface HonorUpsertWithWhereUniqueNestedInput {
  where: HonorWhereUniqueInput;
  update: HonorUpdateDataInput;
  create: HonorCreateInput;
}

export interface GateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GateWhereInput;
  AND?: GateSubscriptionWhereInput[] | GateSubscriptionWhereInput;
  OR?: GateSubscriptionWhereInput[] | GateSubscriptionWhereInput;
  NOT?: GateSubscriptionWhereInput[] | GateSubscriptionWhereInput;
}

export interface HonorScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: HonorScalarWhereInput[] | HonorScalarWhereInput;
  OR?: HonorScalarWhereInput[] | HonorScalarWhereInput;
  NOT?: HonorScalarWhereInput[] | HonorScalarWhereInput;
}

export interface OathSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: OathWhereInput;
  AND?: OathSubscriptionWhereInput[] | OathSubscriptionWhereInput;
  OR?: OathSubscriptionWhereInput[] | OathSubscriptionWhereInput;
  NOT?: OathSubscriptionWhereInput[] | OathSubscriptionWhereInput;
}

export interface HonorUpdateManyWithWhereNestedInput {
  where: HonorScalarWhereInput;
  data: HonorUpdateManyDataInput;
}

export interface FeelingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FeelingWhereInput;
  AND?: FeelingSubscriptionWhereInput[] | FeelingSubscriptionWhereInput;
  OR?: FeelingSubscriptionWhereInput[] | FeelingSubscriptionWhereInput;
  NOT?: FeelingSubscriptionWhereInput[] | FeelingSubscriptionWhereInput;
}

export interface HonorUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface FaceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FaceWhereInput;
  AND?: FaceSubscriptionWhereInput[] | FaceSubscriptionWhereInput;
  OR?: FaceSubscriptionWhereInput[] | FaceSubscriptionWhereInput;
  NOT?: FaceSubscriptionWhereInput[] | FaceSubscriptionWhereInput;
}

export interface CharactersCreateInput {
  id?: ID_Input;
  congregant?: CongregantCreateOneInput;
  genie?: GenieCreateOneInput;
  guardian?: GuardianCreateOneInput;
  martyr?: MartyrCreateOneInput;
  paladin?: PaladinCreateOneInput;
  seeker?: SeekerCreateOneInput;
  self?: SelfCreateOneInput;
  smith?: SmithCreateOneInput;
  summoner?: SummonerCreateOneInput;
  victim?: VictimCreateOneInput;
  volunteer?: VolunteerCreateOneInput;
}

export interface DiscontentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DiscontentWhereInput;
  AND?: DiscontentSubscriptionWhereInput[] | DiscontentSubscriptionWhereInput;
  OR?: DiscontentSubscriptionWhereInput[] | DiscontentSubscriptionWhereInput;
  NOT?: DiscontentSubscriptionWhereInput[] | DiscontentSubscriptionWhereInput;
}

export interface CongregantCreateOneInput {
  create?: CongregantCreateInput;
  connect?: CongregantWhereUniqueInput;
}

export interface SalvationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: SalvationWhereInput[] | SalvationWhereInput;
  OR?: SalvationWhereInput[] | SalvationWhereInput;
  NOT?: SalvationWhereInput[] | SalvationWhereInput;
}

export interface CongregantCreateInput {
  id?: ID_Input;
}

export interface DefectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DefectWhereInput;
  AND?: DefectSubscriptionWhereInput[] | DefectSubscriptionWhereInput;
  OR?: DefectSubscriptionWhereInput[] | DefectSubscriptionWhereInput;
  NOT?: DefectSubscriptionWhereInput[] | DefectSubscriptionWhereInput;
}

export interface GenieCreateOneInput {
  create?: GenieCreateInput;
  connect?: GenieWhereUniqueInput;
}

export interface ConstructWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  gate_every?: GateWhereInput;
  gate_some?: GateWhereInput;
  gate_none?: GateWhereInput;
  tower_every?: TowerWhereInput;
  tower_some?: TowerWhereInput;
  tower_none?: TowerWhereInput;
  wall_every?: WallWhereInput;
  wall_some?: WallWhereInput;
  wall_none?: WallWhereInput;
  AND?: ConstructWhereInput[] | ConstructWhereInput;
  OR?: ConstructWhereInput[] | ConstructWhereInput;
  NOT?: ConstructWhereInput[] | ConstructWhereInput;
}

export interface GenieCreateInput {
  id?: ID_Input;
  wish?: WishCreateManyInput;
}

export interface PledgeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PledgeWhereInput;
  AND?: PledgeSubscriptionWhereInput[] | PledgeSubscriptionWhereInput;
  OR?: PledgeSubscriptionWhereInput[] | PledgeSubscriptionWhereInput;
  NOT?: PledgeSubscriptionWhereInput[] | PledgeSubscriptionWhereInput;
}

export interface WishCreateManyInput {
  create?: WishCreateInput[] | WishCreateInput;
  connect?: WishWhereUniqueInput[] | WishWhereUniqueInput;
}

export interface PrideSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PrideWhereInput;
  AND?: PrideSubscriptionWhereInput[] | PrideSubscriptionWhereInput;
  OR?: PrideSubscriptionWhereInput[] | PrideSubscriptionWhereInput;
  NOT?: PrideSubscriptionWhereInput[] | PrideSubscriptionWhereInput;
}

export interface WishCreateInput {
  id?: ID_Input;
  dream?: DreamCreateManyInput;
}

export interface ConfusionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ConfusionWhereInput;
  AND?: ConfusionSubscriptionWhereInput[] | ConfusionSubscriptionWhereInput;
  OR?: ConfusionSubscriptionWhereInput[] | ConfusionSubscriptionWhereInput;
  NOT?: ConfusionSubscriptionWhereInput[] | ConfusionSubscriptionWhereInput;
}

export interface DreamCreateManyInput {
  create?: DreamCreateInput[] | DreamCreateInput;
  connect?: DreamWhereUniqueInput[] | DreamWhereUniqueInput;
}

export interface CrownWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  suffering_every?: SufferingWhereInput;
  suffering_some?: SufferingWhereInput;
  suffering_none?: SufferingWhereInput;
  AND?: CrownWhereInput[] | CrownWhereInput;
  OR?: CrownWhereInput[] | CrownWhereInput;
  NOT?: CrownWhereInput[] | CrownWhereInput;
}

export interface DreamCreateInput {
  id?: ID_Input;
  salvation?: SalvationCreateManyInput;
}

export type AngerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SalvationCreateManyInput {
  create?: SalvationCreateInput[] | SalvationCreateInput;
  connect?: SalvationWhereUniqueInput[] | SalvationWhereUniqueInput;
}

export interface SacrificeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SacrificeWhereInput;
  AND?: SacrificeSubscriptionWhereInput[] | SacrificeSubscriptionWhereInput;
  OR?: SacrificeSubscriptionWhereInput[] | SacrificeSubscriptionWhereInput;
  NOT?: SacrificeSubscriptionWhereInput[] | SacrificeSubscriptionWhereInput;
}

export interface SalvationCreateInput {
  id?: ID_Input;
  thought: String;
  character: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface BodySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BodyWhereInput;
  AND?: BodySubscriptionWhereInput[] | BodySubscriptionWhereInput;
  OR?: BodySubscriptionWhereInput[] | BodySubscriptionWhereInput;
  NOT?: BodySubscriptionWhereInput[] | BodySubscriptionWhereInput;
}

export interface GuardianCreateOneInput {
  create?: GuardianCreateInput;
  connect?: GuardianWhereUniqueInput;
}

export interface AfflictionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  scar_every?: ScarWhereInput;
  scar_some?: ScarWhereInput;
  scar_none?: ScarWhereInput;
  gash_every?: GashWhereInput;
  gash_some?: GashWhereInput;
  gash_none?: GashWhereInput;
  infection_every?: InfectionWhereInput;
  infection_some?: InfectionWhereInput;
  infection_none?: InfectionWhereInput;
  tremor_every?: TremorWhereInput;
  tremor_some?: TremorWhereInput;
  tremor_none?: TremorWhereInput;
  nightmare_every?: NightmareWhereInput;
  nightmare_some?: NightmareWhereInput;
  nightmare_none?: NightmareWhereInput;
  delirium_every?: DeliriumWhereInput;
  delirium_some?: DeliriumWhereInput;
  delirium_none?: DeliriumWhereInput;
  AND?: AfflictionWhereInput[] | AfflictionWhereInput;
  OR?: AfflictionWhereInput[] | AfflictionWhereInput;
  NOT?: AfflictionWhereInput[] | AfflictionWhereInput;
}

export interface GuardianCreateInput {
  id?: ID_Input;
  construct?: ConstructCreateManyInput;
}

export interface DeliriumWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  trauma_every?: TraumaWhereInput;
  trauma_some?: TraumaWhereInput;
  trauma_none?: TraumaWhereInput;
  toxicity_every?: ToxicityWhereInput;
  toxicity_some?: ToxicityWhereInput;
  toxicity_none?: ToxicityWhereInput;
  AND?: DeliriumWhereInput[] | DeliriumWhereInput;
  OR?: DeliriumWhereInput[] | DeliriumWhereInput;
  NOT?: DeliriumWhereInput[] | DeliriumWhereInput;
}

export interface ConstructCreateManyInput {
  create?: ConstructCreateInput[] | ConstructCreateInput;
  connect?: ConstructWhereUniqueInput[] | ConstructWhereUniqueInput;
}

export interface ScarSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScarWhereInput;
  AND?: ScarSubscriptionWhereInput[] | ScarSubscriptionWhereInput;
  OR?: ScarSubscriptionWhereInput[] | ScarSubscriptionWhereInput;
  NOT?: ScarSubscriptionWhereInput[] | ScarSubscriptionWhereInput;
}

export interface ConstructCreateInput {
  id?: ID_Input;
  gate?: GateCreateManyInput;
  tower?: TowerCreateManyInput;
  wall?: WallCreateManyInput;
}

export interface ShieldWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  silence_every?: SilenceWhereInput;
  silence_some?: SilenceWhereInput;
  silence_none?: SilenceWhereInput;
  sarcasm_every?: SarcasmWhereInput;
  sarcasm_some?: SarcasmWhereInput;
  sarcasm_none?: SarcasmWhereInput;
  denial_every?: DenialWhereInput;
  denial_some?: DenialWhereInput;
  denial_none?: DenialWhereInput;
  confusion_every?: ConfusionWhereInput;
  confusion_some?: ConfusionWhereInput;
  confusion_none?: ConfusionWhereInput;
  AND?: ShieldWhereInput[] | ShieldWhereInput;
  OR?: ShieldWhereInput[] | ShieldWhereInput;
  NOT?: ShieldWhereInput[] | ShieldWhereInput;
}

export interface GateCreateManyInput {
  create?: GateCreateInput[] | GateCreateInput;
  connect?: GateWhereUniqueInput[] | GateWhereUniqueInput;
}

export interface ConfusionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  armor_every?: ArmorWhereInput;
  armor_some?: ArmorWhereInput;
  armor_none?: ArmorWhereInput;
  AND?: ConfusionWhereInput[] | ConfusionWhereInput;
  OR?: ConfusionWhereInput[] | ConfusionWhereInput;
  NOT?: ConfusionWhereInput[] | ConfusionWhereInput;
}

export interface GateCreateInput {
  id?: ID_Input;
  boundary?: BoundaryCreateManyInput;
}

export interface VulnerabilityUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface BoundaryCreateManyInput {
  create?: BoundaryCreateInput[] | BoundaryCreateInput;
  connect?: BoundaryWhereUniqueInput[] | BoundaryWhereUniqueInput;
}

export interface VolunteerUpdateInput {
  act?: ActUpdateManyInput;
}

export interface TowerCreateManyInput {
  create?: TowerCreateInput[] | TowerCreateInput;
  connect?: TowerWhereUniqueInput[] | TowerWhereUniqueInput;
}

export interface TremorUpdateInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface TowerCreateInput {
  id?: ID_Input;
  boundary?: BoundaryCreateManyInput;
}

export interface GenieWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  wish_every?: WishWhereInput;
  wish_some?: WishWhereInput;
  wish_none?: WishWhereInput;
  AND?: GenieWhereInput[] | GenieWhereInput;
  OR?: GenieWhereInput[] | GenieWhereInput;
  NOT?: GenieWhereInput[] | GenieWhereInput;
}

export interface WallCreateManyInput {
  create?: WallCreateInput[] | WallCreateInput;
  connect?: WallWhereUniqueInput[] | WallWhereUniqueInput;
}

export interface SeekerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  virtue_every?: VirtueWhereInput;
  virtue_some?: VirtueWhereInput;
  virtue_none?: VirtueWhereInput;
  AND?: SeekerWhereInput[] | SeekerWhereInput;
  OR?: SeekerWhereInput[] | SeekerWhereInput;
  NOT?: SeekerWhereInput[] | SeekerWhereInput;
}

export interface WallCreateInput {
  id?: ID_Input;
  boundary?: BoundaryCreateManyInput;
}

export interface VictimWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  affliction_every?: AfflictionWhereInput;
  affliction_some?: AfflictionWhereInput;
  affliction_none?: AfflictionWhereInput;
  AND?: VictimWhereInput[] | VictimWhereInput;
  OR?: VictimWhereInput[] | VictimWhereInput;
  NOT?: VictimWhereInput[] | VictimWhereInput;
}

export interface MartyrCreateOneInput {
  create?: MartyrCreateInput;
  connect?: MartyrWhereUniqueInput;
}

export interface ToxicityUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface MartyrCreateInput {
  id?: ID_Input;
  stigmata?: StigmataCreateManyInput;
}

export interface SupportUpdateInput {
  courage?: CourageUpdateManyInput;
  compassion?: CompassionUpdateManyInput;
}

export interface StigmataCreateManyInput {
  create?: StigmataCreateInput[] | StigmataCreateInput;
  connect?: StigmataWhereUniqueInput[] | StigmataWhereUniqueInput;
}

export interface StrengthUpdateInput {
  armor?: ArmorUpdateManyInput;
  boundary?: BoundaryUpdateManyInput;
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
}

export interface StigmataCreateInput {
  id?: ID_Input;
  nail?: NailCreateManyInput;
  crown?: CrownCreateManyInput;
  cross?: CrossCreateManyInput;
}

export interface SternumUpdateInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface NailCreateManyInput {
  create?: NailCreateInput[] | NailCreateInput;
  connect?: NailWhereUniqueInput[] | NailWhereUniqueInput;
}

export interface SkinUpdateInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface NailCreateInput {
  id?: ID_Input;
  suffering?: SufferingCreateManyInput;
}

export interface ShieldUpdateInput {
  silence?: SilenceUpdateManyInput;
  sarcasm?: SarcasmUpdateManyInput;
  denial?: DenialUpdateManyInput;
  confusion?: ConfusionUpdateManyInput;
}

export interface SufferingCreateManyInput {
  create?: SufferingCreateInput[] | SufferingCreateInput;
  connect?: SufferingWhereUniqueInput[] | SufferingWhereUniqueInput;
}

export interface SelfPityUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SufferingCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ScarUpdateInput {
  trauma?: TraumaUpdateManyInput;
  toxicity?: ToxicityUpdateManyInput;
}

export interface CrownCreateManyInput {
  create?: CrownCreateInput[] | CrownCreateInput;
  connect?: CrownWhereUniqueInput[] | CrownWhereUniqueInput;
}

export interface SalvationUpdateInput {
  thought?: String;
  character?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CrownCreateInput {
  id?: ID_Input;
  suffering?: SufferingCreateManyInput;
}

export interface ProcessUpdateInput {
  act?: ActUpdateOneInput;
  affliction?: AfflictionUpdateOneInput;
  body?: BodyUpdateOneInput;
  construct?: ConstructUpdateOneInput;
  oath?: OathUpdateOneInput;
  shield?: ShieldUpdateOneInput;
  stigmata?: StigmataUpdateOneInput;
  virtue?: VirtueUpdateOneInput;
  wish?: WishUpdateOneInput;
}

export interface CrossCreateManyInput {
  create?: CrossCreateInput[] | CrossCreateInput;
  connect?: CrossWhereUniqueInput[] | CrossWhereUniqueInput;
}

export interface PrideUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CrossCreateInput {
  id?: ID_Input;
  suffering?: SufferingCreateManyInput;
}

export interface PathUpdateInput {
  defect?: DefectUpdateOneInput;
  discontent?: DiscontentUpdateOneInput;
  resentment?: ResentmentUpdateOneInput;
  obsession?: ObsessionUpdateOneInput;
  experience?: ExperienceUpdateOneInput;
  strength?: StrengthUpdateOneInput;
  hope?: HopeUpdateOneInput;
}

export interface PaladinCreateOneInput {
  create?: PaladinCreateInput;
  connect?: PaladinWhereUniqueInput;
}

export interface OathUpdateInput {
  pledge?: PledgeUpdateManyInput;
  campaign?: CampaignUpdateManyInput;
  crusade?: CrusadeUpdateManyInput;
}

export interface PaladinCreateInput {
  id?: ID_Input;
  oath?: OathCreateManyInput;
}

export interface IrritabilityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolveAt?: DateTimeInput;
  resolveAt_not?: DateTimeInput;
  resolveAt_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_lt?: DateTimeInput;
  resolveAt_lte?: DateTimeInput;
  resolveAt_gt?: DateTimeInput;
  resolveAt_gte?: DateTimeInput;
  AND?: IrritabilityWhereInput[] | IrritabilityWhereInput;
  OR?: IrritabilityWhereInput[] | IrritabilityWhereInput;
  NOT?: IrritabilityWhereInput[] | IrritabilityWhereInput;
}

export interface OathCreateManyInput {
  create?: OathCreateInput[] | OathCreateInput;
  connect?: OathWhereUniqueInput[] | OathWhereUniqueInput;
}

export interface ToxicityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: ToxicityWhereInput[] | ToxicityWhereInput;
  OR?: ToxicityWhereInput[] | ToxicityWhereInput;
  NOT?: ToxicityWhereInput[] | ToxicityWhereInput;
}

export interface OathCreateInput {
  id?: ID_Input;
  pledge?: PledgeCreateManyInput;
  campaign?: CampaignCreateManyInput;
  crusade?: CrusadeCreateManyInput;
}

export interface MindCreateInput {
  id?: ID_Input;
  vulnerability?: VulnerabilityCreateManyInput;
  acceptance?: AcceptanceCreateManyInput;
}

export interface PledgeCreateManyInput {
  create?: PledgeCreateInput[] | PledgeCreateInput;
  connect?: PledgeWhereUniqueInput[] | PledgeWhereUniqueInput;
}

export interface LoyaltyUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface PledgeCreateInput {
  id?: ID_Input;
  loyalty?: LoyaltyCreateManyInput;
  honor?: HonorCreateManyInput;
}

export interface JoyUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface CampaignCreateManyInput {
  create?: CampaignCreateInput[] | CampaignCreateInput;
  connect?: CampaignWhereUniqueInput[] | CampaignWhereUniqueInput;
}

export interface ExperienceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  compassion_every?: CompassionWhereInput;
  compassion_some?: CompassionWhereInput;
  compassion_none?: CompassionWhereInput;
  courage_every?: CourageWhereInput;
  courage_some?: CourageWhereInput;
  courage_none?: CourageWhereInput;
  acceptance_every?: AcceptanceWhereInput;
  acceptance_some?: AcceptanceWhereInput;
  acceptance_none?: AcceptanceWhereInput;
  vulnerability_every?: VulnerabilityWhereInput;
  vulnerability_some?: VulnerabilityWhereInput;
  vulnerability_none?: VulnerabilityWhereInput;
  gratitude_every?: GratitudeWhereInput;
  gratitude_some?: GratitudeWhereInput;
  gratitude_none?: GratitudeWhereInput;
  suffering_every?: SufferingWhereInput;
  suffering_some?: SufferingWhereInput;
  suffering_none?: SufferingWhereInput;
  AND?: ExperienceWhereInput[] | ExperienceWhereInput;
  OR?: ExperienceWhereInput[] | ExperienceWhereInput;
  NOT?: ExperienceWhereInput[] | ExperienceWhereInput;
}

export interface CrusadeCreateManyInput {
  create?: CrusadeCreateInput[] | CrusadeCreateInput;
  connect?: CrusadeWhereUniqueInput[] | CrusadeWhereUniqueInput;
}

export interface HopeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: HopeScalarWhereInput[] | HopeScalarWhereInput;
  OR?: HopeScalarWhereInput[] | HopeScalarWhereInput;
  NOT?: HopeScalarWhereInput[] | HopeScalarWhereInput;
}

export interface CrusadeCreateInput {
  id?: ID_Input;
  loyalty?: LoyaltyCreateManyInput;
  honor?: HonorCreateManyInput;
}

export interface HopeUpdateManyInput {
  create?: HopeCreateInput[] | HopeCreateInput;
  update?:
    | HopeUpdateWithWhereUniqueNestedInput[]
    | HopeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | HopeUpsertWithWhereUniqueNestedInput[]
    | HopeUpsertWithWhereUniqueNestedInput;
  delete?: HopeWhereUniqueInput[] | HopeWhereUniqueInput;
  connect?: HopeWhereUniqueInput[] | HopeWhereUniqueInput;
  set?: HopeWhereUniqueInput[] | HopeWhereUniqueInput;
  disconnect?: HopeWhereUniqueInput[] | HopeWhereUniqueInput;
  deleteMany?: HopeScalarWhereInput[] | HopeScalarWhereInput;
}

export interface SeekerCreateOneInput {
  create?: SeekerCreateInput;
  connect?: SeekerWhereUniqueInput;
}

export interface StrengthUpdateWithWhereUniqueNestedInput {
  where: StrengthWhereUniqueInput;
  data: StrengthUpdateDataInput;
}

export interface SeekerCreateInput {
  id?: ID_Input;
  virtue?: VirtueCreateManyInput;
}

export type AfflictionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VirtueCreateManyInput {
  create?: VirtueCreateInput[] | VirtueCreateInput;
  connect?: VirtueWhereUniqueInput[] | VirtueWhereUniqueInput;
}

export type FunWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VirtueCreateInput {
  id?: ID_Input;
  nail?: NailCreateManyInput;
  crown?: CrownCreateManyInput;
  cross?: CrossCreateManyInput;
}

export interface ObsessionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ObsessionScalarWhereInput[] | ObsessionScalarWhereInput;
  OR?: ObsessionScalarWhereInput[] | ObsessionScalarWhereInput;
  NOT?: ObsessionScalarWhereInput[] | ObsessionScalarWhereInput;
}

export interface SelfCreateOneInput {
  create?: SelfCreateInput;
  connect?: SelfWhereUniqueInput;
}

export interface ObsessionUpdateManyInput {
  create?: ObsessionCreateInput[] | ObsessionCreateInput;
  update?:
    | ObsessionUpdateWithWhereUniqueNestedInput[]
    | ObsessionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ObsessionUpsertWithWhereUniqueNestedInput[]
    | ObsessionUpsertWithWhereUniqueNestedInput;
  delete?: ObsessionWhereUniqueInput[] | ObsessionWhereUniqueInput;
  connect?: ObsessionWhereUniqueInput[] | ObsessionWhereUniqueInput;
  set?: ObsessionWhereUniqueInput[] | ObsessionWhereUniqueInput;
  disconnect?: ObsessionWhereUniqueInput[] | ObsessionWhereUniqueInput;
  deleteMany?: ObsessionScalarWhereInput[] | ObsessionScalarWhereInput;
}

export interface SelfCreateInput {
  id?: ID_Input;
  body?: BodyCreateManyInput;
}

export interface ResentmentUpdateWithWhereUniqueNestedInput {
  where: ResentmentWhereUniqueInput;
  data: ResentmentUpdateDataInput;
}

export interface BodyCreateManyInput {
  create?: BodyCreateInput[] | BodyCreateInput;
  connect?: BodyWhereUniqueInput[] | BodyWhereUniqueInput;
}

export interface SoulSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SoulWhereInput;
  AND?: SoulSubscriptionWhereInput[] | SoulSubscriptionWhereInput;
  OR?: SoulSubscriptionWhereInput[] | SoulSubscriptionWhereInput;
  NOT?: SoulSubscriptionWhereInput[] | SoulSubscriptionWhereInput;
}

export interface SmithCreateOneInput {
  create?: SmithCreateInput;
  connect?: SmithWhereUniqueInput;
}

export type GratitudeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SmithCreateInput {
  id?: ID_Input;
  shield?: ShieldCreateManyInput;
}

export type GuardianWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ShieldCreateManyInput {
  create?: ShieldCreateInput[] | ShieldCreateInput;
  connect?: ShieldWhereUniqueInput[] | ShieldWhereUniqueInput;
}

export interface HopeCreateManyInput {
  create?: HopeCreateInput[] | HopeCreateInput;
  connect?: HopeWhereUniqueInput[] | HopeWhereUniqueInput;
}

export interface ShieldCreateInput {
  id?: ID_Input;
  silence?: SilenceCreateManyInput;
  sarcasm?: SarcasmCreateManyInput;
  denial?: DenialCreateManyInput;
  confusion?: ConfusionCreateManyInput;
}

export interface ObsessionCreateManyInput {
  create?: ObsessionCreateInput[] | ObsessionCreateInput;
  connect?: ObsessionWhereUniqueInput[] | ObsessionWhereUniqueInput;
}

export interface SilenceCreateManyInput {
  create?: SilenceCreateInput[] | SilenceCreateInput;
  connect?: SilenceWhereUniqueInput[] | SilenceWhereUniqueInput;
}

export interface ActWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  service_every?: ServiceWhereInput;
  service_some?: ServiceWhereInput;
  service_none?: ServiceWhereInput;
  support_every?: SupportWhereInput;
  support_some?: SupportWhereInput;
  support_none?: SupportWhereInput;
  sacrifice_every?: SacrificeWhereInput;
  sacrifice_some?: SacrificeWhereInput;
  sacrifice_none?: SacrificeWhereInput;
  AND?: ActWhereInput[] | ActWhereInput;
  OR?: ActWhereInput[] | ActWhereInput;
  NOT?: ActWhereInput[] | ActWhereInput;
}

export interface SilenceCreateInput {
  id?: ID_Input;
  armor?: ArmorCreateManyInput;
}

export type HeartWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ArmorCreateManyInput {
  create?: ArmorCreateInput[] | ArmorCreateInput;
  connect?: ArmorWhereUniqueInput[] | ArmorWhereUniqueInput;
}

export type HigherPowerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SarcasmCreateManyInput {
  create?: SarcasmCreateInput[] | SarcasmCreateInput;
  connect?: SarcasmWhereUniqueInput[] | SarcasmWhereUniqueInput;
}

export interface CharactersUpsertNestedInput {
  update: CharactersUpdateDataInput;
  create: CharactersCreateInput;
}

export interface SarcasmCreateInput {
  id?: ID_Input;
  armor?: ArmorCreateManyInput;
}

export interface FeelingUpdateManyWithWhereNestedInput {
  where: FeelingScalarWhereInput;
  data: FeelingUpdateManyDataInput;
}

export interface DenialCreateManyInput {
  create?: DenialCreateInput[] | DenialCreateInput;
  connect?: DenialWhereUniqueInput[] | DenialWhereUniqueInput;
}

export interface HigherPowerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  prayer?: PrayerWhereInput;
  inventory_every?: FeelingWhereInput;
  inventory_some?: FeelingWhereInput;
  inventory_none?: FeelingWhereInput;
  character?: CharactersWhereInput;
  AND?: HigherPowerWhereInput[] | HigherPowerWhereInput;
  OR?: HigherPowerWhereInput[] | HigherPowerWhereInput;
  NOT?: HigherPowerWhereInput[] | HigherPowerWhereInput;
}

export interface DenialCreateInput {
  id?: ID_Input;
  armor?: ArmorCreateManyInput;
}

export interface ResentmentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  anger_every?: AngerWhereInput;
  anger_some?: AngerWhereInput;
  anger_none?: AngerWhereInput;
  selfPity_every?: SelfPityWhereInput;
  selfPity_some?: SelfPityWhereInput;
  selfPity_none?: SelfPityWhereInput;
  fear_every?: FearWhereInput;
  fear_some?: FearWhereInput;
  fear_none?: FearWhereInput;
  pride_every?: PrideWhereInput;
  pride_some?: PrideWhereInput;
  pride_none?: PrideWhereInput;
  AND?: ResentmentWhereInput[] | ResentmentWhereInput;
  OR?: ResentmentWhereInput[] | ResentmentWhereInput;
  NOT?: ResentmentWhereInput[] | ResentmentWhereInput;
}

export interface ConfusionCreateManyInput {
  create?: ConfusionCreateInput[] | ConfusionCreateInput;
  connect?: ConfusionWhereUniqueInput[] | ConfusionWhereUniqueInput;
}

export interface SacrificeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  courage_every?: CourageWhereInput;
  courage_some?: CourageWhereInput;
  courage_none?: CourageWhereInput;
  compassion_every?: CompassionWhereInput;
  compassion_some?: CompassionWhereInput;
  compassion_none?: CompassionWhereInput;
  AND?: SacrificeWhereInput[] | SacrificeWhereInput;
  OR?: SacrificeWhereInput[] | SacrificeWhereInput;
  NOT?: SacrificeWhereInput[] | SacrificeWhereInput;
}

export interface ConfusionCreateInput {
  id?: ID_Input;
  armor?: ArmorCreateManyInput;
}

export type HonorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SummonerCreateOneInput {
  create?: SummonerCreateInput;
  connect?: SummonerWhereUniqueInput;
}

export type HopeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SummonerCreateInput {
  id?: ID_Input;
}

export interface JoyUpdateManyWithWhereNestedInput {
  where: JoyScalarWhereInput;
  data: JoyUpdateManyDataInput;
}

export interface VictimCreateOneInput {
  create?: VictimCreateInput;
  connect?: VictimWhereUniqueInput;
}

export interface JoyUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface VictimCreateInput {
  id?: ID_Input;
  affliction?: AfflictionCreateManyInput;
}

export interface FunUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface AfflictionCreateManyInput {
  create?: AfflictionCreateInput[] | AfflictionCreateInput;
  connect?: AfflictionWhereUniqueInput[] | AfflictionWhereUniqueInput;
}

export interface SufferingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SufferingWhereInput;
  AND?: SufferingSubscriptionWhereInput[] | SufferingSubscriptionWhereInput;
  OR?: SufferingSubscriptionWhereInput[] | SufferingSubscriptionWhereInput;
  NOT?: SufferingSubscriptionWhereInput[] | SufferingSubscriptionWhereInput;
}

export interface VolunteerCreateOneInput {
  create?: VolunteerCreateInput;
  connect?: VolunteerWhereUniqueInput;
}

export interface FunScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolveAt?: DateTimeInput;
  resolveAt_not?: DateTimeInput;
  resolveAt_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_lt?: DateTimeInput;
  resolveAt_lte?: DateTimeInput;
  resolveAt_gt?: DateTimeInput;
  resolveAt_gte?: DateTimeInput;
  AND?: FunScalarWhereInput[] | FunScalarWhereInput;
  OR?: FunScalarWhereInput[] | FunScalarWhereInput;
  NOT?: FunScalarWhereInput[] | FunScalarWhereInput;
}

export interface VolunteerCreateInput {
  id?: ID_Input;
  act?: ActCreateManyInput;
}

export interface FunUpdateWithWhereUniqueNestedInput {
  where: FunWhereUniqueInput;
  data: FunUpdateDataInput;
}

export interface ActCreateManyInput {
  create?: ActCreateInput[] | ActCreateInput;
  connect?: ActWhereUniqueInput[] | ActWhereUniqueInput;
}

export interface HopeUpdateOneInput {
  create?: HopeCreateInput;
  update?: HopeUpdateDataInput;
  upsert?: HopeUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HopeWhereUniqueInput;
}

export interface CharactersUpdateInput {
  congregant?: CongregantUpdateOneInput;
  genie?: GenieUpdateOneInput;
  guardian?: GuardianUpdateOneInput;
  martyr?: MartyrUpdateOneInput;
  paladin?: PaladinUpdateOneInput;
  seeker?: SeekerUpdateOneInput;
  self?: SelfUpdateOneInput;
  smith?: SmithUpdateOneInput;
  summoner?: SummonerUpdateOneInput;
  victim?: VictimUpdateOneInput;
  volunteer?: VolunteerUpdateOneInput;
}

export interface StrengthUpdateOneInput {
  create?: StrengthCreateInput;
  update?: StrengthUpdateDataInput;
  upsert?: StrengthUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StrengthWhereUniqueInput;
}

export interface CongregantUpdateOneInput {
  create?: CongregantCreateInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CongregantWhereUniqueInput;
}

export interface ExperienceUpdateDataInput {
  compassion?: CompassionUpdateManyInput;
  courage?: CourageUpdateManyInput;
  acceptance?: AcceptanceUpdateManyInput;
  vulnerability?: VulnerabilityUpdateManyInput;
  gratitude?: GratitudeUpdateManyInput;
  suffering?: SufferingUpdateManyInput;
}

export interface GenieUpdateOneInput {
  create?: GenieCreateInput;
  update?: GenieUpdateDataInput;
  upsert?: GenieUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GenieWhereUniqueInput;
}

export interface ObsessionUpdateDataInput {
  suffering?: SufferingUpdateManyInput;
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
  vulnerability?: VulnerabilityUpdateManyInput;
}

export interface GenieUpdateDataInput {
  wish?: WishUpdateManyInput;
}

export interface ResentmentUpsertNestedInput {
  update: ResentmentUpdateDataInput;
  create: ResentmentCreateInput;
}

export interface WishUpdateManyInput {
  create?: WishCreateInput[] | WishCreateInput;
  update?:
    | WishUpdateWithWhereUniqueNestedInput[]
    | WishUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WishUpsertWithWhereUniqueNestedInput[]
    | WishUpsertWithWhereUniqueNestedInput;
  delete?: WishWhereUniqueInput[] | WishWhereUniqueInput;
  connect?: WishWhereUniqueInput[] | WishWhereUniqueInput;
  set?: WishWhereUniqueInput[] | WishWhereUniqueInput;
  disconnect?: WishWhereUniqueInput[] | WishWhereUniqueInput;
  deleteMany?: WishScalarWhereInput[] | WishScalarWhereInput;
}

export interface DiscontentUpsertNestedInput {
  update: DiscontentUpdateDataInput;
  create: DiscontentCreateInput;
}

export interface WishUpdateWithWhereUniqueNestedInput {
  where: WishWhereUniqueInput;
  data: WishUpdateDataInput;
}

export interface DiscontentUpdateOneInput {
  create?: DiscontentCreateInput;
  update?: DiscontentUpdateDataInput;
  upsert?: DiscontentUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DiscontentWhereUniqueInput;
}

export interface WishUpdateDataInput {
  dream?: DreamUpdateManyInput;
}

export interface DefectUpdateOneInput {
  create?: DefectCreateInput;
  update?: DefectUpdateDataInput;
  upsert?: DefectUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DefectWhereUniqueInput;
}

export interface DreamUpdateManyInput {
  create?: DreamCreateInput[] | DreamCreateInput;
  update?:
    | DreamUpdateWithWhereUniqueNestedInput[]
    | DreamUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DreamUpsertWithWhereUniqueNestedInput[]
    | DreamUpsertWithWhereUniqueNestedInput;
  delete?: DreamWhereUniqueInput[] | DreamWhereUniqueInput;
  connect?: DreamWhereUniqueInput[] | DreamWhereUniqueInput;
  set?: DreamWhereUniqueInput[] | DreamWhereUniqueInput;
  disconnect?: DreamWhereUniqueInput[] | DreamWhereUniqueInput;
  deleteMany?: DreamScalarWhereInput[] | DreamScalarWhereInput;
}

export interface ProcessUpsertNestedInput {
  update: ProcessUpdateDataInput;
  create: ProcessCreateInput;
}

export interface DreamUpdateWithWhereUniqueNestedInput {
  where: DreamWhereUniqueInput;
  data: DreamUpdateDataInput;
}

export interface VirtueUpsertNestedInput {
  update: VirtueUpdateDataInput;
  create: VirtueCreateInput;
}

export interface DreamUpdateDataInput {
  salvation?: SalvationUpdateManyInput;
}

export interface StigmataUpdateOneInput {
  create?: StigmataCreateInput;
  update?: StigmataUpdateDataInput;
  upsert?: StigmataUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: StigmataWhereUniqueInput;
}

export interface SalvationUpdateManyInput {
  create?: SalvationCreateInput[] | SalvationCreateInput;
  update?:
    | SalvationUpdateWithWhereUniqueNestedInput[]
    | SalvationUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SalvationUpsertWithWhereUniqueNestedInput[]
    | SalvationUpsertWithWhereUniqueNestedInput;
  delete?: SalvationWhereUniqueInput[] | SalvationWhereUniqueInput;
  connect?: SalvationWhereUniqueInput[] | SalvationWhereUniqueInput;
  set?: SalvationWhereUniqueInput[] | SalvationWhereUniqueInput;
  disconnect?: SalvationWhereUniqueInput[] | SalvationWhereUniqueInput;
  deleteMany?: SalvationScalarWhereInput[] | SalvationScalarWhereInput;
  updateMany?:
    | SalvationUpdateManyWithWhereNestedInput[]
    | SalvationUpdateManyWithWhereNestedInput;
}

export interface OathUpsertNestedInput {
  update: OathUpdateDataInput;
  create: OathCreateInput;
}

export interface SalvationUpdateWithWhereUniqueNestedInput {
  where: SalvationWhereUniqueInput;
  data: SalvationUpdateDataInput;
}

export interface ConstructUpsertNestedInput {
  update: ConstructUpdateDataInput;
  create: ConstructCreateInput;
}

export interface SalvationUpdateDataInput {
  thought?: String;
  character?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type ActWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SalvationUpsertWithWhereUniqueNestedInput {
  where: SalvationWhereUniqueInput;
  update: SalvationUpdateDataInput;
  create: SalvationCreateInput;
}

export type PledgeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SalvationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: SalvationScalarWhereInput[] | SalvationScalarWhereInput;
  OR?: SalvationScalarWhereInput[] | SalvationScalarWhereInput;
  NOT?: SalvationScalarWhereInput[] | SalvationScalarWhereInput;
}

export type PrayerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SalvationUpdateManyWithWhereNestedInput {
  where: SalvationScalarWhereInput;
  data: SalvationUpdateManyDataInput;
}

export interface PrayerUpdateOneInput {
  create?: PrayerCreateInput;
  update?: PrayerUpdateDataInput;
  upsert?: PrayerUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PrayerWhereUniqueInput;
}

export interface SalvationUpdateManyDataInput {
  thought?: String;
  character?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface FeelingCreateManyInput {
  create?: FeelingCreateInput[] | FeelingCreateInput;
  connect?: FeelingWhereUniqueInput[] | FeelingWhereUniqueInput;
}

export interface DreamUpsertWithWhereUniqueNestedInput {
  where: DreamWhereUniqueInput;
  update: DreamUpdateDataInput;
  create: DreamCreateInput;
}

export interface JoyCreateManyInput {
  create?: JoyCreateInput[] | JoyCreateInput;
  connect?: JoyWhereUniqueInput[] | JoyWhereUniqueInput;
}

export interface DreamScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: DreamScalarWhereInput[] | DreamScalarWhereInput;
  OR?: DreamScalarWhereInput[] | DreamScalarWhereInput;
  NOT?: DreamScalarWhereInput[] | DreamScalarWhereInput;
}

export interface HopeCreateOneInput {
  create?: HopeCreateInput;
  connect?: HopeWhereUniqueInput;
}

export interface WishUpsertWithWhereUniqueNestedInput {
  where: WishWhereUniqueInput;
  update: WishUpdateDataInput;
  create: WishCreateInput;
}

export interface ExperienceCreateOneInput {
  create?: ExperienceCreateInput;
  connect?: ExperienceWhereUniqueInput;
}

export interface WishScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: WishScalarWhereInput[] | WishScalarWhereInput;
  OR?: WishScalarWhereInput[] | WishScalarWhereInput;
  NOT?: WishScalarWhereInput[] | WishScalarWhereInput;
}

export interface SelfPityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: SelfPityWhereInput[] | SelfPityWhereInput;
  OR?: SelfPityWhereInput[] | SelfPityWhereInput;
  NOT?: SelfPityWhereInput[] | SelfPityWhereInput;
}

export interface GenieUpsertNestedInput {
  update: GenieUpdateDataInput;
  create: GenieCreateInput;
}

export interface SoulWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  vulnerability_every?: VulnerabilityWhereInput;
  vulnerability_some?: VulnerabilityWhereInput;
  vulnerability_none?: VulnerabilityWhereInput;
  acceptance_every?: AcceptanceWhereInput;
  acceptance_some?: AcceptanceWhereInput;
  acceptance_none?: AcceptanceWhereInput;
  AND?: SoulWhereInput[] | SoulWhereInput;
  OR?: SoulWhereInput[] | SoulWhereInput;
  NOT?: SoulWhereInput[] | SoulWhereInput;
}

export interface GuardianUpdateOneInput {
  create?: GuardianCreateInput;
  update?: GuardianUpdateDataInput;
  upsert?: GuardianUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: GuardianWhereUniqueInput;
}

export interface LoyaltySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LoyaltyWhereInput;
  AND?: LoyaltySubscriptionWhereInput[] | LoyaltySubscriptionWhereInput;
  OR?: LoyaltySubscriptionWhereInput[] | LoyaltySubscriptionWhereInput;
  NOT?: LoyaltySubscriptionWhereInput[] | LoyaltySubscriptionWhereInput;
}

export interface GuardianUpdateDataInput {
  construct?: ConstructUpdateManyInput;
}

export interface StigmataCreateOneInput {
  create?: StigmataCreateInput;
  connect?: StigmataWhereUniqueInput;
}

export interface ConstructUpdateManyInput {
  create?: ConstructCreateInput[] | ConstructCreateInput;
  update?:
    | ConstructUpdateWithWhereUniqueNestedInput[]
    | ConstructUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ConstructUpsertWithWhereUniqueNestedInput[]
    | ConstructUpsertWithWhereUniqueNestedInput;
  delete?: ConstructWhereUniqueInput[] | ConstructWhereUniqueInput;
  connect?: ConstructWhereUniqueInput[] | ConstructWhereUniqueInput;
  set?: ConstructWhereUniqueInput[] | ConstructWhereUniqueInput;
  disconnect?: ConstructWhereUniqueInput[] | ConstructWhereUniqueInput;
  deleteMany?: ConstructScalarWhereInput[] | ConstructScalarWhereInput;
}

export interface VictimSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VictimWhereInput;
  AND?: VictimSubscriptionWhereInput[] | VictimSubscriptionWhereInput;
  OR?: VictimSubscriptionWhereInput[] | VictimSubscriptionWhereInput;
  NOT?: VictimSubscriptionWhereInput[] | VictimSubscriptionWhereInput;
}

export interface ConstructUpdateWithWhereUniqueNestedInput {
  where: ConstructWhereUniqueInput;
  data: ConstructUpdateDataInput;
}

export type SelfPityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ConstructUpdateDataInput {
  gate?: GateUpdateManyInput;
  tower?: TowerUpdateManyInput;
  wall?: WallUpdateManyInput;
}

export interface GutWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  anger_every?: AngerWhereInput;
  anger_some?: AngerWhereInput;
  anger_none?: AngerWhereInput;
  fear_every?: FearWhereInput;
  fear_some?: FearWhereInput;
  fear_none?: FearWhereInput;
  pride_every?: PrideWhereInput;
  pride_some?: PrideWhereInput;
  pride_none?: PrideWhereInput;
  selfPity_every?: SelfPityWhereInput;
  selfPity_some?: SelfPityWhereInput;
  selfPity_none?: SelfPityWhereInput;
  AND?: GutWhereInput[] | GutWhereInput;
  OR?: GutWhereInput[] | GutWhereInput;
  NOT?: GutWhereInput[] | GutWhereInput;
}

export interface GateUpdateManyInput {
  create?: GateCreateInput[] | GateCreateInput;
  update?:
    | GateUpdateWithWhereUniqueNestedInput[]
    | GateUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GateUpsertWithWhereUniqueNestedInput[]
    | GateUpsertWithWhereUniqueNestedInput;
  delete?: GateWhereUniqueInput[] | GateWhereUniqueInput;
  connect?: GateWhereUniqueInput[] | GateWhereUniqueInput;
  set?: GateWhereUniqueInput[] | GateWhereUniqueInput;
  disconnect?: GateWhereUniqueInput[] | GateWhereUniqueInput;
  deleteMany?: GateScalarWhereInput[] | GateScalarWhereInput;
}

export interface InventorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InventoryWhereInput;
  AND?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
  OR?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
  NOT?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
}

export interface GateUpdateWithWhereUniqueNestedInput {
  where: GateWhereUniqueInput;
  data: GateUpdateDataInput;
}

export type SilenceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GateUpdateDataInput {
  boundary?: BoundaryUpdateManyInput;
}

export type SkinWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BoundaryUpdateManyInput {
  create?: BoundaryCreateInput[] | BoundaryCreateInput;
  update?:
    | BoundaryUpdateWithWhereUniqueNestedInput[]
    | BoundaryUpdateWithWhereUniqueNestedInput;
  upsert?:
    | BoundaryUpsertWithWhereUniqueNestedInput[]
    | BoundaryUpsertWithWhereUniqueNestedInput;
  delete?: BoundaryWhereUniqueInput[] | BoundaryWhereUniqueInput;
  connect?: BoundaryWhereUniqueInput[] | BoundaryWhereUniqueInput;
  set?: BoundaryWhereUniqueInput[] | BoundaryWhereUniqueInput;
  disconnect?: BoundaryWhereUniqueInput[] | BoundaryWhereUniqueInput;
  deleteMany?: BoundaryScalarWhereInput[] | BoundaryScalarWhereInput;
  updateMany?:
    | BoundaryUpdateManyWithWhereNestedInput[]
    | BoundaryUpdateManyWithWhereNestedInput;
}

export interface GratitudeUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface BoundaryUpdateWithWhereUniqueNestedInput {
  where: BoundaryWhereUniqueInput;
  data: BoundaryUpdateDataInput;
}

export interface VolunteerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VolunteerWhereInput;
  AND?: VolunteerSubscriptionWhereInput[] | VolunteerSubscriptionWhereInput;
  OR?: VolunteerSubscriptionWhereInput[] | VolunteerSubscriptionWhereInput;
  NOT?: VolunteerSubscriptionWhereInput[] | VolunteerSubscriptionWhereInput;
}

export interface BoundaryUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type SoulWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BoundaryUpsertWithWhereUniqueNestedInput {
  where: BoundaryWhereUniqueInput;
  update: BoundaryUpdateDataInput;
  create: BoundaryCreateInput;
}

export type SternumWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BoundaryScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: BoundaryScalarWhereInput[] | BoundaryScalarWhereInput;
  OR?: BoundaryScalarWhereInput[] | BoundaryScalarWhereInput;
  NOT?: BoundaryScalarWhereInput[] | BoundaryScalarWhereInput;
}

export type StigmataWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BoundaryUpdateManyWithWhereNestedInput {
  where: BoundaryScalarWhereInput;
  data: BoundaryUpdateManyDataInput;
}

export type StrengthWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BoundaryUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type SufferingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GateUpsertWithWhereUniqueNestedInput {
  where: GateWhereUniqueInput;
  update: GateUpdateDataInput;
  create: GateCreateInput;
}

export type SummonerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface GateScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: GateScalarWhereInput[] | GateScalarWhereInput;
  OR?: GateScalarWhereInput[] | GateScalarWhereInput;
  NOT?: GateScalarWhereInput[] | GateScalarWhereInput;
}

export interface ExperienceCreateInput {
  id?: ID_Input;
  compassion?: CompassionCreateManyInput;
  courage?: CourageCreateManyInput;
  acceptance?: AcceptanceCreateManyInput;
  vulnerability?: VulnerabilityCreateManyInput;
  gratitude?: GratitudeCreateManyInput;
  suffering?: SufferingCreateManyInput;
}

export interface TowerUpdateManyInput {
  create?: TowerCreateInput[] | TowerCreateInput;
  update?:
    | TowerUpdateWithWhereUniqueNestedInput[]
    | TowerUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TowerUpsertWithWhereUniqueNestedInput[]
    | TowerUpsertWithWhereUniqueNestedInput;
  delete?: TowerWhereUniqueInput[] | TowerWhereUniqueInput;
  connect?: TowerWhereUniqueInput[] | TowerWhereUniqueInput;
  set?: TowerWhereUniqueInput[] | TowerWhereUniqueInput;
  disconnect?: TowerWhereUniqueInput[] | TowerWhereUniqueInput;
  deleteMany?: TowerScalarWhereInput[] | TowerScalarWhereInput;
}

export interface ImpatienceUpdateManyWithWhereNestedInput {
  where: ImpatienceScalarWhereInput;
  data: ImpatienceUpdateManyDataInput;
}

export interface TowerUpdateWithWhereUniqueNestedInput {
  where: TowerWhereUniqueInput;
  data: TowerUpdateDataInput;
}

export interface ImpatienceUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface TowerUpdateDataInput {
  boundary?: BoundaryUpdateManyInput;
}

export interface IrritabilityUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface TowerUpsertWithWhereUniqueNestedInput {
  where: TowerWhereUniqueInput;
  update: TowerUpdateDataInput;
  create: TowerCreateInput;
}

export interface IrritabilityUpsertWithWhereUniqueNestedInput {
  where: IrritabilityWhereUniqueInput;
  update: IrritabilityUpdateDataInput;
  create: IrritabilityCreateInput;
}

export interface TowerScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: TowerScalarWhereInput[] | TowerScalarWhereInput;
  OR?: TowerScalarWhereInput[] | TowerScalarWhereInput;
  NOT?: TowerScalarWhereInput[] | TowerScalarWhereInput;
}

export interface IrritabilityUpdateManyInput {
  create?: IrritabilityCreateInput[] | IrritabilityCreateInput;
  update?:
    | IrritabilityUpdateWithWhereUniqueNestedInput[]
    | IrritabilityUpdateWithWhereUniqueNestedInput;
  upsert?:
    | IrritabilityUpsertWithWhereUniqueNestedInput[]
    | IrritabilityUpsertWithWhereUniqueNestedInput;
  delete?: IrritabilityWhereUniqueInput[] | IrritabilityWhereUniqueInput;
  connect?: IrritabilityWhereUniqueInput[] | IrritabilityWhereUniqueInput;
  set?: IrritabilityWhereUniqueInput[] | IrritabilityWhereUniqueInput;
  disconnect?: IrritabilityWhereUniqueInput[] | IrritabilityWhereUniqueInput;
  deleteMany?: IrritabilityScalarWhereInput[] | IrritabilityScalarWhereInput;
  updateMany?:
    | IrritabilityUpdateManyWithWhereNestedInput[]
    | IrritabilityUpdateManyWithWhereNestedInput;
}

export interface WallUpdateManyInput {
  create?: WallCreateInput[] | WallCreateInput;
  update?:
    | WallUpdateWithWhereUniqueNestedInput[]
    | WallUpdateWithWhereUniqueNestedInput;
  upsert?:
    | WallUpsertWithWhereUniqueNestedInput[]
    | WallUpsertWithWhereUniqueNestedInput;
  delete?: WallWhereUniqueInput[] | WallWhereUniqueInput;
  connect?: WallWhereUniqueInput[] | WallWhereUniqueInput;
  set?: WallWhereUniqueInput[] | WallWhereUniqueInput;
  disconnect?: WallWhereUniqueInput[] | WallWhereUniqueInput;
  deleteMany?: WallScalarWhereInput[] | WallScalarWhereInput;
}

export interface ImpatienceCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface WallUpdateWithWhereUniqueNestedInput {
  where: WallWhereUniqueInput;
  data: WallUpdateDataInput;
}

export interface IrritabilityCreateManyInput {
  create?: IrritabilityCreateInput[] | IrritabilityCreateInput;
  connect?: IrritabilityWhereUniqueInput[] | IrritabilityWhereUniqueInput;
}

export interface WallUpdateDataInput {
  boundary?: BoundaryUpdateManyInput;
}

export interface NightmareSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NightmareWhereInput;
  AND?: NightmareSubscriptionWhereInput[] | NightmareSubscriptionWhereInput;
  OR?: NightmareSubscriptionWhereInput[] | NightmareSubscriptionWhereInput;
  NOT?: NightmareSubscriptionWhereInput[] | NightmareSubscriptionWhereInput;
}

export interface WallUpsertWithWhereUniqueNestedInput {
  where: WallWhereUniqueInput;
  update: WallUpdateDataInput;
  create: WallCreateInput;
}

export interface HasSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HasWhereInput;
  AND?: HasSubscriptionWhereInput[] | HasSubscriptionWhereInput;
  OR?: HasSubscriptionWhereInput[] | HasSubscriptionWhereInput;
  NOT?: HasSubscriptionWhereInput[] | HasSubscriptionWhereInput;
}

export interface WallScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: WallScalarWhereInput[] | WallScalarWhereInput;
  OR?: WallScalarWhereInput[] | WallScalarWhereInput;
  NOT?: WallScalarWhereInput[] | WallScalarWhereInput;
}

export interface GashSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GashWhereInput;
  AND?: GashSubscriptionWhereInput[] | GashSubscriptionWhereInput;
  OR?: GashSubscriptionWhereInput[] | GashSubscriptionWhereInput;
  NOT?: GashSubscriptionWhereInput[] | GashSubscriptionWhereInput;
}

export interface ConstructUpsertWithWhereUniqueNestedInput {
  where: ConstructWhereUniqueInput;
  update: ConstructUpdateDataInput;
  create: ConstructCreateInput;
}

export interface PaladinSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaladinWhereInput;
  AND?: PaladinSubscriptionWhereInput[] | PaladinSubscriptionWhereInput;
  OR?: PaladinSubscriptionWhereInput[] | PaladinSubscriptionWhereInput;
  NOT?: PaladinSubscriptionWhereInput[] | PaladinSubscriptionWhereInput;
}

export interface ConstructScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ConstructScalarWhereInput[] | ConstructScalarWhereInput;
  OR?: ConstructScalarWhereInput[] | ConstructScalarWhereInput;
  NOT?: ConstructScalarWhereInput[] | ConstructScalarWhereInput;
}

export interface WishWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  dream_every?: DreamWhereInput;
  dream_some?: DreamWhereInput;
  dream_none?: DreamWhereInput;
  AND?: WishWhereInput[] | WishWhereInput;
  OR?: WishWhereInput[] | WishWhereInput;
  NOT?: WishWhereInput[] | WishWhereInput;
}

export interface GuardianUpsertNestedInput {
  update: GuardianUpdateDataInput;
  create: GuardianCreateInput;
}

export interface CrusadeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CrusadeWhereInput;
  AND?: CrusadeSubscriptionWhereInput[] | CrusadeSubscriptionWhereInput;
  OR?: CrusadeSubscriptionWhereInput[] | CrusadeSubscriptionWhereInput;
  NOT?: CrusadeSubscriptionWhereInput[] | CrusadeSubscriptionWhereInput;
}

export interface MartyrUpdateOneInput {
  create?: MartyrCreateInput;
  update?: MartyrUpdateDataInput;
  upsert?: MartyrUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: MartyrWhereUniqueInput;
}

export interface PrayerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PrayerWhereInput;
  AND?: PrayerSubscriptionWhereInput[] | PrayerSubscriptionWhereInput;
  OR?: PrayerSubscriptionWhereInput[] | PrayerSubscriptionWhereInput;
  NOT?: PrayerSubscriptionWhereInput[] | PrayerSubscriptionWhereInput;
}

export interface MartyrUpdateDataInput {
  stigmata?: StigmataUpdateManyInput;
}

export interface NailWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  suffering_every?: SufferingWhereInput;
  suffering_some?: SufferingWhereInput;
  suffering_none?: SufferingWhereInput;
  AND?: NailWhereInput[] | NailWhereInput;
  OR?: NailWhereInput[] | NailWhereInput;
  NOT?: NailWhereInput[] | NailWhereInput;
}

export interface StigmataUpdateManyInput {
  create?: StigmataCreateInput[] | StigmataCreateInput;
  update?:
    | StigmataUpdateWithWhereUniqueNestedInput[]
    | StigmataUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StigmataUpsertWithWhereUniqueNestedInput[]
    | StigmataUpsertWithWhereUniqueNestedInput;
  delete?: StigmataWhereUniqueInput[] | StigmataWhereUniqueInput;
  connect?: StigmataWhereUniqueInput[] | StigmataWhereUniqueInput;
  set?: StigmataWhereUniqueInput[] | StigmataWhereUniqueInput;
  disconnect?: StigmataWhereUniqueInput[] | StigmataWhereUniqueInput;
  deleteMany?: StigmataScalarWhereInput[] | StigmataScalarWhereInput;
}

export interface ResentmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ResentmentWhereInput;
  AND?: ResentmentSubscriptionWhereInput[] | ResentmentSubscriptionWhereInput;
  OR?: ResentmentSubscriptionWhereInput[] | ResentmentSubscriptionWhereInput;
  NOT?: ResentmentSubscriptionWhereInput[] | ResentmentSubscriptionWhereInput;
}

export interface StigmataUpdateWithWhereUniqueNestedInput {
  where: StigmataWhereUniqueInput;
  data: StigmataUpdateDataInput;
}

export interface PledgeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  loyalty_every?: LoyaltyWhereInput;
  loyalty_some?: LoyaltyWhereInput;
  loyalty_none?: LoyaltyWhereInput;
  honor_every?: HonorWhereInput;
  honor_some?: HonorWhereInput;
  honor_none?: HonorWhereInput;
  AND?: PledgeWhereInput[] | PledgeWhereInput;
  OR?: PledgeWhereInput[] | PledgeWhereInput;
  NOT?: PledgeWhereInput[] | PledgeWhereInput;
}

export interface StigmataUpdateDataInput {
  nail?: NailUpdateManyInput;
  crown?: CrownUpdateManyInput;
  cross?: CrossUpdateManyInput;
}

export interface ActSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ActWhereInput;
  AND?: ActSubscriptionWhereInput[] | ActSubscriptionWhereInput;
  OR?: ActSubscriptionWhereInput[] | ActSubscriptionWhereInput;
  NOT?: ActSubscriptionWhereInput[] | ActSubscriptionWhereInput;
}

export interface NailUpdateManyInput {
  create?: NailCreateInput[] | NailCreateInput;
  update?:
    | NailUpdateWithWhereUniqueNestedInput[]
    | NailUpdateWithWhereUniqueNestedInput;
  upsert?:
    | NailUpsertWithWhereUniqueNestedInput[]
    | NailUpsertWithWhereUniqueNestedInput;
  delete?: NailWhereUniqueInput[] | NailWhereUniqueInput;
  connect?: NailWhereUniqueInput[] | NailWhereUniqueInput;
  set?: NailWhereUniqueInput[] | NailWhereUniqueInput;
  disconnect?: NailWhereUniqueInput[] | NailWhereUniqueInput;
  deleteMany?: NailScalarWhereInput[] | NailScalarWhereInput;
}

export interface SarcasmWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  armor_every?: ArmorWhereInput;
  armor_some?: ArmorWhereInput;
  armor_none?: ArmorWhereInput;
  AND?: SarcasmWhereInput[] | SarcasmWhereInput;
  OR?: SarcasmWhereInput[] | SarcasmWhereInput;
  NOT?: SarcasmWhereInput[] | SarcasmWhereInput;
}

export interface NailUpdateWithWhereUniqueNestedInput {
  where: NailWhereUniqueInput;
  data: NailUpdateDataInput;
}

export interface VulnerabilityUpdateInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface NailUpdateDataInput {
  suffering?: SufferingUpdateManyInput;
}

export interface CharactersWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  congregant?: CongregantWhereInput;
  genie?: GenieWhereInput;
  guardian?: GuardianWhereInput;
  martyr?: MartyrWhereInput;
  paladin?: PaladinWhereInput;
  seeker?: SeekerWhereInput;
  self?: SelfWhereInput;
  smith?: SmithWhereInput;
  summoner?: SummonerWhereInput;
  victim?: VictimWhereInput;
  volunteer?: VolunteerWhereInput;
  AND?: CharactersWhereInput[] | CharactersWhereInput;
  OR?: CharactersWhereInput[] | CharactersWhereInput;
  NOT?: CharactersWhereInput[] | CharactersWhereInput;
}

export interface SufferingUpdateManyInput {
  create?: SufferingCreateInput[] | SufferingCreateInput;
  update?:
    | SufferingUpdateWithWhereUniqueNestedInput[]
    | SufferingUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SufferingUpsertWithWhereUniqueNestedInput[]
    | SufferingUpsertWithWhereUniqueNestedInput;
  delete?: SufferingWhereUniqueInput[] | SufferingWhereUniqueInput;
  connect?: SufferingWhereUniqueInput[] | SufferingWhereUniqueInput;
  set?: SufferingWhereUniqueInput[] | SufferingWhereUniqueInput;
  disconnect?: SufferingWhereUniqueInput[] | SufferingWhereUniqueInput;
  deleteMany?: SufferingScalarWhereInput[] | SufferingScalarWhereInput;
  updateMany?:
    | SufferingUpdateManyWithWhereNestedInput[]
    | SufferingUpdateManyWithWhereNestedInput;
}

export interface SmithWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  shield_every?: ShieldWhereInput;
  shield_some?: ShieldWhereInput;
  shield_none?: ShieldWhereInput;
  AND?: SmithWhereInput[] | SmithWhereInput;
  OR?: SmithWhereInput[] | SmithWhereInput;
  NOT?: SmithWhereInput[] | SmithWhereInput;
}

export interface SufferingUpdateWithWhereUniqueNestedInput {
  where: SufferingWhereUniqueInput;
  data: SufferingUpdateDataInput;
}

export type CompassionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SufferingUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type CongregantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SufferingUpsertWithWhereUniqueNestedInput {
  where: SufferingWhereUniqueInput;
  update: SufferingUpdateDataInput;
  create: SufferingCreateInput;
}

export interface SilenceUpdateInput {
  armor?: ArmorUpdateManyInput;
}

export interface SufferingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: SufferingScalarWhereInput[] | SufferingScalarWhereInput;
  OR?: SufferingScalarWhereInput[] | SufferingScalarWhereInput;
  NOT?: SufferingScalarWhereInput[] | SufferingScalarWhereInput;
}

export interface SeekerUpdateInput {
  virtue?: VirtueUpdateManyInput;
}

export interface SufferingUpdateManyWithWhereNestedInput {
  where: SufferingScalarWhereInput;
  data: SufferingUpdateManyDataInput;
}

export interface ResentmentUpdateInput {
  anger?: AngerUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
}

export interface SufferingUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type DeliriumWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NailUpsertWithWhereUniqueNestedInput {
  where: NailWhereUniqueInput;
  update: NailUpdateDataInput;
  create: NailCreateInput;
}

export type DiscontentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface NailScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: NailScalarWhereInput[] | NailScalarWhereInput;
  OR?: NailScalarWhereInput[] | NailScalarWhereInput;
  NOT?: NailScalarWhereInput[] | NailScalarWhereInput;
}

export interface DiscontentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  irritability_every?: IrritabilityWhereInput;
  irritability_some?: IrritabilityWhereInput;
  irritability_none?: IrritabilityWhereInput;
  impatience_every?: ImpatienceWhereInput;
  impatience_some?: ImpatienceWhereInput;
  impatience_none?: ImpatienceWhereInput;
  AND?: DiscontentWhereInput[] | DiscontentWhereInput;
  OR?: DiscontentWhereInput[] | DiscontentWhereInput;
  NOT?: DiscontentWhereInput[] | DiscontentWhereInput;
}

export interface CrownUpdateManyInput {
  create?: CrownCreateInput[] | CrownCreateInput;
  update?:
    | CrownUpdateWithWhereUniqueNestedInput[]
    | CrownUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CrownUpsertWithWhereUniqueNestedInput[]
    | CrownUpsertWithWhereUniqueNestedInput;
  delete?: CrownWhereUniqueInput[] | CrownWhereUniqueInput;
  connect?: CrownWhereUniqueInput[] | CrownWhereUniqueInput;
  set?: CrownWhereUniqueInput[] | CrownWhereUniqueInput;
  disconnect?: CrownWhereUniqueInput[] | CrownWhereUniqueInput;
  deleteMany?: CrownScalarWhereInput[] | CrownScalarWhereInput;
}

export interface LoveCreateInput {
  id?: ID_Input;
  vulnerability?: VulnerabilityCreateManyInput;
  acceptance?: AcceptanceCreateManyInput;
}

export interface CrownUpdateWithWhereUniqueNestedInput {
  where: CrownWhereUniqueInput;
  data: CrownUpdateDataInput;
}

export interface IrritabilityUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface CrownUpdateDataInput {
  suffering?: SufferingUpdateManyInput;
}

export interface StrengthScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: StrengthScalarWhereInput[] | StrengthScalarWhereInput;
  OR?: StrengthScalarWhereInput[] | StrengthScalarWhereInput;
  NOT?: StrengthScalarWhereInput[] | StrengthScalarWhereInput;
}

export interface CrownUpsertWithWhereUniqueNestedInput {
  where: CrownWhereUniqueInput;
  update: CrownUpdateDataInput;
  create: CrownCreateInput;
}

export interface ExperienceUpsertWithWhereUniqueNestedInput {
  where: ExperienceWhereUniqueInput;
  update: ExperienceUpdateDataInput;
  create: ExperienceCreateInput;
}

export interface CrownScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: CrownScalarWhereInput[] | CrownScalarWhereInput;
  OR?: CrownScalarWhereInput[] | CrownScalarWhereInput;
  NOT?: CrownScalarWhereInput[] | CrownScalarWhereInput;
}

export interface ObsessionUpdateWithWhereUniqueNestedInput {
  where: ObsessionWhereUniqueInput;
  data: ObsessionUpdateDataInput;
}

export interface CrossUpdateManyInput {
  create?: CrossCreateInput[] | CrossCreateInput;
  update?:
    | CrossUpdateWithWhereUniqueNestedInput[]
    | CrossUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CrossUpsertWithWhereUniqueNestedInput[]
    | CrossUpsertWithWhereUniqueNestedInput;
  delete?: CrossWhereUniqueInput[] | CrossWhereUniqueInput;
  connect?: CrossWhereUniqueInput[] | CrossWhereUniqueInput;
  set?: CrossWhereUniqueInput[] | CrossWhereUniqueInput;
  disconnect?: CrossWhereUniqueInput[] | CrossWhereUniqueInput;
  deleteMany?: CrossScalarWhereInput[] | CrossScalarWhereInput;
}

export interface DiscontentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: DiscontentScalarWhereInput[] | DiscontentScalarWhereInput;
  OR?: DiscontentScalarWhereInput[] | DiscontentScalarWhereInput;
  NOT?: DiscontentScalarWhereInput[] | DiscontentScalarWhereInput;
}

export interface CrossUpdateWithWhereUniqueNestedInput {
  where: CrossWhereUniqueInput;
  data: CrossUpdateDataInput;
}

export interface DefectUpsertWithWhereUniqueNestedInput {
  where: DefectWhereUniqueInput;
  update: DefectUpdateDataInput;
  create: DefectCreateInput;
}

export interface CrossUpdateDataInput {
  suffering?: SufferingUpdateManyInput;
}

export interface StrengthCreateManyInput {
  create?: StrengthCreateInput[] | StrengthCreateInput;
  connect?: StrengthWhereUniqueInput[] | StrengthWhereUniqueInput;
}

export interface CrossUpsertWithWhereUniqueNestedInput {
  where: CrossWhereUniqueInput;
  update: CrossUpdateDataInput;
  create: CrossCreateInput;
}

export interface DefectCreateManyInput {
  create?: DefectCreateInput[] | DefectCreateInput;
  connect?: DefectWhereUniqueInput[] | DefectWhereUniqueInput;
}

export interface CrossScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: CrossScalarWhereInput[] | CrossScalarWhereInput;
  OR?: CrossScalarWhereInput[] | CrossScalarWhereInput;
  NOT?: CrossScalarWhereInput[] | CrossScalarWhereInput;
}

export interface HonorUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface StigmataUpsertWithWhereUniqueNestedInput {
  where: StigmataWhereUniqueInput;
  update: StigmataUpdateDataInput;
  create: StigmataCreateInput;
}

export interface StigmataSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StigmataWhereInput;
  AND?: StigmataSubscriptionWhereInput[] | StigmataSubscriptionWhereInput;
  OR?: StigmataSubscriptionWhereInput[] | StigmataSubscriptionWhereInput;
  NOT?: StigmataSubscriptionWhereInput[] | StigmataSubscriptionWhereInput;
}

export interface StigmataScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: StigmataScalarWhereInput[] | StigmataScalarWhereInput;
  OR?: StigmataScalarWhereInput[] | StigmataScalarWhereInput;
  NOT?: StigmataScalarWhereInput[] | StigmataScalarWhereInput;
}

export interface StrengthWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  armor_every?: ArmorWhereInput;
  armor_some?: ArmorWhereInput;
  armor_none?: ArmorWhereInput;
  boundary_every?: BoundaryWhereInput;
  boundary_some?: BoundaryWhereInput;
  boundary_none?: BoundaryWhereInput;
  loyalty_every?: LoyaltyWhereInput;
  loyalty_some?: LoyaltyWhereInput;
  loyalty_none?: LoyaltyWhereInput;
  honor_every?: HonorWhereInput;
  honor_some?: HonorWhereInput;
  honor_none?: HonorWhereInput;
  AND?: StrengthWhereInput[] | StrengthWhereInput;
  OR?: StrengthWhereInput[] | StrengthWhereInput;
  NOT?: StrengthWhereInput[] | StrengthWhereInput;
}

export interface MartyrUpsertNestedInput {
  update: MartyrUpdateDataInput;
  create: MartyrCreateInput;
}

export interface PrayerUpsertNestedInput {
  update: PrayerUpdateDataInput;
  create: PrayerCreateInput;
}

export interface PaladinUpdateOneInput {
  create?: PaladinCreateInput;
  update?: PaladinUpdateDataInput;
  upsert?: PaladinUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaladinWhereUniqueInput;
}

export interface JoyScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolveAt?: DateTimeInput;
  resolveAt_not?: DateTimeInput;
  resolveAt_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_lt?: DateTimeInput;
  resolveAt_lte?: DateTimeInput;
  resolveAt_gt?: DateTimeInput;
  resolveAt_gte?: DateTimeInput;
  AND?: JoyScalarWhereInput[] | JoyScalarWhereInput;
  OR?: JoyScalarWhereInput[] | JoyScalarWhereInput;
  NOT?: JoyScalarWhereInput[] | JoyScalarWhereInput;
}

export interface PaladinUpdateDataInput {
  oath?: OathUpdateManyInput;
}

export interface FunUpdateManyWithWhereNestedInput {
  where: FunScalarWhereInput;
  data: FunUpdateManyDataInput;
}

export interface OathUpdateManyInput {
  create?: OathCreateInput[] | OathCreateInput;
  update?:
    | OathUpdateWithWhereUniqueNestedInput[]
    | OathUpdateWithWhereUniqueNestedInput;
  upsert?:
    | OathUpsertWithWhereUniqueNestedInput[]
    | OathUpsertWithWhereUniqueNestedInput;
  delete?: OathWhereUniqueInput[] | OathWhereUniqueInput;
  connect?: OathWhereUniqueInput[] | OathWhereUniqueInput;
  set?: OathWhereUniqueInput[] | OathWhereUniqueInput;
  disconnect?: OathWhereUniqueInput[] | OathWhereUniqueInput;
  deleteMany?: OathScalarWhereInput[] | OathScalarWhereInput;
}

export interface WishSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: WishWhereInput;
  AND?: WishSubscriptionWhereInput[] | WishSubscriptionWhereInput;
  OR?: WishSubscriptionWhereInput[] | WishSubscriptionWhereInput;
  NOT?: WishSubscriptionWhereInput[] | WishSubscriptionWhereInput;
}

export interface OathUpdateWithWhereUniqueNestedInput {
  where: OathWhereUniqueInput;
  data: OathUpdateDataInput;
}

export interface StrengthUpdateDataInput {
  armor?: ArmorUpdateManyInput;
  boundary?: BoundaryUpdateManyInput;
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
}

export interface OathUpdateDataInput {
  pledge?: PledgeUpdateManyInput;
  campaign?: CampaignUpdateManyInput;
  crusade?: CrusadeUpdateManyInput;
}

export type LoyaltyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PledgeUpdateManyInput {
  create?: PledgeCreateInput[] | PledgeCreateInput;
  update?:
    | PledgeUpdateWithWhereUniqueNestedInput[]
    | PledgeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PledgeUpsertWithWhereUniqueNestedInput[]
    | PledgeUpsertWithWhereUniqueNestedInput;
  delete?: PledgeWhereUniqueInput[] | PledgeWhereUniqueInput;
  connect?: PledgeWhereUniqueInput[] | PledgeWhereUniqueInput;
  set?: PledgeWhereUniqueInput[] | PledgeWhereUniqueInput;
  disconnect?: PledgeWhereUniqueInput[] | PledgeWhereUniqueInput;
  deleteMany?: PledgeScalarWhereInput[] | PledgeScalarWhereInput;
}

export interface ResentmentUpdateOneInput {
  create?: ResentmentCreateInput;
  update?: ResentmentUpdateDataInput;
  upsert?: ResentmentUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ResentmentWhereUniqueInput;
}

export interface PledgeUpdateWithWhereUniqueNestedInput {
  where: PledgeWhereUniqueInput;
  data: PledgeUpdateDataInput;
}

export type MouthWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PledgeUpdateDataInput {
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
}

export type NightmareWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PledgeUpsertWithWhereUniqueNestedInput {
  where: PledgeWhereUniqueInput;
  update: PledgeUpdateDataInput;
  create: PledgeCreateInput;
}

export type ObsessionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PledgeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: PledgeScalarWhereInput[] | PledgeScalarWhereInput;
  OR?: PledgeScalarWhereInput[] | PledgeScalarWhereInput;
  NOT?: PledgeScalarWhereInput[] | PledgeScalarWhereInput;
}

export interface BodyUpsertNestedInput {
  update: BodyUpdateDataInput;
  create: BodyCreateInput;
}

export interface CampaignUpdateManyInput {
  create?: CampaignCreateInput[] | CampaignCreateInput;
  update?:
    | CampaignUpdateWithWhereUniqueNestedInput[]
    | CampaignUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CampaignUpsertWithWhereUniqueNestedInput[]
    | CampaignUpsertWithWhereUniqueNestedInput;
  delete?: CampaignWhereUniqueInput[] | CampaignWhereUniqueInput;
  connect?: CampaignWhereUniqueInput[] | CampaignWhereUniqueInput;
  set?: CampaignWhereUniqueInput[] | CampaignWhereUniqueInput;
  disconnect?: CampaignWhereUniqueInput[] | CampaignWhereUniqueInput;
  deleteMany?: CampaignScalarWhereInput[] | CampaignScalarWhereInput;
}

export interface ActUpdateOneInput {
  create?: ActCreateInput;
  update?: ActUpdateDataInput;
  upsert?: ActUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ActWhereUniqueInput;
}

export interface CampaignUpdateWithWhereUniqueNestedInput {
  where: CampaignWhereUniqueInput;
  data: CampaignUpdateDataInput;
}

export interface HigherPowerUpdateInput {
  prayer?: PrayerUpdateOneInput;
  inventory?: FeelingUpdateManyInput;
  character?: CharactersUpdateOneInput;
}

export interface CampaignUpdateDataInput {
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
}

export type ResentmentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CampaignUpsertWithWhereUniqueNestedInput {
  where: CampaignWhereUniqueInput;
  update: CampaignUpdateDataInput;
  create: CampaignCreateInput;
}

export interface HeartWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  anger_every?: AngerWhereInput;
  anger_some?: AngerWhereInput;
  anger_none?: AngerWhereInput;
  fear_every?: FearWhereInput;
  fear_some?: FearWhereInput;
  fear_none?: FearWhereInput;
  pride_every?: PrideWhereInput;
  pride_some?: PrideWhereInput;
  pride_none?: PrideWhereInput;
  selfPity_every?: SelfPityWhereInput;
  selfPity_some?: SelfPityWhereInput;
  selfPity_none?: SelfPityWhereInput;
  AND?: HeartWhereInput[] | HeartWhereInput;
  OR?: HeartWhereInput[] | HeartWhereInput;
  NOT?: HeartWhereInput[] | HeartWhereInput;
}

export interface CampaignScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: CampaignScalarWhereInput[] | CampaignScalarWhereInput;
  OR?: CampaignScalarWhereInput[] | CampaignScalarWhereInput;
  NOT?: CampaignScalarWhereInput[] | CampaignScalarWhereInput;
}

export interface MouthSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: MouthWhereInput;
  AND?: MouthSubscriptionWhereInput[] | MouthSubscriptionWhereInput;
  OR?: MouthSubscriptionWhereInput[] | MouthSubscriptionWhereInput;
  NOT?: MouthSubscriptionWhereInput[] | MouthSubscriptionWhereInput;
}

export interface CrusadeUpdateManyInput {
  create?: CrusadeCreateInput[] | CrusadeCreateInput;
  update?:
    | CrusadeUpdateWithWhereUniqueNestedInput[]
    | CrusadeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CrusadeUpsertWithWhereUniqueNestedInput[]
    | CrusadeUpsertWithWhereUniqueNestedInput;
  delete?: CrusadeWhereUniqueInput[] | CrusadeWhereUniqueInput;
  connect?: CrusadeWhereUniqueInput[] | CrusadeWhereUniqueInput;
  set?: CrusadeWhereUniqueInput[] | CrusadeWhereUniqueInput;
  disconnect?: CrusadeWhereUniqueInput[] | CrusadeWhereUniqueInput;
  deleteMany?: CrusadeScalarWhereInput[] | CrusadeScalarWhereInput;
}

export interface OathCreateOneInput {
  create?: OathCreateInput;
  connect?: OathWhereUniqueInput;
}

export interface CrusadeUpdateWithWhereUniqueNestedInput {
  where: CrusadeWhereUniqueInput;
  data: CrusadeUpdateDataInput;
}

export interface ImpatienceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ImpatienceWhereInput;
  AND?: ImpatienceSubscriptionWhereInput[] | ImpatienceSubscriptionWhereInput;
  OR?: ImpatienceSubscriptionWhereInput[] | ImpatienceSubscriptionWhereInput;
  NOT?: ImpatienceSubscriptionWhereInput[] | ImpatienceSubscriptionWhereInput;
}

export interface CrusadeUpdateDataInput {
  loyalty?: LoyaltyUpdateManyInput;
  honor?: HonorUpdateManyInput;
}

export interface HasUpdateManyMutationInput {
  defect?: Boolean;
  discontent?: Boolean;
  resentment?: Boolean;
  obsession?: Boolean;
  experience?: Boolean;
  strength?: Boolean;
  hope?: Boolean;
  acceptance?: Boolean;
  anger?: Boolean;
  armor?: Boolean;
  boundary?: Boolean;
  compassion?: Boolean;
  courage?: Boolean;
  fear?: Boolean;
  fun?: Boolean;
  gratitude?: Boolean;
  irritability?: Boolean;
  impatience?: Boolean;
  joy?: Boolean;
  pride?: Boolean;
  salvaltion?: Boolean;
  selfPity?: Boolean;
  suffering?: Boolean;
  toxicity?: Boolean;
  trauma?: Boolean;
  vulnerability?: Boolean;
}

export interface CrusadeUpsertWithWhereUniqueNestedInput {
  where: CrusadeWhereUniqueInput;
  update: CrusadeUpdateDataInput;
  create: CrusadeCreateInput;
}

export interface SkinWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  anger_every?: AngerWhereInput;
  anger_some?: AngerWhereInput;
  anger_none?: AngerWhereInput;
  fear_every?: FearWhereInput;
  fear_some?: FearWhereInput;
  fear_none?: FearWhereInput;
  pride_every?: PrideWhereInput;
  pride_some?: PrideWhereInput;
  pride_none?: PrideWhereInput;
  selfPity_every?: SelfPityWhereInput;
  selfPity_some?: SelfPityWhereInput;
  selfPity_none?: SelfPityWhereInput;
  AND?: SkinWhereInput[] | SkinWhereInput;
  OR?: SkinWhereInput[] | SkinWhereInput;
  NOT?: SkinWhereInput[] | SkinWhereInput;
}

export interface CrusadeScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: CrusadeScalarWhereInput[] | CrusadeScalarWhereInput;
  OR?: CrusadeScalarWhereInput[] | CrusadeScalarWhereInput;
  NOT?: CrusadeScalarWhereInput[] | CrusadeScalarWhereInput;
}

export interface FunUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface OathUpsertWithWhereUniqueNestedInput {
  where: OathWhereUniqueInput;
  update: OathUpdateDataInput;
  create: OathCreateInput;
}

export interface FearUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface OathScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: OathScalarWhereInput[] | OathScalarWhereInput;
  OR?: OathScalarWhereInput[] | OathScalarWhereInput;
  NOT?: OathScalarWhereInput[] | OathScalarWhereInput;
}

export interface GratitudeUpsertWithWhereUniqueNestedInput {
  where: GratitudeWhereUniqueInput;
  update: GratitudeUpdateDataInput;
  create: GratitudeCreateInput;
}

export interface PaladinUpsertNestedInput {
  update: PaladinUpdateDataInput;
  create: PaladinCreateInput;
}

export interface GratitudeCreateInput {
  id?: ID_Input;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SeekerUpdateOneInput {
  create?: SeekerCreateInput;
  update?: SeekerUpdateDataInput;
  upsert?: SeekerUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SeekerWhereUniqueInput;
}

export interface ImpatienceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolveAt?: DateTimeInput;
  resolveAt_not?: DateTimeInput;
  resolveAt_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_lt?: DateTimeInput;
  resolveAt_lte?: DateTimeInput;
  resolveAt_gt?: DateTimeInput;
  resolveAt_gte?: DateTimeInput;
  AND?: ImpatienceScalarWhereInput[] | ImpatienceScalarWhereInput;
  OR?: ImpatienceScalarWhereInput[] | ImpatienceScalarWhereInput;
  NOT?: ImpatienceScalarWhereInput[] | ImpatienceScalarWhereInput;
}

export interface SeekerUpdateDataInput {
  virtue?: VirtueUpdateManyInput;
}

export interface IrritabilityUpdateManyWithWhereNestedInput {
  where: IrritabilityScalarWhereInput;
  data: IrritabilityUpdateManyDataInput;
}

export interface VirtueUpdateManyInput {
  create?: VirtueCreateInput[] | VirtueCreateInput;
  update?:
    | VirtueUpdateWithWhereUniqueNestedInput[]
    | VirtueUpdateWithWhereUniqueNestedInput;
  upsert?:
    | VirtueUpsertWithWhereUniqueNestedInput[]
    | VirtueUpsertWithWhereUniqueNestedInput;
  delete?: VirtueWhereUniqueInput[] | VirtueWhereUniqueInput;
  connect?: VirtueWhereUniqueInput[] | VirtueWhereUniqueInput;
  set?: VirtueWhereUniqueInput[] | VirtueWhereUniqueInput;
  disconnect?: VirtueWhereUniqueInput[] | VirtueWhereUniqueInput;
  deleteMany?: VirtueScalarWhereInput[] | VirtueScalarWhereInput;
}

export interface VulnerabilitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VulnerabilityWhereInput;
  AND?:
    | VulnerabilitySubscriptionWhereInput[]
    | VulnerabilitySubscriptionWhereInput;
  OR?:
    | VulnerabilitySubscriptionWhereInput[]
    | VulnerabilitySubscriptionWhereInput;
  NOT?:
    | VulnerabilitySubscriptionWhereInput[]
    | VulnerabilitySubscriptionWhereInput;
}

export interface VirtueUpdateWithWhereUniqueNestedInput {
  where: VirtueWhereUniqueInput;
  data: VirtueUpdateDataInput;
}

export type VolunteerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VirtueUpdateDataInput {
  nail?: NailUpdateManyInput;
  crown?: CrownUpdateManyInput;
  cross?: CrossUpdateManyInput;
}

export interface GratitudeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: GratitudeWhereInput;
  AND?: GratitudeSubscriptionWhereInput[] | GratitudeSubscriptionWhereInput;
  OR?: GratitudeSubscriptionWhereInput[] | GratitudeSubscriptionWhereInput;
  NOT?: GratitudeSubscriptionWhereInput[] | GratitudeSubscriptionWhereInput;
}

export interface VirtueUpsertWithWhereUniqueNestedInput {
  where: VirtueWhereUniqueInput;
  update: VirtueUpdateDataInput;
  create: VirtueCreateInput;
}

export type CharactersWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VirtueScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: VirtueScalarWhereInput[] | VirtueScalarWhereInput;
  OR?: VirtueScalarWhereInput[] | VirtueScalarWhereInput;
  NOT?: VirtueScalarWhereInput[] | VirtueScalarWhereInput;
}

export interface TowerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  boundary_every?: BoundaryWhereInput;
  boundary_some?: BoundaryWhereInput;
  boundary_none?: BoundaryWhereInput;
  AND?: TowerWhereInput[] | TowerWhereInput;
  OR?: TowerWhereInput[] | TowerWhereInput;
  NOT?: TowerWhereInput[] | TowerWhereInput;
}

export interface SeekerUpsertNestedInput {
  update: SeekerUpdateDataInput;
  create: SeekerCreateInput;
}

export interface ProcessSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProcessWhereInput;
  AND?: ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput;
  OR?: ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput;
  NOT?: ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput;
}

export interface SelfUpdateOneInput {
  create?: SelfCreateInput;
  update?: SelfUpdateDataInput;
  upsert?: SelfUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SelfWhereUniqueInput;
}

export interface SarcasmSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SarcasmWhereInput;
  AND?: SarcasmSubscriptionWhereInput[] | SarcasmSubscriptionWhereInput;
  OR?: SarcasmSubscriptionWhereInput[] | SarcasmSubscriptionWhereInput;
  NOT?: SarcasmSubscriptionWhereInput[] | SarcasmSubscriptionWhereInput;
}

export interface SelfUpdateDataInput {
  body?: BodyUpdateManyInput;
}

export interface WallUpdateInput {
  boundary?: BoundaryUpdateManyInput;
}

export interface BodyUpdateManyInput {
  create?: BodyCreateInput[] | BodyCreateInput;
  update?:
    | BodyUpdateWithWhereUniqueNestedInput[]
    | BodyUpdateWithWhereUniqueNestedInput;
  upsert?:
    | BodyUpsertWithWhereUniqueNestedInput[]
    | BodyUpsertWithWhereUniqueNestedInput;
  delete?: BodyWhereUniqueInput[] | BodyWhereUniqueInput;
  connect?: BodyWhereUniqueInput[] | BodyWhereUniqueInput;
  set?: BodyWhereUniqueInput[] | BodyWhereUniqueInput;
  disconnect?: BodyWhereUniqueInput[] | BodyWhereUniqueInput;
  deleteMany?: BodyScalarWhereInput[] | BodyScalarWhereInput;
}

export interface MartyrWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  stigmata_every?: StigmataWhereInput;
  stigmata_some?: StigmataWhereInput;
  stigmata_none?: StigmataWhereInput;
  AND?: MartyrWhereInput[] | MartyrWhereInput;
  OR?: MartyrWhereInput[] | MartyrWhereInput;
  NOT?: MartyrWhereInput[] | MartyrWhereInput;
}

export interface BodyUpdateWithWhereUniqueNestedInput {
  where: BodyWhereUniqueInput;
  data: BodyUpdateDataInput;
}

export type ConfusionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BodyUpdateDataInput {
  brain?: BrainUpdateManyInput;
  face?: FaceUpdateManyInput;
  mouth?: MouthUpdateManyInput;
  soul?: SoulUpdateManyInput;
  heart?: HeartUpdateManyInput;
  sternum?: SternumUpdateManyInput;
  gut?: GutUpdateManyInput;
}

export interface SelfPityUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface BodyUpsertWithWhereUniqueNestedInput {
  where: BodyWhereUniqueInput;
  update: BodyUpdateDataInput;
  create: BodyCreateInput;
}

export interface ShieldSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShieldWhereInput;
  AND?: ShieldSubscriptionWhereInput[] | ShieldSubscriptionWhereInput;
  OR?: ShieldSubscriptionWhereInput[] | ShieldSubscriptionWhereInput;
  NOT?: ShieldSubscriptionWhereInput[] | ShieldSubscriptionWhereInput;
}

export interface BodyScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: BodyScalarWhereInput[] | BodyScalarWhereInput;
  OR?: BodyScalarWhereInput[] | BodyScalarWhereInput;
  NOT?: BodyScalarWhereInput[] | BodyScalarWhereInput;
}

export interface MouthUpdateInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface SelfUpsertNestedInput {
  update: SelfUpdateDataInput;
  create: SelfCreateInput;
}

export interface ScarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  trauma_every?: TraumaWhereInput;
  trauma_some?: TraumaWhereInput;
  trauma_none?: TraumaWhereInput;
  toxicity_every?: ToxicityWhereInput;
  toxicity_some?: ToxicityWhereInput;
  toxicity_none?: ToxicityWhereInput;
  AND?: ScarWhereInput[] | ScarWhereInput;
  OR?: ScarWhereInput[] | ScarWhereInput;
  NOT?: ScarWhereInput[] | ScarWhereInput;
}

export interface SmithUpdateOneInput {
  create?: SmithCreateInput;
  update?: SmithUpdateDataInput;
  upsert?: SmithUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SmithWhereUniqueInput;
}

export interface StrengthUpdateManyInput {
  create?: StrengthCreateInput[] | StrengthCreateInput;
  update?:
    | StrengthUpdateWithWhereUniqueNestedInput[]
    | StrengthUpdateWithWhereUniqueNestedInput;
  upsert?:
    | StrengthUpsertWithWhereUniqueNestedInput[]
    | StrengthUpsertWithWhereUniqueNestedInput;
  delete?: StrengthWhereUniqueInput[] | StrengthWhereUniqueInput;
  connect?: StrengthWhereUniqueInput[] | StrengthWhereUniqueInput;
  set?: StrengthWhereUniqueInput[] | StrengthWhereUniqueInput;
  disconnect?: StrengthWhereUniqueInput[] | StrengthWhereUniqueInput;
  deleteMany?: StrengthScalarWhereInput[] | StrengthScalarWhereInput;
}

export interface SmithUpdateDataInput {
  shield?: ShieldUpdateManyInput;
}

export interface ResentmentUpsertWithWhereUniqueNestedInput {
  where: ResentmentWhereUniqueInput;
  update: ResentmentUpdateDataInput;
  create: ResentmentCreateInput;
}

export interface ShieldUpdateManyInput {
  create?: ShieldCreateInput[] | ShieldCreateInput;
  update?:
    | ShieldUpdateWithWhereUniqueNestedInput[]
    | ShieldUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ShieldUpsertWithWhereUniqueNestedInput[]
    | ShieldUpsertWithWhereUniqueNestedInput;
  delete?: ShieldWhereUniqueInput[] | ShieldWhereUniqueInput;
  connect?: ShieldWhereUniqueInput[] | ShieldWhereUniqueInput;
  set?: ShieldWhereUniqueInput[] | ShieldWhereUniqueInput;
  disconnect?: ShieldWhereUniqueInput[] | ShieldWhereUniqueInput;
  deleteMany?: ShieldScalarWhereInput[] | ShieldScalarWhereInput;
}

export interface DefectUpdateManyInput {
  create?: DefectCreateInput[] | DefectCreateInput;
  update?:
    | DefectUpdateWithWhereUniqueNestedInput[]
    | DefectUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DefectUpsertWithWhereUniqueNestedInput[]
    | DefectUpsertWithWhereUniqueNestedInput;
  delete?: DefectWhereUniqueInput[] | DefectWhereUniqueInput;
  connect?: DefectWhereUniqueInput[] | DefectWhereUniqueInput;
  set?: DefectWhereUniqueInput[] | DefectWhereUniqueInput;
  disconnect?: DefectWhereUniqueInput[] | DefectWhereUniqueInput;
  deleteMany?: DefectScalarWhereInput[] | DefectScalarWhereInput;
}

export interface ShieldUpdateWithWhereUniqueNestedInput {
  where: ShieldWhereUniqueInput;
  data: ShieldUpdateDataInput;
}

export interface ImpatienceUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export interface ShieldUpdateDataInput {
  silence?: SilenceUpdateManyInput;
  sarcasm?: SarcasmUpdateManyInput;
  denial?: DenialUpdateManyInput;
  confusion?: ConfusionUpdateManyInput;
}

export interface ProcessWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  act?: ActWhereInput;
  affliction?: AfflictionWhereInput;
  body?: BodyWhereInput;
  construct?: ConstructWhereInput;
  oath?: OathWhereInput;
  shield?: ShieldWhereInput;
  stigmata?: StigmataWhereInput;
  virtue?: VirtueWhereInput;
  wish?: WishWhereInput;
  AND?: ProcessWhereInput[] | ProcessWhereInput;
  OR?: ProcessWhereInput[] | ProcessWhereInput;
  NOT?: ProcessWhereInput[] | ProcessWhereInput;
}

export interface SilenceUpdateManyInput {
  create?: SilenceCreateInput[] | SilenceCreateInput;
  update?:
    | SilenceUpdateWithWhereUniqueNestedInput[]
    | SilenceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SilenceUpsertWithWhereUniqueNestedInput[]
    | SilenceUpsertWithWhereUniqueNestedInput;
  delete?: SilenceWhereUniqueInput[] | SilenceWhereUniqueInput;
  connect?: SilenceWhereUniqueInput[] | SilenceWhereUniqueInput;
  set?: SilenceWhereUniqueInput[] | SilenceWhereUniqueInput;
  disconnect?: SilenceWhereUniqueInput[] | SilenceWhereUniqueInput;
  deleteMany?: SilenceScalarWhereInput[] | SilenceScalarWhereInput;
}

export interface HopeUpsertNestedInput {
  update: HopeUpdateDataInput;
  create: HopeCreateInput;
}

export interface SilenceUpdateWithWhereUniqueNestedInput {
  where: SilenceWhereUniqueInput;
  data: SilenceUpdateDataInput;
}

export interface InventoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  defect_every?: DefectWhereInput;
  defect_some?: DefectWhereInput;
  defect_none?: DefectWhereInput;
  discontent_every?: DiscontentWhereInput;
  discontent_some?: DiscontentWhereInput;
  discontent_none?: DiscontentWhereInput;
  resentment_every?: ResentmentWhereInput;
  resentment_some?: ResentmentWhereInput;
  resentment_none?: ResentmentWhereInput;
  obsession_every?: ObsessionWhereInput;
  obsession_some?: ObsessionWhereInput;
  obsession_none?: ObsessionWhereInput;
  experience_every?: ExperienceWhereInput;
  experience_some?: ExperienceWhereInput;
  experience_none?: ExperienceWhereInput;
  strength_every?: StrengthWhereInput;
  strength_some?: StrengthWhereInput;
  strength_none?: StrengthWhereInput;
  hope_every?: HopeWhereInput;
  hope_some?: HopeWhereInput;
  hope_none?: HopeWhereInput;
  AND?: InventoryWhereInput[] | InventoryWhereInput;
  OR?: InventoryWhereInput[] | InventoryWhereInput;
  NOT?: InventoryWhereInput[] | InventoryWhereInput;
}

export interface SilenceUpdateDataInput {
  armor?: ArmorUpdateManyInput;
}

export interface CompassionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: CompassionWhereInput[] | CompassionWhereInput;
  OR?: CompassionWhereInput[] | CompassionWhereInput;
  NOT?: CompassionWhereInput[] | CompassionWhereInput;
}

export interface ArmorUpdateManyInput {
  create?: ArmorCreateInput[] | ArmorCreateInput;
  update?:
    | ArmorUpdateWithWhereUniqueNestedInput[]
    | ArmorUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ArmorUpsertWithWhereUniqueNestedInput[]
    | ArmorUpsertWithWhereUniqueNestedInput;
  delete?: ArmorWhereUniqueInput[] | ArmorWhereUniqueInput;
  connect?: ArmorWhereUniqueInput[] | ArmorWhereUniqueInput;
  set?: ArmorWhereUniqueInput[] | ArmorWhereUniqueInput;
  disconnect?: ArmorWhereUniqueInput[] | ArmorWhereUniqueInput;
  deleteMany?: ArmorScalarWhereInput[] | ArmorScalarWhereInput;
  updateMany?:
    | ArmorUpdateManyWithWhereNestedInput[]
    | ArmorUpdateManyWithWhereNestedInput;
}

export interface ServiceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  courage_every?: CourageWhereInput;
  courage_some?: CourageWhereInput;
  courage_none?: CourageWhereInput;
  compassion_every?: CompassionWhereInput;
  compassion_some?: CompassionWhereInput;
  compassion_none?: CompassionWhereInput;
  AND?: ServiceWhereInput[] | ServiceWhereInput;
  OR?: ServiceWhereInput[] | ServiceWhereInput;
  NOT?: ServiceWhereInput[] | ServiceWhereInput;
}

export interface ArmorUpdateWithWhereUniqueNestedInput {
  where: ArmorWhereUniqueInput;
  data: ArmorUpdateDataInput;
}

export type OathWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ArmorUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface AfflictionUpsertNestedInput {
  update: AfflictionUpdateDataInput;
  create: AfflictionCreateInput;
}

export interface ArmorUpsertWithWhereUniqueNestedInput {
  where: ArmorWhereUniqueInput;
  update: ArmorUpdateDataInput;
  create: ArmorCreateInput;
}

export interface TraumaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TraumaWhereInput;
  AND?: TraumaSubscriptionWhereInput[] | TraumaSubscriptionWhereInput;
  OR?: TraumaSubscriptionWhereInput[] | TraumaSubscriptionWhereInput;
  NOT?: TraumaSubscriptionWhereInput[] | TraumaSubscriptionWhereInput;
}

export interface ArmorScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: ArmorScalarWhereInput[] | ArmorScalarWhereInput;
  OR?: ArmorScalarWhereInput[] | ArmorScalarWhereInput;
  NOT?: ArmorScalarWhereInput[] | ArmorScalarWhereInput;
}

export interface NailSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: NailWhereInput;
  AND?: NailSubscriptionWhereInput[] | NailSubscriptionWhereInput;
  OR?: NailSubscriptionWhereInput[] | NailSubscriptionWhereInput;
  NOT?: NailSubscriptionWhereInput[] | NailSubscriptionWhereInput;
}

export interface ArmorUpdateManyWithWhereNestedInput {
  where: ArmorScalarWhereInput;
  data: ArmorUpdateManyDataInput;
}

export interface BodyCreateOneInput {
  create?: BodyCreateInput;
  connect?: BodyWhereUniqueInput;
}

export interface ArmorUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface GutUpdateInput {
  anger?: AngerUpdateManyInput;
  fear?: FearUpdateManyInput;
  pride?: PrideUpdateManyInput;
  selfPity?: SelfPityUpdateManyInput;
}

export interface SilenceUpsertWithWhereUniqueNestedInput {
  where: SilenceWhereUniqueInput;
  update: SilenceUpdateDataInput;
  create: SilenceCreateInput;
}

export interface FeelingUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SilenceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: SilenceScalarWhereInput[] | SilenceScalarWhereInput;
  OR?: SilenceScalarWhereInput[] | SilenceScalarWhereInput;
  NOT?: SilenceScalarWhereInput[] | SilenceScalarWhereInput;
}

export interface GratitudeUpdateManyInput {
  create?: GratitudeCreateInput[] | GratitudeCreateInput;
  update?:
    | GratitudeUpdateWithWhereUniqueNestedInput[]
    | GratitudeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | GratitudeUpsertWithWhereUniqueNestedInput[]
    | GratitudeUpsertWithWhereUniqueNestedInput;
  delete?: GratitudeWhereUniqueInput[] | GratitudeWhereUniqueInput;
  connect?: GratitudeWhereUniqueInput[] | GratitudeWhereUniqueInput;
  set?: GratitudeWhereUniqueInput[] | GratitudeWhereUniqueInput;
  disconnect?: GratitudeWhereUniqueInput[] | GratitudeWhereUniqueInput;
  deleteMany?: GratitudeScalarWhereInput[] | GratitudeScalarWhereInput;
  updateMany?:
    | GratitudeUpdateManyWithWhereNestedInput[]
    | GratitudeUpdateManyWithWhereNestedInput;
}

export interface SarcasmUpdateManyInput {
  create?: SarcasmCreateInput[] | SarcasmCreateInput;
  update?:
    | SarcasmUpdateWithWhereUniqueNestedInput[]
    | SarcasmUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SarcasmUpsertWithWhereUniqueNestedInput[]
    | SarcasmUpsertWithWhereUniqueNestedInput;
  delete?: SarcasmWhereUniqueInput[] | SarcasmWhereUniqueInput;
  connect?: SarcasmWhereUniqueInput[] | SarcasmWhereUniqueInput;
  set?: SarcasmWhereUniqueInput[] | SarcasmWhereUniqueInput;
  disconnect?: SarcasmWhereUniqueInput[] | SarcasmWhereUniqueInput;
  deleteMany?: SarcasmScalarWhereInput[] | SarcasmScalarWhereInput;
}

export interface ImpatienceUpdateWithWhereUniqueNestedInput {
  where: ImpatienceWhereUniqueInput;
  data: ImpatienceUpdateDataInput;
}

export interface SarcasmUpdateWithWhereUniqueNestedInput {
  where: SarcasmWhereUniqueInput;
  data: SarcasmUpdateDataInput;
}

export type VirtueWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SarcasmUpdateDataInput {
  armor?: ArmorUpdateManyInput;
}

export interface HonorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: HonorWhereInput[] | HonorWhereInput;
  OR?: HonorWhereInput[] | HonorWhereInput;
  NOT?: HonorWhereInput[] | HonorWhereInput;
}

export interface SarcasmUpsertWithWhereUniqueNestedInput {
  where: SarcasmWhereUniqueInput;
  update: SarcasmUpdateDataInput;
  create: SarcasmCreateInput;
}

export interface AngerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: AngerWhereInput[] | AngerWhereInput;
  OR?: AngerWhereInput[] | AngerWhereInput;
  NOT?: AngerWhereInput[] | AngerWhereInput;
}

export interface SarcasmScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: SarcasmScalarWhereInput[] | SarcasmScalarWhereInput;
  OR?: SarcasmScalarWhereInput[] | SarcasmScalarWhereInput;
  NOT?: SarcasmScalarWhereInput[] | SarcasmScalarWhereInput;
}

export interface AcceptanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AcceptanceWhereInput;
  AND?: AcceptanceSubscriptionWhereInput[] | AcceptanceSubscriptionWhereInput;
  OR?: AcceptanceSubscriptionWhereInput[] | AcceptanceSubscriptionWhereInput;
  NOT?: AcceptanceSubscriptionWhereInput[] | AcceptanceSubscriptionWhereInput;
}

export interface DenialUpdateManyInput {
  create?: DenialCreateInput[] | DenialCreateInput;
  update?:
    | DenialUpdateWithWhereUniqueNestedInput[]
    | DenialUpdateWithWhereUniqueNestedInput;
  upsert?:
    | DenialUpsertWithWhereUniqueNestedInput[]
    | DenialUpsertWithWhereUniqueNestedInput;
  delete?: DenialWhereUniqueInput[] | DenialWhereUniqueInput;
  connect?: DenialWhereUniqueInput[] | DenialWhereUniqueInput;
  set?: DenialWhereUniqueInput[] | DenialWhereUniqueInput;
  disconnect?: DenialWhereUniqueInput[] | DenialWhereUniqueInput;
  deleteMany?: DenialScalarWhereInput[] | DenialScalarWhereInput;
}

export interface GashWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  trauma_every?: TraumaWhereInput;
  trauma_some?: TraumaWhereInput;
  trauma_none?: TraumaWhereInput;
  toxicity_every?: ToxicityWhereInput;
  toxicity_some?: ToxicityWhereInput;
  toxicity_none?: ToxicityWhereInput;
  AND?: GashWhereInput[] | GashWhereInput;
  OR?: GashWhereInput[] | GashWhereInput;
  NOT?: GashWhereInput[] | GashWhereInput;
}

export interface DenialUpdateWithWhereUniqueNestedInput {
  where: DenialWhereUniqueInput;
  data: DenialUpdateDataInput;
}

export interface SalvationUpdateManyMutationInput {
  thought?: String;
  character?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface DenialUpdateDataInput {
  armor?: ArmorUpdateManyInput;
}

export interface LoyaltyUpdateManyMutationInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface DenialUpsertWithWhereUniqueNestedInput {
  where: DenialWhereUniqueInput;
  update: DenialUpdateDataInput;
  create: DenialCreateInput;
}

export interface FunWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolveAt?: DateTimeInput;
  resolveAt_not?: DateTimeInput;
  resolveAt_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolveAt_lt?: DateTimeInput;
  resolveAt_lte?: DateTimeInput;
  resolveAt_gt?: DateTimeInput;
  resolveAt_gte?: DateTimeInput;
  AND?: FunWhereInput[] | FunWhereInput;
  OR?: FunWhereInput[] | FunWhereInput;
  NOT?: FunWhereInput[] | FunWhereInput;
}

export interface DenialScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: DenialScalarWhereInput[] | DenialScalarWhereInput;
  OR?: DenialScalarWhereInput[] | DenialScalarWhereInput;
  NOT?: DenialScalarWhereInput[] | DenialScalarWhereInput;
}

export interface ResentmentCreateManyInput {
  create?: ResentmentCreateInput[] | ResentmentCreateInput;
  connect?: ResentmentWhereUniqueInput[] | ResentmentWhereUniqueInput;
}

export interface ConfusionUpdateManyInput {
  create?: ConfusionCreateInput[] | ConfusionCreateInput;
  update?:
    | ConfusionUpdateWithWhereUniqueNestedInput[]
    | ConfusionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ConfusionUpsertWithWhereUniqueNestedInput[]
    | ConfusionUpsertWithWhereUniqueNestedInput;
  delete?: ConfusionWhereUniqueInput[] | ConfusionWhereUniqueInput;
  connect?: ConfusionWhereUniqueInput[] | ConfusionWhereUniqueInput;
  set?: ConfusionWhereUniqueInput[] | ConfusionWhereUniqueInput;
  disconnect?: ConfusionWhereUniqueInput[] | ConfusionWhereUniqueInput;
  deleteMany?: ConfusionScalarWhereInput[] | ConfusionScalarWhereInput;
}

export interface FeelingUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ConfusionUpdateWithWhereUniqueNestedInput {
  where: ConfusionWhereUniqueInput;
  data: ConfusionUpdateDataInput;
}

export interface HopeUpdateDataInput {
  salvation?: SalvationUpdateManyInput;
  fun?: FunUpdateManyInput;
  joy?: JoyUpdateManyInput;
}

export interface ConfusionUpdateDataInput {
  armor?: ArmorUpdateManyInput;
}

export type NailWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ConfusionUpsertWithWhereUniqueNestedInput {
  where: ConfusionWhereUniqueInput;
  update: ConfusionUpdateDataInput;
  create: ConfusionCreateInput;
}

export interface ProcessUpdateOneInput {
  create?: ProcessCreateInput;
  update?: ProcessUpdateDataInput;
  upsert?: ProcessUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ProcessWhereUniqueInput;
}

export interface ConfusionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ConfusionScalarWhereInput[] | ConfusionScalarWhereInput;
  OR?: ConfusionScalarWhereInput[] | ConfusionScalarWhereInput;
  NOT?: ConfusionScalarWhereInput[] | ConfusionScalarWhereInput;
}

export interface FaceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  anger_every?: AngerWhereInput;
  anger_some?: AngerWhereInput;
  anger_none?: AngerWhereInput;
  fear_every?: FearWhereInput;
  fear_some?: FearWhereInput;
  fear_none?: FearWhereInput;
  pride_every?: PrideWhereInput;
  pride_some?: PrideWhereInput;
  pride_none?: PrideWhereInput;
  selfPity_every?: SelfPityWhereInput;
  selfPity_some?: SelfPityWhereInput;
  selfPity_none?: SelfPityWhereInput;
  AND?: FaceWhereInput[] | FaceWhereInput;
  OR?: FaceWhereInput[] | FaceWhereInput;
  NOT?: FaceWhereInput[] | FaceWhereInput;
}

export interface ShieldUpsertWithWhereUniqueNestedInput {
  where: ShieldWhereUniqueInput;
  update: ShieldUpdateDataInput;
  create: ShieldCreateInput;
}

export interface GateUpdateInput {
  boundary?: BoundaryUpdateManyInput;
}

export interface ShieldScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: ShieldScalarWhereInput[] | ShieldScalarWhereInput;
  OR?: ShieldScalarWhereInput[] | ShieldScalarWhereInput;
  NOT?: ShieldScalarWhereInput[] | ShieldScalarWhereInput;
}

export interface DreamUpdateInput {
  salvation?: SalvationUpdateManyInput;
}

export interface SmithUpsertNestedInput {
  update: SmithUpdateDataInput;
  create: SmithCreateInput;
}

export type BoundaryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SummonerUpdateOneInput {
  create?: SummonerCreateInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SummonerWhereUniqueInput;
}

export interface SalvationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SalvationWhereInput;
  AND?: SalvationSubscriptionWhereInput[] | SalvationSubscriptionWhereInput;
  OR?: SalvationSubscriptionWhereInput[] | SalvationSubscriptionWhereInput;
  NOT?: SalvationSubscriptionWhereInput[] | SalvationSubscriptionWhereInput;
}

export interface VictimUpdateOneInput {
  create?: VictimCreateInput;
  update?: VictimUpdateDataInput;
  upsert?: VictimUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VictimWhereUniqueInput;
}

export interface SmithUpdateInput {
  shield?: ShieldUpdateManyInput;
}

export interface VictimUpdateDataInput {
  affliction?: AfflictionUpdateManyInput;
}

export interface HopeUpsertWithWhereUniqueNestedInput {
  where: HopeWhereUniqueInput;
  update: HopeUpdateDataInput;
  create: HopeCreateInput;
}

export interface AfflictionUpdateManyInput {
  create?: AfflictionCreateInput[] | AfflictionCreateInput;
  update?:
    | AfflictionUpdateWithWhereUniqueNestedInput[]
    | AfflictionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | AfflictionUpsertWithWhereUniqueNestedInput[]
    | AfflictionUpsertWithWhereUniqueNestedInput;
  delete?: AfflictionWhereUniqueInput[] | AfflictionWhereUniqueInput;
  connect?: AfflictionWhereUniqueInput[] | AfflictionWhereUniqueInput;
  set?: AfflictionWhereUniqueInput[] | AfflictionWhereUniqueInput;
  disconnect?: AfflictionWhereUniqueInput[] | AfflictionWhereUniqueInput;
  deleteMany?: AfflictionScalarWhereInput[] | AfflictionScalarWhereInput;
}

export interface CharactersUpdateOneInput {
  create?: CharactersCreateInput;
  update?: CharactersUpdateDataInput;
  upsert?: CharactersUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CharactersWhereUniqueInput;
}

export interface AfflictionUpdateWithWhereUniqueNestedInput {
  where: AfflictionWhereUniqueInput;
  data: AfflictionUpdateDataInput;
}

export type MartyrWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AfflictionUpdateDataInput {
  scar?: ScarUpdateManyInput;
  gash?: GashUpdateManyInput;
  infection?: InfectionUpdateManyInput;
  tremor?: TremorUpdateManyInput;
  nightmare?: NightmareUpdateManyInput;
  delirium?: DeliriumUpdateManyInput;
}

export type SacrificeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AfflictionUpsertWithWhereUniqueNestedInput {
  where: AfflictionWhereUniqueInput;
  update: AfflictionUpdateDataInput;
  create: AfflictionCreateInput;
}

export interface GratitudeUpdateManyDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface AfflictionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  AND?: AfflictionScalarWhereInput[] | AfflictionScalarWhereInput;
  OR?: AfflictionScalarWhereInput[] | AfflictionScalarWhereInput;
  NOT?: AfflictionScalarWhereInput[] | AfflictionScalarWhereInput;
}

export interface DeliriumSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DeliriumWhereInput;
  AND?: DeliriumSubscriptionWhereInput[] | DeliriumSubscriptionWhereInput;
  OR?: DeliriumSubscriptionWhereInput[] | DeliriumSubscriptionWhereInput;
  NOT?: DeliriumSubscriptionWhereInput[] | DeliriumSubscriptionWhereInput;
}

export interface VictimUpsertNestedInput {
  update: VictimUpdateDataInput;
  create: VictimCreateInput;
}

export type DenialWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface VolunteerUpdateOneInput {
  create?: VolunteerCreateInput;
  update?: VolunteerUpdateDataInput;
  upsert?: VolunteerUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: VolunteerWhereUniqueInput;
}

export interface JoyUpdateWithWhereUniqueNestedInput {
  where: JoyWhereUniqueInput;
  data: JoyUpdateDataInput;
}

export interface VolunteerUpdateDataInput {
  act?: ActUpdateManyInput;
}

export interface FearWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: String;
  character_not?: String;
  character_in?: String[] | String;
  character_not_in?: String[] | String;
  character_lt?: String;
  character_lte?: String;
  character_gt?: String;
  character_gte?: String;
  character_contains?: String;
  character_not_contains?: String;
  character_starts_with?: String;
  character_not_starts_with?: String;
  character_ends_with?: String;
  character_not_ends_with?: String;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  source?: String;
  source_not?: String;
  source_in?: String[] | String;
  source_not_in?: String[] | String;
  source_lt?: String;
  source_lte?: String;
  source_gt?: String;
  source_gte?: String;
  source_contains?: String;
  source_not_contains?: String;
  source_starts_with?: String;
  source_not_starts_with?: String;
  source_ends_with?: String;
  source_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  feeling?: String;
  feeling_not?: String;
  feeling_in?: String[] | String;
  feeling_not_in?: String[] | String;
  feeling_lt?: String;
  feeling_lte?: String;
  feeling_gt?: String;
  feeling_gte?: String;
  feeling_contains?: String;
  feeling_not_contains?: String;
  feeling_starts_with?: String;
  feeling_not_starts_with?: String;
  feeling_ends_with?: String;
  feeling_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: FearWhereInput[] | FearWhereInput;
  OR?: FearWhereInput[] | FearWhereInput;
  NOT?: FearWhereInput[] | FearWhereInput;
}

export interface ActUpsertWithWhereUniqueNestedInput {
  where: ActWhereUniqueInput;
  update: ActUpdateDataInput;
  create: ActCreateInput;
}

export interface ActUpdateDataInput {
  service?: ServiceUpdateManyInput;
  support?: SupportUpdateManyInput;
  sacrifice?: SacrificeUpdateManyInput;
}

export interface ActUpdateWithWhereUniqueNestedInput {
  where: ActWhereUniqueInput;
  data: ActUpdateDataInput;
}

export interface ActUpdateManyInput {
  create?: ActCreateInput[] | ActCreateInput;
  update?:
    | ActUpdateWithWhereUniqueNestedInput[]
    | ActUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ActUpsertWithWhereUniqueNestedInput[]
    | ActUpsertWithWhereUniqueNestedInput;
  delete?: ActWhereUniqueInput[] | ActWhereUniqueInput;
  connect?: ActWhereUniqueInput[] | ActWhereUniqueInput;
  set?: ActWhereUniqueInput[] | ActWhereUniqueInput;
  disconnect?: ActWhereUniqueInput[] | ActWhereUniqueInput;
  deleteMany?: ActScalarWhereInput[] | ActScalarWhereInput;
}

export interface IrritabilityUpdateDataInput {
  character?: String;
  thought?: String;
  source?: String;
  process?: String;
  path?: String;
  feeling?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolveAt?: DateTimeInput;
}

export type PaladinWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DiscontentUpdateWithWhereUniqueNestedInput {
  where: DiscontentWhereUniqueInput;
  data: DiscontentUpdateDataInput;
}

export interface VirtueUpdateInput {
  nail?: NailUpdateManyInput;
  crown?: CrownUpdateManyInput;
  cross?: CrossUpdateManyInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface DenialPreviousValues {
  id: ID_Output;
}

export interface DenialPreviousValuesPromise
  extends Promise<DenialPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface DenialPreviousValuesSubscription
  extends Promise<AsyncIterator<DenialPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Silence {
  id: ID_Output;
}

export interface SilencePromise extends Promise<Silence>, Fragmentable {
  id: () => Promise<ID_Output>;
  armor: <T = FragmentableArray<Armor>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SilenceSubscription
  extends Promise<AsyncIterator<Silence>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  armor: <T = Promise<AsyncIterator<ArmorSubscription>>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WishPreviousValues {
  id: ID_Output;
}

export interface WishPreviousValuesPromise
  extends Promise<WishPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface WishPreviousValuesSubscription
  extends Promise<AsyncIterator<WishPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Shield {
  id: ID_Output;
}

export interface ShieldPromise extends Promise<Shield>, Fragmentable {
  id: () => Promise<ID_Output>;
  silence: <T = FragmentableArray<Silence>>(
    args?: {
      where?: SilenceWhereInput;
      orderBy?: SilenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sarcasm: <T = FragmentableArray<Sarcasm>>(
    args?: {
      where?: SarcasmWhereInput;
      orderBy?: SarcasmOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  denial: <T = FragmentableArray<Denial>>(
    args?: {
      where?: DenialWhereInput;
      orderBy?: DenialOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  confusion: <T = FragmentableArray<Confusion>>(
    args?: {
      where?: ConfusionWhereInput;
      orderBy?: ConfusionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ShieldSubscription
  extends Promise<AsyncIterator<Shield>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  silence: <T = Promise<AsyncIterator<SilenceSubscription>>>(
    args?: {
      where?: SilenceWhereInput;
      orderBy?: SilenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sarcasm: <T = Promise<AsyncIterator<SarcasmSubscription>>>(
    args?: {
      where?: SarcasmWhereInput;
      orderBy?: SarcasmOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  denial: <T = Promise<AsyncIterator<DenialSubscription>>>(
    args?: {
      where?: DenialWhereInput;
      orderBy?: DenialOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  confusion: <T = Promise<AsyncIterator<ConfusionSubscription>>>(
    args?: {
      where?: ConfusionWhereInput;
      orderBy?: ConfusionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateWish {
  count: Int;
}

export interface AggregateWishPromise
  extends Promise<AggregateWish>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWishSubscription
  extends Promise<AsyncIterator<AggregateWish>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Smith {
  id: ID_Output;
}

export interface SmithPromise extends Promise<Smith>, Fragmentable {
  id: () => Promise<ID_Output>;
  shield: <T = FragmentableArray<Shield>>(
    args?: {
      where?: ShieldWhereInput;
      orderBy?: ShieldOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SmithSubscription
  extends Promise<AsyncIterator<Smith>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  shield: <T = Promise<AsyncIterator<ShieldSubscription>>>(
    args?: {
      where?: ShieldWhereInput;
      orderBy?: ShieldOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WishConnection {
  pageInfo: PageInfo;
  edges: WishEdge[];
}

export interface WishConnectionPromise
  extends Promise<WishConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WishEdge>>() => T;
  aggregate: <T = AggregateWishPromise>() => T;
}

export interface WishConnectionSubscription
  extends Promise<AsyncIterator<WishConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WishEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWishSubscription>() => T;
}

export interface Self {
  id: ID_Output;
}

export interface SelfPromise extends Promise<Self>, Fragmentable {
  id: () => Promise<ID_Output>;
  body: <T = FragmentableArray<Body>>(
    args?: {
      where?: BodyWhereInput;
      orderBy?: BodyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SelfSubscription
  extends Promise<AsyncIterator<Self>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  body: <T = Promise<AsyncIterator<BodySubscription>>>(
    args?: {
      where?: BodyWhereInput;
      orderBy?: BodyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WallEdge {
  node: Wall;
  cursor: String;
}

export interface WallEdgePromise extends Promise<WallEdge>, Fragmentable {
  node: <T = WallPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WallEdgeSubscription
  extends Promise<AsyncIterator<WallEdge>>,
    Fragmentable {
  node: <T = WallSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Virtue {
  id: ID_Output;
}

export interface VirtuePromise extends Promise<Virtue>, Fragmentable {
  id: () => Promise<ID_Output>;
  nail: <T = FragmentableArray<Nail>>(
    args?: {
      where?: NailWhereInput;
      orderBy?: NailOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  crown: <T = FragmentableArray<Crown>>(
    args?: {
      where?: CrownWhereInput;
      orderBy?: CrownOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cross: <T = FragmentableArray<Cross>>(
    args?: {
      where?: CrossWhereInput;
      orderBy?: CrossOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VirtueSubscription
  extends Promise<AsyncIterator<Virtue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nail: <T = Promise<AsyncIterator<NailSubscription>>>(
    args?: {
      where?: NailWhereInput;
      orderBy?: NailOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  crown: <T = Promise<AsyncIterator<CrownSubscription>>>(
    args?: {
      where?: CrownWhereInput;
      orderBy?: CrownOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cross: <T = Promise<AsyncIterator<CrossSubscription>>>(
    args?: {
      where?: CrossWhereInput;
      orderBy?: CrossOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateVulnerability {
  count: Int;
}

export interface AggregateVulnerabilityPromise
  extends Promise<AggregateVulnerability>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVulnerabilitySubscription
  extends Promise<AsyncIterator<AggregateVulnerability>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AcceptanceSubscriptionPayload {
  mutation: MutationType;
  node: Acceptance;
  updatedFields: String[];
  previousValues: AcceptancePreviousValues;
}

export interface AcceptanceSubscriptionPayloadPromise
  extends Promise<AcceptanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AcceptancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AcceptancePreviousValuesPromise>() => T;
}

export interface AcceptanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AcceptanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AcceptanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AcceptancePreviousValuesSubscription>() => T;
}

export interface VulnerabilityConnection {
  pageInfo: PageInfo;
  edges: VulnerabilityEdge[];
}

export interface VulnerabilityConnectionPromise
  extends Promise<VulnerabilityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VulnerabilityEdge>>() => T;
  aggregate: <T = AggregateVulnerabilityPromise>() => T;
}

export interface VulnerabilityConnectionSubscription
  extends Promise<AsyncIterator<VulnerabilityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VulnerabilityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVulnerabilitySubscription>() => T;
}

export interface AcceptancePreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface AcceptancePreviousValuesPromise
  extends Promise<AcceptancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface AcceptancePreviousValuesSubscription
  extends Promise<AsyncIterator<AcceptancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VolunteerEdge {
  node: Volunteer;
  cursor: String;
}

export interface VolunteerEdgePromise
  extends Promise<VolunteerEdge>,
    Fragmentable {
  node: <T = VolunteerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VolunteerEdgeSubscription
  extends Promise<AsyncIterator<VolunteerEdge>>,
    Fragmentable {
  node: <T = VolunteerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Seeker {
  id: ID_Output;
}

export interface SeekerPromise extends Promise<Seeker>, Fragmentable {
  id: () => Promise<ID_Output>;
  virtue: <T = FragmentableArray<Virtue>>(
    args?: {
      where?: VirtueWhereInput;
      orderBy?: VirtueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SeekerSubscription
  extends Promise<AsyncIterator<Seeker>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  virtue: <T = Promise<AsyncIterator<VirtueSubscription>>>(
    args?: {
      where?: VirtueWhereInput;
      orderBy?: VirtueOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateVirtue {
  count: Int;
}

export interface AggregateVirtuePromise
  extends Promise<AggregateVirtue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVirtueSubscription
  extends Promise<AsyncIterator<AggregateVirtue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActSubscriptionPayload {
  mutation: MutationType;
  node: Act;
  updatedFields: String[];
  previousValues: ActPreviousValues;
}

export interface ActSubscriptionPayloadPromise
  extends Promise<ActSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ActPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ActPreviousValuesPromise>() => T;
}

export interface ActSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ActSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ActSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ActPreviousValuesSubscription>() => T;
}

export interface VirtueConnection {
  pageInfo: PageInfo;
  edges: VirtueEdge[];
}

export interface VirtueConnectionPromise
  extends Promise<VirtueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VirtueEdge>>() => T;
  aggregate: <T = AggregateVirtuePromise>() => T;
}

export interface VirtueConnectionSubscription
  extends Promise<AsyncIterator<VirtueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VirtueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVirtueSubscription>() => T;
}

export interface ActPreviousValues {
  id: ID_Output;
}

export interface ActPreviousValuesPromise
  extends Promise<ActPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ActPreviousValuesSubscription
  extends Promise<AsyncIterator<ActPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface VictimEdge {
  node: Victim;
  cursor: String;
}

export interface VictimEdgePromise extends Promise<VictimEdge>, Fragmentable {
  node: <T = VictimPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VictimEdgeSubscription
  extends Promise<AsyncIterator<VictimEdge>>,
    Fragmentable {
  node: <T = VictimSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Crusade {
  id: ID_Output;
}

export interface CrusadePromise extends Promise<Crusade>, Fragmentable {
  id: () => Promise<ID_Output>;
  loyalty: <T = FragmentableArray<Loyalty>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = FragmentableArray<Honor>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CrusadeSubscription
  extends Promise<AsyncIterator<Crusade>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  loyalty: <T = Promise<AsyncIterator<LoyaltySubscription>>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = Promise<AsyncIterator<HonorSubscription>>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateTremor {
  count: Int;
}

export interface AggregateTremorPromise
  extends Promise<AggregateTremor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTremorSubscription
  extends Promise<AsyncIterator<AggregateTremor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AfflictionSubscriptionPayload {
  mutation: MutationType;
  node: Affliction;
  updatedFields: String[];
  previousValues: AfflictionPreviousValues;
}

export interface AfflictionSubscriptionPayloadPromise
  extends Promise<AfflictionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AfflictionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AfflictionPreviousValuesPromise>() => T;
}

export interface AfflictionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AfflictionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AfflictionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AfflictionPreviousValuesSubscription>() => T;
}

export interface TremorConnection {
  pageInfo: PageInfo;
  edges: TremorEdge[];
}

export interface TremorConnectionPromise
  extends Promise<TremorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TremorEdge>>() => T;
  aggregate: <T = AggregateTremorPromise>() => T;
}

export interface TremorConnectionSubscription
  extends Promise<AsyncIterator<TremorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TremorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTremorSubscription>() => T;
}

export interface AfflictionPreviousValues {
  id: ID_Output;
}

export interface AfflictionPreviousValuesPromise
  extends Promise<AfflictionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface AfflictionPreviousValuesSubscription
  extends Promise<AsyncIterator<AfflictionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface TraumaEdge {
  node: Trauma;
  cursor: String;
}

export interface TraumaEdgePromise extends Promise<TraumaEdge>, Fragmentable {
  node: <T = TraumaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TraumaEdgeSubscription
  extends Promise<AsyncIterator<TraumaEdge>>,
    Fragmentable {
  node: <T = TraumaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Pledge {
  id: ID_Output;
}

export interface PledgePromise extends Promise<Pledge>, Fragmentable {
  id: () => Promise<ID_Output>;
  loyalty: <T = FragmentableArray<Loyalty>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = FragmentableArray<Honor>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PledgeSubscription
  extends Promise<AsyncIterator<Pledge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  loyalty: <T = Promise<AsyncIterator<LoyaltySubscription>>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = Promise<AsyncIterator<HonorSubscription>>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateToxicity {
  count: Int;
}

export interface AggregateToxicityPromise
  extends Promise<AggregateToxicity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateToxicitySubscription
  extends Promise<AsyncIterator<AggregateToxicity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AngerSubscriptionPayload {
  mutation: MutationType;
  node: Anger;
  updatedFields: String[];
  previousValues: AngerPreviousValues;
}

export interface AngerSubscriptionPayloadPromise
  extends Promise<AngerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AngerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AngerPreviousValuesPromise>() => T;
}

export interface AngerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AngerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AngerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AngerPreviousValuesSubscription>() => T;
}

export interface ToxicityConnection {
  pageInfo: PageInfo;
  edges: ToxicityEdge[];
}

export interface ToxicityConnectionPromise
  extends Promise<ToxicityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ToxicityEdge>>() => T;
  aggregate: <T = AggregateToxicityPromise>() => T;
}

export interface ToxicityConnectionSubscription
  extends Promise<AsyncIterator<ToxicityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ToxicityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateToxicitySubscription>() => T;
}

export interface AngerPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface AngerPreviousValuesPromise
  extends Promise<AngerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface AngerPreviousValuesSubscription
  extends Promise<AsyncIterator<AngerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TowerEdge {
  node: Tower;
  cursor: String;
}

export interface TowerEdgePromise extends Promise<TowerEdge>, Fragmentable {
  node: <T = TowerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TowerEdgeSubscription
  extends Promise<AsyncIterator<TowerEdge>>,
    Fragmentable {
  node: <T = TowerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Oath {
  id: ID_Output;
}

export interface OathPromise extends Promise<Oath>, Fragmentable {
  id: () => Promise<ID_Output>;
  pledge: <T = FragmentableArray<Pledge>>(
    args?: {
      where?: PledgeWhereInput;
      orderBy?: PledgeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  campaign: <T = FragmentableArray<Campaign>>(
    args?: {
      where?: CampaignWhereInput;
      orderBy?: CampaignOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  crusade: <T = FragmentableArray<Crusade>>(
    args?: {
      where?: CrusadeWhereInput;
      orderBy?: CrusadeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface OathSubscription
  extends Promise<AsyncIterator<Oath>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  pledge: <T = Promise<AsyncIterator<PledgeSubscription>>>(
    args?: {
      where?: PledgeWhereInput;
      orderBy?: PledgeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  campaign: <T = Promise<AsyncIterator<CampaignSubscription>>>(
    args?: {
      where?: CampaignWhereInput;
      orderBy?: CampaignOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  crusade: <T = Promise<AsyncIterator<CrusadeSubscription>>>(
    args?: {
      where?: CrusadeWhereInput;
      orderBy?: CrusadeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateSupport {
  count: Int;
}

export interface AggregateSupportPromise
  extends Promise<AggregateSupport>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSupportSubscription
  extends Promise<AsyncIterator<AggregateSupport>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArmorSubscriptionPayload {
  mutation: MutationType;
  node: Armor;
  updatedFields: String[];
  previousValues: ArmorPreviousValues;
}

export interface ArmorSubscriptionPayloadPromise
  extends Promise<ArmorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArmorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArmorPreviousValuesPromise>() => T;
}

export interface ArmorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArmorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArmorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArmorPreviousValuesSubscription>() => T;
}

export interface SupportConnection {
  pageInfo: PageInfo;
  edges: SupportEdge[];
}

export interface SupportConnectionPromise
  extends Promise<SupportConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SupportEdge>>() => T;
  aggregate: <T = AggregateSupportPromise>() => T;
}

export interface SupportConnectionSubscription
  extends Promise<AsyncIterator<SupportConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SupportEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSupportSubscription>() => T;
}

export interface ArmorPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ArmorPreviousValuesPromise
  extends Promise<ArmorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ArmorPreviousValuesSubscription
  extends Promise<AsyncIterator<ArmorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SummonerEdge {
  node: Summoner;
  cursor: String;
}

export interface SummonerEdgePromise
  extends Promise<SummonerEdge>,
    Fragmentable {
  node: <T = SummonerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SummonerEdgeSubscription
  extends Promise<AsyncIterator<SummonerEdge>>,
    Fragmentable {
  node: <T = SummonerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Paladin {
  id: ID_Output;
}

export interface PaladinPromise extends Promise<Paladin>, Fragmentable {
  id: () => Promise<ID_Output>;
  oath: <T = FragmentableArray<Oath>>(
    args?: {
      where?: OathWhereInput;
      orderBy?: OathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PaladinSubscription
  extends Promise<AsyncIterator<Paladin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  oath: <T = Promise<AsyncIterator<OathSubscription>>>(
    args?: {
      where?: OathWhereInput;
      orderBy?: OathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateSuffering {
  count: Int;
}

export interface AggregateSufferingPromise
  extends Promise<AggregateSuffering>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSufferingSubscription
  extends Promise<AsyncIterator<AggregateSuffering>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BodySubscriptionPayload {
  mutation: MutationType;
  node: Body;
  updatedFields: String[];
  previousValues: BodyPreviousValues;
}

export interface BodySubscriptionPayloadPromise
  extends Promise<BodySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BodyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BodyPreviousValuesPromise>() => T;
}

export interface BodySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BodySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BodySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BodyPreviousValuesSubscription>() => T;
}

export interface SufferingConnection {
  pageInfo: PageInfo;
  edges: SufferingEdge[];
}

export interface SufferingConnectionPromise
  extends Promise<SufferingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SufferingEdge>>() => T;
  aggregate: <T = AggregateSufferingPromise>() => T;
}

export interface SufferingConnectionSubscription
  extends Promise<AsyncIterator<SufferingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SufferingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSufferingSubscription>() => T;
}

export interface BodyPreviousValues {
  id: ID_Output;
}

export interface BodyPreviousValuesPromise
  extends Promise<BodyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface BodyPreviousValuesSubscription
  extends Promise<AsyncIterator<BodyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface StrengthEdge {
  node: Strength;
  cursor: String;
}

export interface StrengthEdgePromise
  extends Promise<StrengthEdge>,
    Fragmentable {
  node: <T = StrengthPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StrengthEdgeSubscription
  extends Promise<AsyncIterator<StrengthEdge>>,
    Fragmentable {
  node: <T = StrengthSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Cross {
  id: ID_Output;
}

export interface CrossPromise extends Promise<Cross>, Fragmentable {
  id: () => Promise<ID_Output>;
  suffering: <T = FragmentableArray<Suffering>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CrossSubscription
  extends Promise<AsyncIterator<Cross>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  suffering: <T = Promise<AsyncIterator<SufferingSubscription>>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateStigmata {
  count: Int;
}

export interface AggregateStigmataPromise
  extends Promise<AggregateStigmata>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStigmataSubscription
  extends Promise<AsyncIterator<AggregateStigmata>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BoundarySubscriptionPayload {
  mutation: MutationType;
  node: Boundary;
  updatedFields: String[];
  previousValues: BoundaryPreviousValues;
}

export interface BoundarySubscriptionPayloadPromise
  extends Promise<BoundarySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BoundaryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BoundaryPreviousValuesPromise>() => T;
}

export interface BoundarySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BoundarySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BoundarySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BoundaryPreviousValuesSubscription>() => T;
}

export interface StigmataConnection {
  pageInfo: PageInfo;
  edges: StigmataEdge[];
}

export interface StigmataConnectionPromise
  extends Promise<StigmataConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StigmataEdge>>() => T;
  aggregate: <T = AggregateStigmataPromise>() => T;
}

export interface StigmataConnectionSubscription
  extends Promise<AsyncIterator<StigmataConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StigmataEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStigmataSubscription>() => T;
}

export interface BoundaryPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface BoundaryPreviousValuesPromise
  extends Promise<BoundaryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface BoundaryPreviousValuesSubscription
  extends Promise<AsyncIterator<BoundaryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SternumEdge {
  node: Sternum;
  cursor: String;
}

export interface SternumEdgePromise extends Promise<SternumEdge>, Fragmentable {
  node: <T = SternumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SternumEdgeSubscription
  extends Promise<AsyncIterator<SternumEdge>>,
    Fragmentable {
  node: <T = SternumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Crown {
  id: ID_Output;
}

export interface CrownPromise extends Promise<Crown>, Fragmentable {
  id: () => Promise<ID_Output>;
  suffering: <T = FragmentableArray<Suffering>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CrownSubscription
  extends Promise<AsyncIterator<Crown>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  suffering: <T = Promise<AsyncIterator<SufferingSubscription>>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateSoul {
  count: Int;
}

export interface AggregateSoulPromise
  extends Promise<AggregateSoul>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSoulSubscription
  extends Promise<AsyncIterator<AggregateSoul>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BrainSubscriptionPayload {
  mutation: MutationType;
  node: Brain;
  updatedFields: String[];
  previousValues: BrainPreviousValues;
}

export interface BrainSubscriptionPayloadPromise
  extends Promise<BrainSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BrainPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BrainPreviousValuesPromise>() => T;
}

export interface BrainSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BrainSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BrainSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BrainPreviousValuesSubscription>() => T;
}

export interface SoulConnection {
  pageInfo: PageInfo;
  edges: SoulEdge[];
}

export interface SoulConnectionPromise
  extends Promise<SoulConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SoulEdge>>() => T;
  aggregate: <T = AggregateSoulPromise>() => T;
}

export interface SoulConnectionSubscription
  extends Promise<AsyncIterator<SoulConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SoulEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSoulSubscription>() => T;
}

export interface BrainPreviousValues {
  id: ID_Output;
}

export interface BrainPreviousValuesPromise
  extends Promise<BrainPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface BrainPreviousValuesSubscription
  extends Promise<AsyncIterator<BrainPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SmithEdge {
  node: Smith;
  cursor: String;
}

export interface SmithEdgePromise extends Promise<SmithEdge>, Fragmentable {
  node: <T = SmithPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SmithEdgeSubscription
  extends Promise<AsyncIterator<SmithEdge>>,
    Fragmentable {
  node: <T = SmithSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Suffering {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SufferingPromise extends Promise<Suffering>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SufferingSubscription
  extends Promise<AsyncIterator<Suffering>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSkin {
  count: Int;
}

export interface AggregateSkinPromise
  extends Promise<AggregateSkin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSkinSubscription
  extends Promise<AsyncIterator<AggregateSkin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CampaignSubscriptionPayload {
  mutation: MutationType;
  node: Campaign;
  updatedFields: String[];
  previousValues: CampaignPreviousValues;
}

export interface CampaignSubscriptionPayloadPromise
  extends Promise<CampaignSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CampaignPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CampaignPreviousValuesPromise>() => T;
}

export interface CampaignSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CampaignSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CampaignSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CampaignPreviousValuesSubscription>() => T;
}

export interface SkinConnection {
  pageInfo: PageInfo;
  edges: SkinEdge[];
}

export interface SkinConnectionPromise
  extends Promise<SkinConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SkinEdge>>() => T;
  aggregate: <T = AggregateSkinPromise>() => T;
}

export interface SkinConnectionSubscription
  extends Promise<AsyncIterator<SkinConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SkinEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSkinSubscription>() => T;
}

export interface CampaignPreviousValues {
  id: ID_Output;
}

export interface CampaignPreviousValuesPromise
  extends Promise<CampaignPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CampaignPreviousValuesSubscription
  extends Promise<AsyncIterator<CampaignPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateSilence {
  count: Int;
}

export interface AggregateSilencePromise
  extends Promise<AggregateSilence>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSilenceSubscription
  extends Promise<AsyncIterator<AggregateSilence>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Nail {
  id: ID_Output;
}

export interface NailPromise extends Promise<Nail>, Fragmentable {
  id: () => Promise<ID_Output>;
  suffering: <T = FragmentableArray<Suffering>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface NailSubscription
  extends Promise<AsyncIterator<Nail>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  suffering: <T = Promise<AsyncIterator<SufferingSubscription>>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SilenceConnection {
  pageInfo: PageInfo;
  edges: SilenceEdge[];
}

export interface SilenceConnectionPromise
  extends Promise<SilenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SilenceEdge>>() => T;
  aggregate: <T = AggregateSilencePromise>() => T;
}

export interface SilenceConnectionSubscription
  extends Promise<AsyncIterator<SilenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SilenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSilenceSubscription>() => T;
}

export interface CharactersSubscriptionPayload {
  mutation: MutationType;
  node: Characters;
  updatedFields: String[];
  previousValues: CharactersPreviousValues;
}

export interface CharactersSubscriptionPayloadPromise
  extends Promise<CharactersSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharactersPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharactersPreviousValuesPromise>() => T;
}

export interface CharactersSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharactersSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharactersSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharactersPreviousValuesSubscription>() => T;
}

export interface ShieldEdge {
  node: Shield;
  cursor: String;
}

export interface ShieldEdgePromise extends Promise<ShieldEdge>, Fragmentable {
  node: <T = ShieldPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ShieldEdgeSubscription
  extends Promise<AsyncIterator<ShieldEdge>>,
    Fragmentable {
  node: <T = ShieldSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharactersPreviousValues {
  id: ID_Output;
}

export interface CharactersPreviousValuesPromise
  extends Promise<CharactersPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CharactersPreviousValuesSubscription
  extends Promise<AsyncIterator<CharactersPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateService {
  count: Int;
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Stigmata {
  id: ID_Output;
}

export interface StigmataPromise extends Promise<Stigmata>, Fragmentable {
  id: () => Promise<ID_Output>;
  nail: <T = FragmentableArray<Nail>>(
    args?: {
      where?: NailWhereInput;
      orderBy?: NailOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  crown: <T = FragmentableArray<Crown>>(
    args?: {
      where?: CrownWhereInput;
      orderBy?: CrownOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cross: <T = FragmentableArray<Cross>>(
    args?: {
      where?: CrossWhereInput;
      orderBy?: CrossOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StigmataSubscription
  extends Promise<AsyncIterator<Stigmata>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  nail: <T = Promise<AsyncIterator<NailSubscription>>>(
    args?: {
      where?: NailWhereInput;
      orderBy?: NailOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  crown: <T = Promise<AsyncIterator<CrownSubscription>>>(
    args?: {
      where?: CrownWhereInput;
      orderBy?: CrownOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cross: <T = Promise<AsyncIterator<CrossSubscription>>>(
    args?: {
      where?: CrossWhereInput;
      orderBy?: CrossOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ServiceConnection {
  pageInfo: PageInfo;
  edges: ServiceEdge[];
}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceEdge>>() => T;
  aggregate: <T = AggregateServicePromise>() => T;
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceSubscription>() => T;
}

export interface CompassionSubscriptionPayload {
  mutation: MutationType;
  node: Compassion;
  updatedFields: String[];
  previousValues: CompassionPreviousValues;
}

export interface CompassionSubscriptionPayloadPromise
  extends Promise<CompassionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompassionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompassionPreviousValuesPromise>() => T;
}

export interface CompassionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompassionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompassionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompassionPreviousValuesSubscription>() => T;
}

export interface SelfPityEdge {
  node: SelfPity;
  cursor: String;
}

export interface SelfPityEdgePromise
  extends Promise<SelfPityEdge>,
    Fragmentable {
  node: <T = SelfPityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SelfPityEdgeSubscription
  extends Promise<AsyncIterator<SelfPityEdge>>,
    Fragmentable {
  node: <T = SelfPitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompassionPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface CompassionPreviousValuesPromise
  extends Promise<CompassionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface CompassionPreviousValuesSubscription
  extends Promise<AsyncIterator<CompassionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSelf {
  count: Int;
}

export interface AggregateSelfPromise
  extends Promise<AggregateSelf>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSelfSubscription
  extends Promise<AsyncIterator<AggregateSelf>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Martyr {
  id: ID_Output;
}

export interface MartyrPromise extends Promise<Martyr>, Fragmentable {
  id: () => Promise<ID_Output>;
  stigmata: <T = FragmentableArray<Stigmata>>(
    args?: {
      where?: StigmataWhereInput;
      orderBy?: StigmataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface MartyrSubscription
  extends Promise<AsyncIterator<Martyr>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  stigmata: <T = Promise<AsyncIterator<StigmataSubscription>>>(
    args?: {
      where?: StigmataWhereInput;
      orderBy?: StigmataOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SelfConnection {
  pageInfo: PageInfo;
  edges: SelfEdge[];
}

export interface SelfConnectionPromise
  extends Promise<SelfConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SelfEdge>>() => T;
  aggregate: <T = AggregateSelfPromise>() => T;
}

export interface SelfConnectionSubscription
  extends Promise<AsyncIterator<SelfConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SelfEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSelfSubscription>() => T;
}

export interface ConfusionSubscriptionPayload {
  mutation: MutationType;
  node: Confusion;
  updatedFields: String[];
  previousValues: ConfusionPreviousValues;
}

export interface ConfusionSubscriptionPayloadPromise
  extends Promise<ConfusionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConfusionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConfusionPreviousValuesPromise>() => T;
}

export interface ConfusionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConfusionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConfusionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConfusionPreviousValuesSubscription>() => T;
}

export interface SeekerEdge {
  node: Seeker;
  cursor: String;
}

export interface SeekerEdgePromise extends Promise<SeekerEdge>, Fragmentable {
  node: <T = SeekerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SeekerEdgeSubscription
  extends Promise<AsyncIterator<SeekerEdge>>,
    Fragmentable {
  node: <T = SeekerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ConfusionPreviousValues {
  id: ID_Output;
}

export interface ConfusionPreviousValuesPromise
  extends Promise<ConfusionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ConfusionPreviousValuesSubscription
  extends Promise<AsyncIterator<ConfusionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateScar {
  count: Int;
}

export interface AggregateScarPromise
  extends Promise<AggregateScar>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScarSubscription
  extends Promise<AsyncIterator<AggregateScar>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Wall {
  id: ID_Output;
}

export interface WallPromise extends Promise<Wall>, Fragmentable {
  id: () => Promise<ID_Output>;
  boundary: <T = FragmentableArray<Boundary>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WallSubscription
  extends Promise<AsyncIterator<Wall>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  boundary: <T = Promise<AsyncIterator<BoundarySubscription>>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ScarConnection {
  pageInfo: PageInfo;
  edges: ScarEdge[];
}

export interface ScarConnectionPromise
  extends Promise<ScarConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ScarEdge>>() => T;
  aggregate: <T = AggregateScarPromise>() => T;
}

export interface ScarConnectionSubscription
  extends Promise<AsyncIterator<ScarConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScarEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScarSubscription>() => T;
}

export interface CongregantSubscriptionPayload {
  mutation: MutationType;
  node: Congregant;
  updatedFields: String[];
  previousValues: CongregantPreviousValues;
}

export interface CongregantSubscriptionPayloadPromise
  extends Promise<CongregantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CongregantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CongregantPreviousValuesPromise>() => T;
}

export interface CongregantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CongregantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CongregantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CongregantPreviousValuesSubscription>() => T;
}

export interface SarcasmEdge {
  node: Sarcasm;
  cursor: String;
}

export interface SarcasmEdgePromise extends Promise<SarcasmEdge>, Fragmentable {
  node: <T = SarcasmPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SarcasmEdgeSubscription
  extends Promise<AsyncIterator<SarcasmEdge>>,
    Fragmentable {
  node: <T = SarcasmSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CongregantPreviousValues {
  id: ID_Output;
}

export interface CongregantPreviousValuesPromise
  extends Promise<CongregantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CongregantPreviousValuesSubscription
  extends Promise<AsyncIterator<CongregantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateSalvation {
  count: Int;
}

export interface AggregateSalvationPromise
  extends Promise<AggregateSalvation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSalvationSubscription
  extends Promise<AsyncIterator<AggregateSalvation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Tower {
  id: ID_Output;
}

export interface TowerPromise extends Promise<Tower>, Fragmentable {
  id: () => Promise<ID_Output>;
  boundary: <T = FragmentableArray<Boundary>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TowerSubscription
  extends Promise<AsyncIterator<Tower>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  boundary: <T = Promise<AsyncIterator<BoundarySubscription>>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SalvationConnection {
  pageInfo: PageInfo;
  edges: SalvationEdge[];
}

export interface SalvationConnectionPromise
  extends Promise<SalvationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SalvationEdge>>() => T;
  aggregate: <T = AggregateSalvationPromise>() => T;
}

export interface SalvationConnectionSubscription
  extends Promise<AsyncIterator<SalvationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SalvationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSalvationSubscription>() => T;
}

export interface ConstructSubscriptionPayload {
  mutation: MutationType;
  node: Construct;
  updatedFields: String[];
  previousValues: ConstructPreviousValues;
}

export interface ConstructSubscriptionPayloadPromise
  extends Promise<ConstructSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConstructPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConstructPreviousValuesPromise>() => T;
}

export interface ConstructSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConstructSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConstructSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConstructPreviousValuesSubscription>() => T;
}

export interface SacrificeEdge {
  node: Sacrifice;
  cursor: String;
}

export interface SacrificeEdgePromise
  extends Promise<SacrificeEdge>,
    Fragmentable {
  node: <T = SacrificePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SacrificeEdgeSubscription
  extends Promise<AsyncIterator<SacrificeEdge>>,
    Fragmentable {
  node: <T = SacrificeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ConstructPreviousValues {
  id: ID_Output;
}

export interface ConstructPreviousValuesPromise
  extends Promise<ConstructPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ConstructPreviousValuesSubscription
  extends Promise<AsyncIterator<ConstructPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateResentment {
  count: Int;
}

export interface AggregateResentmentPromise
  extends Promise<AggregateResentment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResentmentSubscription
  extends Promise<AsyncIterator<AggregateResentment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Gate {
  id: ID_Output;
}

export interface GatePromise extends Promise<Gate>, Fragmentable {
  id: () => Promise<ID_Output>;
  boundary: <T = FragmentableArray<Boundary>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GateSubscription
  extends Promise<AsyncIterator<Gate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  boundary: <T = Promise<AsyncIterator<BoundarySubscription>>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ResentmentConnection {
  pageInfo: PageInfo;
  edges: ResentmentEdge[];
}

export interface ResentmentConnectionPromise
  extends Promise<ResentmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ResentmentEdge>>() => T;
  aggregate: <T = AggregateResentmentPromise>() => T;
}

export interface ResentmentConnectionSubscription
  extends Promise<AsyncIterator<ResentmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ResentmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateResentmentSubscription>() => T;
}

export interface CourageSubscriptionPayload {
  mutation: MutationType;
  node: Courage;
  updatedFields: String[];
  previousValues: CouragePreviousValues;
}

export interface CourageSubscriptionPayloadPromise
  extends Promise<CourageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CouragePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CouragePreviousValuesPromise>() => T;
}

export interface CourageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CouragePreviousValuesSubscription>() => T;
}

export interface ProcessEdge {
  node: Process;
  cursor: String;
}

export interface ProcessEdgePromise extends Promise<ProcessEdge>, Fragmentable {
  node: <T = ProcessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProcessEdgeSubscription
  extends Promise<AsyncIterator<ProcessEdge>>,
    Fragmentable {
  node: <T = ProcessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CouragePreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface CouragePreviousValuesPromise
  extends Promise<CouragePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface CouragePreviousValuesSubscription
  extends Promise<AsyncIterator<CouragePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePride {
  count: Int;
}

export interface AggregatePridePromise
  extends Promise<AggregatePride>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePrideSubscription
  extends Promise<AsyncIterator<AggregatePride>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Construct {
  id: ID_Output;
}

export interface ConstructPromise extends Promise<Construct>, Fragmentable {
  id: () => Promise<ID_Output>;
  gate: <T = FragmentableArray<Gate>>(
    args?: {
      where?: GateWhereInput;
      orderBy?: GateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tower: <T = FragmentableArray<Tower>>(
    args?: {
      where?: TowerWhereInput;
      orderBy?: TowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  wall: <T = FragmentableArray<Wall>>(
    args?: {
      where?: WallWhereInput;
      orderBy?: WallOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ConstructSubscription
  extends Promise<AsyncIterator<Construct>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  gate: <T = Promise<AsyncIterator<GateSubscription>>>(
    args?: {
      where?: GateWhereInput;
      orderBy?: GateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tower: <T = Promise<AsyncIterator<TowerSubscription>>>(
    args?: {
      where?: TowerWhereInput;
      orderBy?: TowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  wall: <T = Promise<AsyncIterator<WallSubscription>>>(
    args?: {
      where?: WallWhereInput;
      orderBy?: WallOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PrideConnection {
  pageInfo: PageInfo;
  edges: PrideEdge[];
}

export interface PrideConnectionPromise
  extends Promise<PrideConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PrideEdge>>() => T;
  aggregate: <T = AggregatePridePromise>() => T;
}

export interface PrideConnectionSubscription
  extends Promise<AsyncIterator<PrideConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PrideEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePrideSubscription>() => T;
}

export interface CrossSubscriptionPayload {
  mutation: MutationType;
  node: Cross;
  updatedFields: String[];
  previousValues: CrossPreviousValues;
}

export interface CrossSubscriptionPayloadPromise
  extends Promise<CrossSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CrossPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CrossPreviousValuesPromise>() => T;
}

export interface CrossSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CrossSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CrossSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CrossPreviousValuesSubscription>() => T;
}

export interface PrayerEdge {
  node: Prayer;
  cursor: String;
}

export interface PrayerEdgePromise extends Promise<PrayerEdge>, Fragmentable {
  node: <T = PrayerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PrayerEdgeSubscription
  extends Promise<AsyncIterator<PrayerEdge>>,
    Fragmentable {
  node: <T = PrayerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CrossPreviousValues {
  id: ID_Output;
}

export interface CrossPreviousValuesPromise
  extends Promise<CrossPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CrossPreviousValuesSubscription
  extends Promise<AsyncIterator<CrossPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregatePledge {
  count: Int;
}

export interface AggregatePledgePromise
  extends Promise<AggregatePledge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePledgeSubscription
  extends Promise<AsyncIterator<AggregatePledge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Guardian {
  id: ID_Output;
}

export interface GuardianPromise extends Promise<Guardian>, Fragmentable {
  id: () => Promise<ID_Output>;
  construct: <T = FragmentableArray<Construct>>(
    args?: {
      where?: ConstructWhereInput;
      orderBy?: ConstructOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GuardianSubscription
  extends Promise<AsyncIterator<Guardian>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  construct: <T = Promise<AsyncIterator<ConstructSubscription>>>(
    args?: {
      where?: ConstructWhereInput;
      orderBy?: ConstructOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PledgeConnection {
  pageInfo: PageInfo;
  edges: PledgeEdge[];
}

export interface PledgeConnectionPromise
  extends Promise<PledgeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PledgeEdge>>() => T;
  aggregate: <T = AggregatePledgePromise>() => T;
}

export interface PledgeConnectionSubscription
  extends Promise<AsyncIterator<PledgeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PledgeEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePledgeSubscription>() => T;
}

export interface CrownSubscriptionPayload {
  mutation: MutationType;
  node: Crown;
  updatedFields: String[];
  previousValues: CrownPreviousValues;
}

export interface CrownSubscriptionPayloadPromise
  extends Promise<CrownSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CrownPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CrownPreviousValuesPromise>() => T;
}

export interface CrownSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CrownSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CrownSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CrownPreviousValuesSubscription>() => T;
}

export interface PathEdge {
  node: Path;
  cursor: String;
}

export interface PathEdgePromise extends Promise<PathEdge>, Fragmentable {
  node: <T = PathPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PathEdgeSubscription
  extends Promise<AsyncIterator<PathEdge>>,
    Fragmentable {
  node: <T = PathSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CrownPreviousValues {
  id: ID_Output;
}

export interface CrownPreviousValuesPromise
  extends Promise<CrownPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CrownPreviousValuesSubscription
  extends Promise<AsyncIterator<CrownPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregatePaladin {
  count: Int;
}

export interface AggregatePaladinPromise
  extends Promise<AggregatePaladin>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaladinSubscription
  extends Promise<AsyncIterator<AggregatePaladin>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Salvation {
  id: ID_Output;
  thought: String;
  character: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SalvationPromise extends Promise<Salvation>, Fragmentable {
  id: () => Promise<ID_Output>;
  thought: () => Promise<String>;
  character: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SalvationSubscription
  extends Promise<AsyncIterator<Salvation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  thought: () => Promise<AsyncIterator<String>>;
  character: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PaladinConnection {
  pageInfo: PageInfo;
  edges: PaladinEdge[];
}

export interface PaladinConnectionPromise
  extends Promise<PaladinConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaladinEdge>>() => T;
  aggregate: <T = AggregatePaladinPromise>() => T;
}

export interface PaladinConnectionSubscription
  extends Promise<AsyncIterator<PaladinConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaladinEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaladinSubscription>() => T;
}

export interface CrusadeSubscriptionPayload {
  mutation: MutationType;
  node: Crusade;
  updatedFields: String[];
  previousValues: CrusadePreviousValues;
}

export interface CrusadeSubscriptionPayloadPromise
  extends Promise<CrusadeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CrusadePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CrusadePreviousValuesPromise>() => T;
}

export interface CrusadeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CrusadeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CrusadeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CrusadePreviousValuesSubscription>() => T;
}

export interface ObsessionEdge {
  node: Obsession;
  cursor: String;
}

export interface ObsessionEdgePromise
  extends Promise<ObsessionEdge>,
    Fragmentable {
  node: <T = ObsessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ObsessionEdgeSubscription
  extends Promise<AsyncIterator<ObsessionEdge>>,
    Fragmentable {
  node: <T = ObsessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CrusadePreviousValues {
  id: ID_Output;
}

export interface CrusadePreviousValuesPromise
  extends Promise<CrusadePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CrusadePreviousValuesSubscription
  extends Promise<AsyncIterator<CrusadePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateOath {
  count: Int;
}

export interface AggregateOathPromise
  extends Promise<AggregateOath>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOathSubscription
  extends Promise<AsyncIterator<AggregateOath>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Dream {
  id: ID_Output;
}

export interface DreamPromise extends Promise<Dream>, Fragmentable {
  id: () => Promise<ID_Output>;
  salvation: <T = FragmentableArray<Salvation>>(
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DreamSubscription
  extends Promise<AsyncIterator<Dream>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  salvation: <T = Promise<AsyncIterator<SalvationSubscription>>>(
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface OathConnection {
  pageInfo: PageInfo;
  edges: OathEdge[];
}

export interface OathConnectionPromise
  extends Promise<OathConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OathEdge>>() => T;
  aggregate: <T = AggregateOathPromise>() => T;
}

export interface OathConnectionSubscription
  extends Promise<AsyncIterator<OathConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OathEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOathSubscription>() => T;
}

export interface DefectSubscriptionPayload {
  mutation: MutationType;
  node: Defect;
  updatedFields: String[];
  previousValues: DefectPreviousValues;
}

export interface DefectSubscriptionPayloadPromise
  extends Promise<DefectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DefectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DefectPreviousValuesPromise>() => T;
}

export interface DefectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DefectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DefectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DefectPreviousValuesSubscription>() => T;
}

export interface NightmareEdge {
  node: Nightmare;
  cursor: String;
}

export interface NightmareEdgePromise
  extends Promise<NightmareEdge>,
    Fragmentable {
  node: <T = NightmarePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NightmareEdgeSubscription
  extends Promise<AsyncIterator<NightmareEdge>>,
    Fragmentable {
  node: <T = NightmareSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DefectPreviousValues {
  id: ID_Output;
}

export interface DefectPreviousValuesPromise
  extends Promise<DefectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface DefectPreviousValuesSubscription
  extends Promise<AsyncIterator<DefectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateNail {
  count: Int;
}

export interface AggregateNailPromise
  extends Promise<AggregateNail>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNailSubscription
  extends Promise<AsyncIterator<AggregateNail>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Wish {
  id: ID_Output;
}

export interface WishPromise extends Promise<Wish>, Fragmentable {
  id: () => Promise<ID_Output>;
  dream: <T = FragmentableArray<Dream>>(
    args?: {
      where?: DreamWhereInput;
      orderBy?: DreamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WishSubscription
  extends Promise<AsyncIterator<Wish>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  dream: <T = Promise<AsyncIterator<DreamSubscription>>>(
    args?: {
      where?: DreamWhereInput;
      orderBy?: DreamOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface NailConnection {
  pageInfo: PageInfo;
  edges: NailEdge[];
}

export interface NailConnectionPromise
  extends Promise<NailConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NailEdge>>() => T;
  aggregate: <T = AggregateNailPromise>() => T;
}

export interface NailConnectionSubscription
  extends Promise<AsyncIterator<NailConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NailEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNailSubscription>() => T;
}

export interface DeliriumSubscriptionPayload {
  mutation: MutationType;
  node: Delirium;
  updatedFields: String[];
  previousValues: DeliriumPreviousValues;
}

export interface DeliriumSubscriptionPayloadPromise
  extends Promise<DeliriumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DeliriumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DeliriumPreviousValuesPromise>() => T;
}

export interface DeliriumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DeliriumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DeliriumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DeliriumPreviousValuesSubscription>() => T;
}

export interface MouthEdge {
  node: Mouth;
  cursor: String;
}

export interface MouthEdgePromise extends Promise<MouthEdge>, Fragmentable {
  node: <T = MouthPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MouthEdgeSubscription
  extends Promise<AsyncIterator<MouthEdge>>,
    Fragmentable {
  node: <T = MouthSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DeliriumPreviousValues {
  id: ID_Output;
}

export interface DeliriumPreviousValuesPromise
  extends Promise<DeliriumPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface DeliriumPreviousValuesSubscription
  extends Promise<AsyncIterator<DeliriumPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateMind {
  count: Int;
}

export interface AggregateMindPromise
  extends Promise<AggregateMind>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMindSubscription
  extends Promise<AsyncIterator<AggregateMind>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Genie {
  id: ID_Output;
}

export interface GeniePromise extends Promise<Genie>, Fragmentable {
  id: () => Promise<ID_Output>;
  wish: <T = FragmentableArray<Wish>>(
    args?: {
      where?: WishWhereInput;
      orderBy?: WishOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GenieSubscription
  extends Promise<AsyncIterator<Genie>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  wish: <T = Promise<AsyncIterator<WishSubscription>>>(
    args?: {
      where?: WishWhereInput;
      orderBy?: WishOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface MindConnection {
  pageInfo: PageInfo;
  edges: MindEdge[];
}

export interface MindConnectionPromise
  extends Promise<MindConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MindEdge>>() => T;
  aggregate: <T = AggregateMindPromise>() => T;
}

export interface MindConnectionSubscription
  extends Promise<AsyncIterator<MindConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MindEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMindSubscription>() => T;
}

export interface DenialSubscriptionPayload {
  mutation: MutationType;
  node: Denial;
  updatedFields: String[];
  previousValues: DenialPreviousValues;
}

export interface DenialSubscriptionPayloadPromise
  extends Promise<DenialSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DenialPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DenialPreviousValuesPromise>() => T;
}

export interface DenialSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DenialSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DenialSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DenialPreviousValuesSubscription>() => T;
}

export interface AggregateMartyr {
  count: Int;
}

export interface AggregateMartyrPromise
  extends Promise<AggregateMartyr>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMartyrSubscription
  extends Promise<AsyncIterator<AggregateMartyr>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Mind {
  id: ID_Output;
}

export interface MindPromise extends Promise<Mind>, Fragmentable {
  id: () => Promise<ID_Output>;
  vulnerability: <T = FragmentableArray<Vulnerability>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = FragmentableArray<Acceptance>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface MindSubscription
  extends Promise<AsyncIterator<Mind>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vulnerability: <T = Promise<AsyncIterator<VulnerabilitySubscription>>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = Promise<AsyncIterator<AcceptanceSubscription>>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface WallSubscriptionPayload {
  mutation: MutationType;
  node: Wall;
  updatedFields: String[];
  previousValues: WallPreviousValues;
}

export interface WallSubscriptionPayloadPromise
  extends Promise<WallSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WallPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WallPreviousValuesPromise>() => T;
}

export interface WallSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WallSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WallSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WallPreviousValuesSubscription>() => T;
}

export interface MartyrEdge {
  node: Martyr;
  cursor: String;
}

export interface MartyrEdgePromise extends Promise<MartyrEdge>, Fragmentable {
  node: <T = MartyrPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MartyrEdgeSubscription
  extends Promise<AsyncIterator<MartyrEdge>>,
    Fragmentable {
  node: <T = MartyrSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MartyrConnection {
  pageInfo: PageInfo;
  edges: MartyrEdge[];
}

export interface MartyrConnectionPromise
  extends Promise<MartyrConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MartyrEdge>>() => T;
  aggregate: <T = AggregateMartyrPromise>() => T;
}

export interface MartyrConnectionSubscription
  extends Promise<AsyncIterator<MartyrConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MartyrEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMartyrSubscription>() => T;
}

export interface AggregateLoyalty {
  count: Int;
}

export interface AggregateLoyaltyPromise
  extends Promise<AggregateLoyalty>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoyaltySubscription
  extends Promise<AsyncIterator<AggregateLoyalty>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoyaltyConnection {
  pageInfo: PageInfo;
  edges: LoyaltyEdge[];
}

export interface LoyaltyConnectionPromise
  extends Promise<LoyaltyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoyaltyEdge>>() => T;
  aggregate: <T = AggregateLoyaltyPromise>() => T;
}

export interface LoyaltyConnectionSubscription
  extends Promise<AsyncIterator<LoyaltyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoyaltyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoyaltySubscription>() => T;
}

export interface Congregant {
  id: ID_Output;
}

export interface CongregantPromise extends Promise<Congregant>, Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CongregantSubscription
  extends Promise<AsyncIterator<Congregant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface LoveEdge {
  node: Love;
  cursor: String;
}

export interface LoveEdgePromise extends Promise<LoveEdge>, Fragmentable {
  node: <T = LovePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoveEdgeSubscription
  extends Promise<AsyncIterator<LoveEdge>>,
    Fragmentable {
  node: <T = LoveSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DiscontentSubscriptionPayload {
  mutation: MutationType;
  node: Discontent;
  updatedFields: String[];
  previousValues: DiscontentPreviousValues;
}

export interface DiscontentSubscriptionPayloadPromise
  extends Promise<DiscontentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DiscontentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DiscontentPreviousValuesPromise>() => T;
}

export interface DiscontentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DiscontentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DiscontentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DiscontentPreviousValuesSubscription>() => T;
}

export interface Love {
  id: ID_Output;
}

export interface LovePromise extends Promise<Love>, Fragmentable {
  id: () => Promise<ID_Output>;
  vulnerability: <T = FragmentableArray<Vulnerability>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = FragmentableArray<Acceptance>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface LoveSubscription
  extends Promise<AsyncIterator<Love>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vulnerability: <T = Promise<AsyncIterator<VulnerabilitySubscription>>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = Promise<AsyncIterator<AcceptanceSubscription>>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DiscontentPreviousValues {
  id: ID_Output;
}

export interface DiscontentPreviousValuesPromise
  extends Promise<DiscontentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface DiscontentPreviousValuesSubscription
  extends Promise<AsyncIterator<DiscontentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface JoyEdge {
  node: Joy;
  cursor: String;
}

export interface JoyEdgePromise extends Promise<JoyEdge>, Fragmentable {
  node: <T = JoyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface JoyEdgeSubscription
  extends Promise<AsyncIterator<JoyEdge>>,
    Fragmentable {
  node: <T = JoySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Characters {
  id: ID_Output;
}

export interface CharactersPromise extends Promise<Characters>, Fragmentable {
  id: () => Promise<ID_Output>;
  congregant: <T = CongregantPromise>() => T;
  genie: <T = GeniePromise>() => T;
  guardian: <T = GuardianPromise>() => T;
  martyr: <T = MartyrPromise>() => T;
  paladin: <T = PaladinPromise>() => T;
  seeker: <T = SeekerPromise>() => T;
  self: <T = SelfPromise>() => T;
  smith: <T = SmithPromise>() => T;
  summoner: <T = SummonerPromise>() => T;
  victim: <T = VictimPromise>() => T;
  volunteer: <T = VolunteerPromise>() => T;
}

export interface CharactersSubscription
  extends Promise<AsyncIterator<Characters>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  congregant: <T = CongregantSubscription>() => T;
  genie: <T = GenieSubscription>() => T;
  guardian: <T = GuardianSubscription>() => T;
  martyr: <T = MartyrSubscription>() => T;
  paladin: <T = PaladinSubscription>() => T;
  seeker: <T = SeekerSubscription>() => T;
  self: <T = SelfSubscription>() => T;
  smith: <T = SmithSubscription>() => T;
  summoner: <T = SummonerSubscription>() => T;
  victim: <T = VictimSubscription>() => T;
  volunteer: <T = VolunteerSubscription>() => T;
}

export interface AggregateIrritability {
  count: Int;
}

export interface AggregateIrritabilityPromise
  extends Promise<AggregateIrritability>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIrritabilitySubscription
  extends Promise<AsyncIterator<AggregateIrritability>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DreamSubscriptionPayload {
  mutation: MutationType;
  node: Dream;
  updatedFields: String[];
  previousValues: DreamPreviousValues;
}

export interface DreamSubscriptionPayloadPromise
  extends Promise<DreamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DreamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DreamPreviousValuesPromise>() => T;
}

export interface DreamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DreamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DreamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DreamPreviousValuesSubscription>() => T;
}

export interface IrritabilityConnection {
  pageInfo: PageInfo;
  edges: IrritabilityEdge[];
}

export interface IrritabilityConnectionPromise
  extends Promise<IrritabilityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IrritabilityEdge>>() => T;
  aggregate: <T = AggregateIrritabilityPromise>() => T;
}

export interface IrritabilityConnectionSubscription
  extends Promise<AsyncIterator<IrritabilityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IrritabilityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIrritabilitySubscription>() => T;
}

export interface DreamPreviousValues {
  id: ID_Output;
}

export interface DreamPreviousValuesPromise
  extends Promise<DreamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface DreamPreviousValuesSubscription
  extends Promise<AsyncIterator<DreamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface InventoryEdge {
  node: Inventory;
  cursor: String;
}

export interface InventoryEdgePromise
  extends Promise<InventoryEdge>,
    Fragmentable {
  node: <T = InventoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryEdgeSubscription
  extends Promise<AsyncIterator<InventoryEdge>>,
    Fragmentable {
  node: <T = InventorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCampaign {
  count: Int;
}

export interface AggregateCampaignPromise
  extends Promise<AggregateCampaign>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCampaignSubscription
  extends Promise<AsyncIterator<AggregateCampaign>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Inventory {
  id: ID_Output;
}

export interface InventoryPromise extends Promise<Inventory>, Fragmentable {
  id: () => Promise<ID_Output>;
  defect: <T = FragmentableArray<Defect>>(
    args?: {
      where?: DefectWhereInput;
      orderBy?: DefectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  discontent: <T = FragmentableArray<Discontent>>(
    args?: {
      where?: DiscontentWhereInput;
      orderBy?: DiscontentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  resentment: <T = FragmentableArray<Resentment>>(
    args?: {
      where?: ResentmentWhereInput;
      orderBy?: ResentmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  obsession: <T = FragmentableArray<Obsession>>(
    args?: {
      where?: ObsessionWhereInput;
      orderBy?: ObsessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  experience: <T = FragmentableArray<Experience>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  strength: <T = FragmentableArray<Strength>>(
    args?: {
      where?: StrengthWhereInput;
      orderBy?: StrengthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hope: <T = FragmentableArray<Hope>>(
    args?: {
      where?: HopeWhereInput;
      orderBy?: HopeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface InventorySubscription
  extends Promise<AsyncIterator<Inventory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  defect: <T = Promise<AsyncIterator<DefectSubscription>>>(
    args?: {
      where?: DefectWhereInput;
      orderBy?: DefectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  discontent: <T = Promise<AsyncIterator<DiscontentSubscription>>>(
    args?: {
      where?: DiscontentWhereInput;
      orderBy?: DiscontentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  resentment: <T = Promise<AsyncIterator<ResentmentSubscription>>>(
    args?: {
      where?: ResentmentWhereInput;
      orderBy?: ResentmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  obsession: <T = Promise<AsyncIterator<ObsessionSubscription>>>(
    args?: {
      where?: ObsessionWhereInput;
      orderBy?: ObsessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  experience: <T = Promise<AsyncIterator<ExperienceSubscription>>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  strength: <T = Promise<AsyncIterator<StrengthSubscription>>>(
    args?: {
      where?: StrengthWhereInput;
      orderBy?: StrengthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hope: <T = Promise<AsyncIterator<HopeSubscription>>>(
    args?: {
      where?: HopeWhereInput;
      orderBy?: HopeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ExperienceSubscriptionPayload {
  mutation: MutationType;
  node: Experience;
  updatedFields: String[];
  previousValues: ExperiencePreviousValues;
}

export interface ExperienceSubscriptionPayloadPromise
  extends Promise<ExperienceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExperiencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExperiencePreviousValuesPromise>() => T;
}

export interface ExperienceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExperiencePreviousValuesSubscription>() => T;
}

export interface InfectionEdge {
  node: Infection;
  cursor: String;
}

export interface InfectionEdgePromise
  extends Promise<InfectionEdge>,
    Fragmentable {
  node: <T = InfectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InfectionEdgeSubscription
  extends Promise<AsyncIterator<InfectionEdge>>,
    Fragmentable {
  node: <T = InfectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperiencePreviousValues {
  id: ID_Output;
}

export interface ExperiencePreviousValuesPromise
  extends Promise<ExperiencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ExperiencePreviousValuesSubscription
  extends Promise<AsyncIterator<ExperiencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateImpatience {
  count: Int;
}

export interface AggregateImpatiencePromise
  extends Promise<AggregateImpatience>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImpatienceSubscription
  extends Promise<AsyncIterator<AggregateImpatience>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CampaignEdge {
  node: Campaign;
  cursor: String;
}

export interface CampaignEdgePromise
  extends Promise<CampaignEdge>,
    Fragmentable {
  node: <T = CampaignPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CampaignEdgeSubscription
  extends Promise<AsyncIterator<CampaignEdge>>,
    Fragmentable {
  node: <T = CampaignSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImpatienceConnection {
  pageInfo: PageInfo;
  edges: ImpatienceEdge[];
}

export interface ImpatienceConnectionPromise
  extends Promise<ImpatienceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImpatienceEdge>>() => T;
  aggregate: <T = AggregateImpatiencePromise>() => T;
}

export interface ImpatienceConnectionSubscription
  extends Promise<AsyncIterator<ImpatienceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImpatienceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImpatienceSubscription>() => T;
}

export interface FaceSubscriptionPayload {
  mutation: MutationType;
  node: Face;
  updatedFields: String[];
  previousValues: FacePreviousValues;
}

export interface FaceSubscriptionPayloadPromise
  extends Promise<FaceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FacePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FacePreviousValuesPromise>() => T;
}

export interface FaceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FaceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FaceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FacePreviousValuesSubscription>() => T;
}

export interface HopeEdge {
  node: Hope;
  cursor: String;
}

export interface HopeEdgePromise extends Promise<HopeEdge>, Fragmentable {
  node: <T = HopePromise>() => T;
  cursor: () => Promise<String>;
}

export interface HopeEdgeSubscription
  extends Promise<AsyncIterator<HopeEdge>>,
    Fragmentable {
  node: <T = HopeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FacePreviousValues {
  id: ID_Output;
}

export interface FacePreviousValuesPromise
  extends Promise<FacePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface FacePreviousValuesSubscription
  extends Promise<AsyncIterator<FacePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateHonor {
  count: Int;
}

export interface AggregateHonorPromise
  extends Promise<AggregateHonor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHonorSubscription
  extends Promise<AsyncIterator<AggregateHonor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CampaignConnection {
  pageInfo: PageInfo;
  edges: CampaignEdge[];
}

export interface CampaignConnectionPromise
  extends Promise<CampaignConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CampaignEdge>>() => T;
  aggregate: <T = AggregateCampaignPromise>() => T;
}

export interface CampaignConnectionSubscription
  extends Promise<AsyncIterator<CampaignConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CampaignEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCampaignSubscription>() => T;
}

export interface HonorConnection {
  pageInfo: PageInfo;
  edges: HonorEdge[];
}

export interface HonorConnectionPromise
  extends Promise<HonorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HonorEdge>>() => T;
  aggregate: <T = AggregateHonorPromise>() => T;
}

export interface HonorConnectionSubscription
  extends Promise<AsyncIterator<HonorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HonorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHonorSubscription>() => T;
}

export interface FearSubscriptionPayload {
  mutation: MutationType;
  node: Fear;
  updatedFields: String[];
  previousValues: FearPreviousValues;
}

export interface FearSubscriptionPayloadPromise
  extends Promise<FearSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FearPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FearPreviousValuesPromise>() => T;
}

export interface FearSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FearSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FearSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FearPreviousValuesSubscription>() => T;
}

export interface HigherPowerEdge {
  node: HigherPower;
  cursor: String;
}

export interface HigherPowerEdgePromise
  extends Promise<HigherPowerEdge>,
    Fragmentable {
  node: <T = HigherPowerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HigherPowerEdgeSubscription
  extends Promise<AsyncIterator<HigherPowerEdge>>,
    Fragmentable {
  node: <T = HigherPowerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FearPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface FearPreviousValuesPromise
  extends Promise<FearPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface FearPreviousValuesSubscription
  extends Promise<AsyncIterator<FearPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Joy {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolveAt?: DateTimeOutput;
}

export interface JoyPromise extends Promise<Joy>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolveAt: () => Promise<DateTimeOutput>;
}

export interface JoySubscription
  extends Promise<AsyncIterator<Joy>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Honor {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface HonorPromise extends Promise<Honor>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface HonorSubscription
  extends Promise<AsyncIterator<Honor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Strength {
  id: ID_Output;
}

export interface StrengthPromise extends Promise<Strength>, Fragmentable {
  id: () => Promise<ID_Output>;
  armor: <T = FragmentableArray<Armor>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  boundary: <T = FragmentableArray<Boundary>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loyalty: <T = FragmentableArray<Loyalty>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = FragmentableArray<Honor>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StrengthSubscription
  extends Promise<AsyncIterator<Strength>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  armor: <T = Promise<AsyncIterator<ArmorSubscription>>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  boundary: <T = Promise<AsyncIterator<BoundarySubscription>>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loyalty: <T = Promise<AsyncIterator<LoyaltySubscription>>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = Promise<AsyncIterator<HonorSubscription>>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FeelingSubscriptionPayload {
  mutation: MutationType;
  node: Feeling;
  updatedFields: String[];
  previousValues: FeelingPreviousValues;
}

export interface FeelingSubscriptionPayloadPromise
  extends Promise<FeelingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FeelingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FeelingPreviousValuesPromise>() => T;
}

export interface FeelingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FeelingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FeelingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FeelingPreviousValuesSubscription>() => T;
}

export interface Resentment {
  id: ID_Output;
}

export interface ResentmentPromise extends Promise<Resentment>, Fragmentable {
  id: () => Promise<ID_Output>;
  anger: <T = FragmentableArray<Anger>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = FragmentableArray<SelfPity>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = FragmentableArray<Fear>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = FragmentableArray<Pride>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ResentmentSubscription
  extends Promise<AsyncIterator<Resentment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  anger: <T = Promise<AsyncIterator<AngerSubscription>>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = Promise<AsyncIterator<SelfPitySubscription>>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = Promise<AsyncIterator<FearSubscription>>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = Promise<AsyncIterator<PrideSubscription>>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FeelingPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface FeelingPreviousValuesPromise
  extends Promise<FeelingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface FeelingPreviousValuesSubscription
  extends Promise<AsyncIterator<FeelingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Process {
  id: ID_Output;
}

export interface ProcessPromise extends Promise<Process>, Fragmentable {
  id: () => Promise<ID_Output>;
  act: <T = ActPromise>() => T;
  affliction: <T = AfflictionPromise>() => T;
  body: <T = BodyPromise>() => T;
  construct: <T = ConstructPromise>() => T;
  oath: <T = OathPromise>() => T;
  shield: <T = ShieldPromise>() => T;
  stigmata: <T = StigmataPromise>() => T;
  virtue: <T = VirtuePromise>() => T;
  wish: <T = WishPromise>() => T;
}

export interface ProcessSubscription
  extends Promise<AsyncIterator<Process>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  act: <T = ActSubscription>() => T;
  affliction: <T = AfflictionSubscription>() => T;
  body: <T = BodySubscription>() => T;
  construct: <T = ConstructSubscription>() => T;
  oath: <T = OathSubscription>() => T;
  shield: <T = ShieldSubscription>() => T;
  stigmata: <T = StigmataSubscription>() => T;
  virtue: <T = VirtueSubscription>() => T;
  wish: <T = WishSubscription>() => T;
}

export interface Loyalty {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface LoyaltyPromise extends Promise<Loyalty>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface LoyaltySubscription
  extends Promise<AsyncIterator<Loyalty>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HigherPower {
  id: ID_Output;
}

export interface HigherPowerPromise extends Promise<HigherPower>, Fragmentable {
  id: () => Promise<ID_Output>;
  prayer: <T = PrayerPromise>() => T;
  inventory: <T = FragmentableArray<Feeling>>(
    args?: {
      where?: FeelingWhereInput;
      orderBy?: FeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  character: <T = CharactersPromise>() => T;
}

export interface HigherPowerSubscription
  extends Promise<AsyncIterator<HigherPower>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  prayer: <T = PrayerSubscription>() => T;
  inventory: <T = Promise<AsyncIterator<FeelingSubscription>>>(
    args?: {
      where?: FeelingWhereInput;
      orderBy?: FeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  character: <T = CharactersSubscription>() => T;
}

export interface FunSubscriptionPayload {
  mutation: MutationType;
  node: Fun;
  updatedFields: String[];
  previousValues: FunPreviousValues;
}

export interface FunSubscriptionPayloadPromise
  extends Promise<FunSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FunPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FunPreviousValuesPromise>() => T;
}

export interface FunSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FunSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FunSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FunPreviousValuesSubscription>() => T;
}

export interface HeartEdge {
  node: Heart;
  cursor: String;
}

export interface HeartEdgePromise extends Promise<HeartEdge>, Fragmentable {
  node: <T = HeartPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HeartEdgeSubscription
  extends Promise<AsyncIterator<HeartEdge>>,
    Fragmentable {
  node: <T = HeartSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FunPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolveAt?: DateTimeOutput;
}

export interface FunPreviousValuesPromise
  extends Promise<FunPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolveAt: () => Promise<DateTimeOutput>;
}

export interface FunPreviousValuesSubscription
  extends Promise<AsyncIterator<FunPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateHas {
  count: Int;
}

export interface AggregateHasPromise
  extends Promise<AggregateHas>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHasSubscription
  extends Promise<AsyncIterator<AggregateHas>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Campaign {
  id: ID_Output;
}

export interface CampaignPromise extends Promise<Campaign>, Fragmentable {
  id: () => Promise<ID_Output>;
  loyalty: <T = FragmentableArray<Loyalty>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = FragmentableArray<Honor>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CampaignSubscription
  extends Promise<AsyncIterator<Campaign>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  loyalty: <T = Promise<AsyncIterator<LoyaltySubscription>>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = Promise<AsyncIterator<HonorSubscription>>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HasConnection {
  pageInfo: PageInfo;
  edges: HasEdge[];
}

export interface HasConnectionPromise
  extends Promise<HasConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HasEdge>>() => T;
  aggregate: <T = AggregateHasPromise>() => T;
}

export interface HasConnectionSubscription
  extends Promise<AsyncIterator<HasConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HasEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHasSubscription>() => T;
}

export interface GashSubscriptionPayload {
  mutation: MutationType;
  node: Gash;
  updatedFields: String[];
  previousValues: GashPreviousValues;
}

export interface GashSubscriptionPayloadPromise
  extends Promise<GashSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GashPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GashPreviousValuesPromise>() => T;
}

export interface GashSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GashSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GashSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GashPreviousValuesSubscription>() => T;
}

export interface AggregateGut {
  count: Int;
}

export interface AggregateGutPromise
  extends Promise<AggregateGut>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGutSubscription
  extends Promise<AsyncIterator<AggregateGut>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GashPreviousValues {
  id: ID_Output;
}

export interface GashPreviousValuesPromise
  extends Promise<GashPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface GashPreviousValuesSubscription
  extends Promise<AsyncIterator<GashPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface GutConnection {
  pageInfo: PageInfo;
  edges: GutEdge[];
}

export interface GutConnectionPromise
  extends Promise<GutConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GutEdge>>() => T;
  aggregate: <T = AggregateGutPromise>() => T;
}

export interface GutConnectionSubscription
  extends Promise<AsyncIterator<GutConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GutEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGutSubscription>() => T;
}

export interface AggregateBrain {
  count: Int;
}

export interface AggregateBrainPromise
  extends Promise<AggregateBrain>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBrainSubscription
  extends Promise<AsyncIterator<AggregateBrain>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GuardianEdge {
  node: Guardian;
  cursor: String;
}

export interface GuardianEdgePromise
  extends Promise<GuardianEdge>,
    Fragmentable {
  node: <T = GuardianPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GuardianEdgeSubscription
  extends Promise<AsyncIterator<GuardianEdge>>,
    Fragmentable {
  node: <T = GuardianSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GateSubscriptionPayload {
  mutation: MutationType;
  node: Gate;
  updatedFields: String[];
  previousValues: GatePreviousValues;
}

export interface GateSubscriptionPayloadPromise
  extends Promise<GateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GatePreviousValuesPromise>() => T;
}

export interface GateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GatePreviousValuesSubscription>() => T;
}

export interface AggregateGratitude {
  count: Int;
}

export interface AggregateGratitudePromise
  extends Promise<AggregateGratitude>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGratitudeSubscription
  extends Promise<AsyncIterator<AggregateGratitude>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GatePreviousValues {
  id: ID_Output;
}

export interface GatePreviousValuesPromise
  extends Promise<GatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface GatePreviousValuesSubscription
  extends Promise<AsyncIterator<GatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface GratitudeConnection {
  pageInfo: PageInfo;
  edges: GratitudeEdge[];
}

export interface GratitudeConnectionPromise
  extends Promise<GratitudeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GratitudeEdge>>() => T;
  aggregate: <T = AggregateGratitudePromise>() => T;
}

export interface GratitudeConnectionSubscription
  extends Promise<AsyncIterator<GratitudeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GratitudeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGratitudeSubscription>() => T;
}

export interface BrainEdge {
  node: Brain;
  cursor: String;
}

export interface BrainEdgePromise extends Promise<BrainEdge>, Fragmentable {
  node: <T = BrainPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BrainEdgeSubscription
  extends Promise<AsyncIterator<BrainEdge>>,
    Fragmentable {
  node: <T = BrainSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GenieEdge {
  node: Genie;
  cursor: String;
}

export interface GenieEdgePromise extends Promise<GenieEdge>, Fragmentable {
  node: <T = GeniePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GenieEdgeSubscription
  extends Promise<AsyncIterator<GenieEdge>>,
    Fragmentable {
  node: <T = GenieSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GenieSubscriptionPayload {
  mutation: MutationType;
  node: Genie;
  updatedFields: String[];
  previousValues: GeniePreviousValues;
}

export interface GenieSubscriptionPayloadPromise
  extends Promise<GenieSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GeniePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GeniePreviousValuesPromise>() => T;
}

export interface GenieSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GenieSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GenieSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GeniePreviousValuesSubscription>() => T;
}

export interface AggregateGate {
  count: Int;
}

export interface AggregateGatePromise
  extends Promise<AggregateGate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGateSubscription
  extends Promise<AsyncIterator<AggregateGate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GeniePreviousValues {
  id: ID_Output;
}

export interface GeniePreviousValuesPromise
  extends Promise<GeniePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface GeniePreviousValuesSubscription
  extends Promise<AsyncIterator<GeniePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface GateConnection {
  pageInfo: PageInfo;
  edges: GateEdge[];
}

export interface GateConnectionPromise
  extends Promise<GateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GateEdge>>() => T;
  aggregate: <T = AggregateGatePromise>() => T;
}

export interface GateConnectionSubscription
  extends Promise<AsyncIterator<GateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGateSubscription>() => T;
}

export interface BrainConnection {
  pageInfo: PageInfo;
  edges: BrainEdge[];
}

export interface BrainConnectionPromise
  extends Promise<BrainConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BrainEdge>>() => T;
  aggregate: <T = AggregateBrainPromise>() => T;
}

export interface BrainConnectionSubscription
  extends Promise<AsyncIterator<BrainConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BrainEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBrainSubscription>() => T;
}

export interface GashEdge {
  node: Gash;
  cursor: String;
}

export interface GashEdgePromise extends Promise<GashEdge>, Fragmentable {
  node: <T = GashPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GashEdgeSubscription
  extends Promise<AsyncIterator<GashEdge>>,
    Fragmentable {
  node: <T = GashSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GratitudeSubscriptionPayload {
  mutation: MutationType;
  node: Gratitude;
  updatedFields: String[];
  previousValues: GratitudePreviousValues;
}

export interface GratitudeSubscriptionPayloadPromise
  extends Promise<GratitudeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GratitudePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GratitudePreviousValuesPromise>() => T;
}

export interface GratitudeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GratitudeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GratitudeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GratitudePreviousValuesSubscription>() => T;
}

export interface AggregateFun {
  count: Int;
}

export interface AggregateFunPromise
  extends Promise<AggregateFun>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFunSubscription
  extends Promise<AsyncIterator<AggregateFun>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GratitudePreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface GratitudePreviousValuesPromise
  extends Promise<GratitudePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface GratitudePreviousValuesSubscription
  extends Promise<AsyncIterator<GratitudePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FunConnection {
  pageInfo: PageInfo;
  edges: FunEdge[];
}

export interface FunConnectionPromise
  extends Promise<FunConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FunEdge>>() => T;
  aggregate: <T = AggregateFunPromise>() => T;
}

export interface FunConnectionSubscription
  extends Promise<AsyncIterator<FunConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FunEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFunSubscription>() => T;
}

export interface AggregateBoundary {
  count: Int;
}

export interface AggregateBoundaryPromise
  extends Promise<AggregateBoundary>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBoundarySubscription
  extends Promise<AsyncIterator<AggregateBoundary>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateFeeling {
  count: Int;
}

export interface AggregateFeelingPromise
  extends Promise<AggregateFeeling>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFeelingSubscription
  extends Promise<AsyncIterator<AggregateFeeling>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GuardianSubscriptionPayload {
  mutation: MutationType;
  node: Guardian;
  updatedFields: String[];
  previousValues: GuardianPreviousValues;
}

export interface GuardianSubscriptionPayloadPromise
  extends Promise<GuardianSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GuardianPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GuardianPreviousValuesPromise>() => T;
}

export interface GuardianSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GuardianSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GuardianSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GuardianPreviousValuesSubscription>() => T;
}

export interface FeelingConnection {
  pageInfo: PageInfo;
  edges: FeelingEdge[];
}

export interface FeelingConnectionPromise
  extends Promise<FeelingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FeelingEdge>>() => T;
  aggregate: <T = AggregateFeelingPromise>() => T;
}

export interface FeelingConnectionSubscription
  extends Promise<AsyncIterator<FeelingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FeelingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFeelingSubscription>() => T;
}

export interface GuardianPreviousValues {
  id: ID_Output;
}

export interface GuardianPreviousValuesPromise
  extends Promise<GuardianPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface GuardianPreviousValuesSubscription
  extends Promise<AsyncIterator<GuardianPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateFear {
  count: Int;
}

export interface AggregateFearPromise
  extends Promise<AggregateFear>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFearSubscription
  extends Promise<AsyncIterator<AggregateFear>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BoundaryEdge {
  node: Boundary;
  cursor: String;
}

export interface BoundaryEdgePromise
  extends Promise<BoundaryEdge>,
    Fragmentable {
  node: <T = BoundaryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BoundaryEdgeSubscription
  extends Promise<AsyncIterator<BoundaryEdge>>,
    Fragmentable {
  node: <T = BoundarySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FearConnection {
  pageInfo: PageInfo;
  edges: FearEdge[];
}

export interface FearConnectionPromise
  extends Promise<FearConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FearEdge>>() => T;
  aggregate: <T = AggregateFearPromise>() => T;
}

export interface FearConnectionSubscription
  extends Promise<AsyncIterator<FearConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FearEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFearSubscription>() => T;
}

export interface GutSubscriptionPayload {
  mutation: MutationType;
  node: Gut;
  updatedFields: String[];
  previousValues: GutPreviousValues;
}

export interface GutSubscriptionPayloadPromise
  extends Promise<GutSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GutPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GutPreviousValuesPromise>() => T;
}

export interface GutSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GutSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GutSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GutPreviousValuesSubscription>() => T;
}

export interface FaceEdge {
  node: Face;
  cursor: String;
}

export interface FaceEdgePromise extends Promise<FaceEdge>, Fragmentable {
  node: <T = FacePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FaceEdgeSubscription
  extends Promise<AsyncIterator<FaceEdge>>,
    Fragmentable {
  node: <T = FaceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GutPreviousValues {
  id: ID_Output;
}

export interface GutPreviousValuesPromise
  extends Promise<GutPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface GutPreviousValuesSubscription
  extends Promise<AsyncIterator<GutPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateExperience {
  count: Int;
}

export interface AggregateExperiencePromise
  extends Promise<AggregateExperience>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExperienceSubscription
  extends Promise<AsyncIterator<AggregateExperience>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BoundaryConnection {
  pageInfo: PageInfo;
  edges: BoundaryEdge[];
}

export interface BoundaryConnectionPromise
  extends Promise<BoundaryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BoundaryEdge>>() => T;
  aggregate: <T = AggregateBoundaryPromise>() => T;
}

export interface BoundaryConnectionSubscription
  extends Promise<AsyncIterator<BoundaryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BoundaryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBoundarySubscription>() => T;
}

export interface ExperienceConnection {
  pageInfo: PageInfo;
  edges: ExperienceEdge[];
}

export interface ExperienceConnectionPromise
  extends Promise<ExperienceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExperienceEdge>>() => T;
  aggregate: <T = AggregateExperiencePromise>() => T;
}

export interface ExperienceConnectionSubscription
  extends Promise<AsyncIterator<ExperienceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExperienceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExperienceSubscription>() => T;
}

export interface HasSubscriptionPayload {
  mutation: MutationType;
  node: Has;
  updatedFields: String[];
  previousValues: HasPreviousValues;
}

export interface HasSubscriptionPayloadPromise
  extends Promise<HasSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HasPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HasPreviousValuesPromise>() => T;
}

export interface HasSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HasSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HasSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HasPreviousValuesSubscription>() => T;
}

export interface Experience {
  id: ID_Output;
}

export interface ExperiencePromise extends Promise<Experience>, Fragmentable {
  id: () => Promise<ID_Output>;
  compassion: <T = FragmentableArray<Compassion>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  courage: <T = FragmentableArray<Courage>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = FragmentableArray<Acceptance>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vulnerability: <T = FragmentableArray<Vulnerability>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  gratitude: <T = FragmentableArray<Gratitude>>(
    args?: {
      where?: GratitudeWhereInput;
      orderBy?: GratitudeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  suffering: <T = FragmentableArray<Suffering>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ExperienceSubscription
  extends Promise<AsyncIterator<Experience>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  compassion: <T = Promise<AsyncIterator<CompassionSubscription>>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  courage: <T = Promise<AsyncIterator<CourageSubscription>>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = Promise<AsyncIterator<AcceptanceSubscription>>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vulnerability: <T = Promise<AsyncIterator<VulnerabilitySubscription>>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  gratitude: <T = Promise<AsyncIterator<GratitudeSubscription>>>(
    args?: {
      where?: GratitudeWhereInput;
      orderBy?: GratitudeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  suffering: <T = Promise<AsyncIterator<SufferingSubscription>>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HasPreviousValues {
  id: ID_Output;
  defect: Boolean;
  discontent: Boolean;
  resentment: Boolean;
  obsession: Boolean;
  experience: Boolean;
  strength: Boolean;
  hope: Boolean;
  acceptance: Boolean;
  anger: Boolean;
  armor: Boolean;
  boundary: Boolean;
  compassion: Boolean;
  courage: Boolean;
  fear: Boolean;
  fun: Boolean;
  gratitude: Boolean;
  irritability: Boolean;
  impatience: Boolean;
  joy: Boolean;
  pride: Boolean;
  salvaltion: Boolean;
  selfPity: Boolean;
  suffering: Boolean;
  toxicity: Boolean;
  trauma: Boolean;
  vulnerability: Boolean;
}

export interface HasPreviousValuesPromise
  extends Promise<HasPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  defect: () => Promise<Boolean>;
  discontent: () => Promise<Boolean>;
  resentment: () => Promise<Boolean>;
  obsession: () => Promise<Boolean>;
  experience: () => Promise<Boolean>;
  strength: () => Promise<Boolean>;
  hope: () => Promise<Boolean>;
  acceptance: () => Promise<Boolean>;
  anger: () => Promise<Boolean>;
  armor: () => Promise<Boolean>;
  boundary: () => Promise<Boolean>;
  compassion: () => Promise<Boolean>;
  courage: () => Promise<Boolean>;
  fear: () => Promise<Boolean>;
  fun: () => Promise<Boolean>;
  gratitude: () => Promise<Boolean>;
  irritability: () => Promise<Boolean>;
  impatience: () => Promise<Boolean>;
  joy: () => Promise<Boolean>;
  pride: () => Promise<Boolean>;
  salvaltion: () => Promise<Boolean>;
  selfPity: () => Promise<Boolean>;
  suffering: () => Promise<Boolean>;
  toxicity: () => Promise<Boolean>;
  trauma: () => Promise<Boolean>;
  vulnerability: () => Promise<Boolean>;
}

export interface HasPreviousValuesSubscription
  extends Promise<AsyncIterator<HasPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  defect: () => Promise<AsyncIterator<Boolean>>;
  discontent: () => Promise<AsyncIterator<Boolean>>;
  resentment: () => Promise<AsyncIterator<Boolean>>;
  obsession: () => Promise<AsyncIterator<Boolean>>;
  experience: () => Promise<AsyncIterator<Boolean>>;
  strength: () => Promise<AsyncIterator<Boolean>>;
  hope: () => Promise<AsyncIterator<Boolean>>;
  acceptance: () => Promise<AsyncIterator<Boolean>>;
  anger: () => Promise<AsyncIterator<Boolean>>;
  armor: () => Promise<AsyncIterator<Boolean>>;
  boundary: () => Promise<AsyncIterator<Boolean>>;
  compassion: () => Promise<AsyncIterator<Boolean>>;
  courage: () => Promise<AsyncIterator<Boolean>>;
  fear: () => Promise<AsyncIterator<Boolean>>;
  fun: () => Promise<AsyncIterator<Boolean>>;
  gratitude: () => Promise<AsyncIterator<Boolean>>;
  irritability: () => Promise<AsyncIterator<Boolean>>;
  impatience: () => Promise<AsyncIterator<Boolean>>;
  joy: () => Promise<AsyncIterator<Boolean>>;
  pride: () => Promise<AsyncIterator<Boolean>>;
  salvaltion: () => Promise<AsyncIterator<Boolean>>;
  selfPity: () => Promise<AsyncIterator<Boolean>>;
  suffering: () => Promise<AsyncIterator<Boolean>>;
  toxicity: () => Promise<AsyncIterator<Boolean>>;
  trauma: () => Promise<AsyncIterator<Boolean>>;
  vulnerability: () => Promise<AsyncIterator<Boolean>>;
}

export interface DreamEdge {
  node: Dream;
  cursor: String;
}

export interface DreamEdgePromise extends Promise<DreamEdge>, Fragmentable {
  node: <T = DreamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DreamEdgeSubscription
  extends Promise<AsyncIterator<DreamEdge>>,
    Fragmentable {
  node: <T = DreamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Boundary {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface BoundaryPromise extends Promise<Boundary>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface BoundarySubscription
  extends Promise<AsyncIterator<Boundary>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateDiscontent {
  count: Int;
}

export interface AggregateDiscontentPromise
  extends Promise<AggregateDiscontent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDiscontentSubscription
  extends Promise<AsyncIterator<AggregateDiscontent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HeartSubscriptionPayload {
  mutation: MutationType;
  node: Heart;
  updatedFields: String[];
  previousValues: HeartPreviousValues;
}

export interface HeartSubscriptionPayloadPromise
  extends Promise<HeartSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HeartPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HeartPreviousValuesPromise>() => T;
}

export interface HeartSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HeartSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HeartSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HeartPreviousValuesSubscription>() => T;
}

export interface DiscontentConnection {
  pageInfo: PageInfo;
  edges: DiscontentEdge[];
}

export interface DiscontentConnectionPromise
  extends Promise<DiscontentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DiscontentEdge>>() => T;
  aggregate: <T = AggregateDiscontentPromise>() => T;
}

export interface DiscontentConnectionSubscription
  extends Promise<AsyncIterator<DiscontentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DiscontentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDiscontentSubscription>() => T;
}

export interface HeartPreviousValues {
  id: ID_Output;
}

export interface HeartPreviousValuesPromise
  extends Promise<HeartPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface HeartPreviousValuesSubscription
  extends Promise<AsyncIterator<HeartPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Irritability {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolveAt?: DateTimeOutput;
}

export interface IrritabilityPromise
  extends Promise<Irritability>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolveAt: () => Promise<DateTimeOutput>;
}

export interface IrritabilitySubscription
  extends Promise<AsyncIterator<Irritability>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateBody {
  count: Int;
}

export interface AggregateBodyPromise
  extends Promise<AggregateBody>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBodySubscription
  extends Promise<AsyncIterator<AggregateBody>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateDenial {
  count: Int;
}

export interface AggregateDenialPromise
  extends Promise<AggregateDenial>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDenialSubscription
  extends Promise<AsyncIterator<AggregateDenial>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HigherPowerSubscriptionPayload {
  mutation: MutationType;
  node: HigherPower;
  updatedFields: String[];
  previousValues: HigherPowerPreviousValues;
}

export interface HigherPowerSubscriptionPayloadPromise
  extends Promise<HigherPowerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HigherPowerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HigherPowerPreviousValuesPromise>() => T;
}

export interface HigherPowerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HigherPowerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HigherPowerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HigherPowerPreviousValuesSubscription>() => T;
}

export interface DenialConnection {
  pageInfo: PageInfo;
  edges: DenialEdge[];
}

export interface DenialConnectionPromise
  extends Promise<DenialConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DenialEdge>>() => T;
  aggregate: <T = AggregateDenialPromise>() => T;
}

export interface DenialConnectionSubscription
  extends Promise<AsyncIterator<DenialConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DenialEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDenialSubscription>() => T;
}

export interface HigherPowerPreviousValues {
  id: ID_Output;
}

export interface HigherPowerPreviousValuesPromise
  extends Promise<HigherPowerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface HigherPowerPreviousValuesSubscription
  extends Promise<AsyncIterator<HigherPowerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface DeliriumEdge {
  node: Delirium;
  cursor: String;
}

export interface DeliriumEdgePromise
  extends Promise<DeliriumEdge>,
    Fragmentable {
  node: <T = DeliriumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DeliriumEdgeSubscription
  extends Promise<AsyncIterator<DeliriumEdge>>,
    Fragmentable {
  node: <T = DeliriumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BodyEdge {
  node: Body;
  cursor: String;
}

export interface BodyEdgePromise extends Promise<BodyEdge>, Fragmentable {
  node: <T = BodyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BodyEdgeSubscription
  extends Promise<AsyncIterator<BodyEdge>>,
    Fragmentable {
  node: <T = BodySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDefect {
  count: Int;
}

export interface AggregateDefectPromise
  extends Promise<AggregateDefect>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDefectSubscription
  extends Promise<AsyncIterator<AggregateDefect>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HonorSubscriptionPayload {
  mutation: MutationType;
  node: Honor;
  updatedFields: String[];
  previousValues: HonorPreviousValues;
}

export interface HonorSubscriptionPayloadPromise
  extends Promise<HonorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HonorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HonorPreviousValuesPromise>() => T;
}

export interface HonorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HonorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HonorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HonorPreviousValuesSubscription>() => T;
}

export interface DefectConnection {
  pageInfo: PageInfo;
  edges: DefectEdge[];
}

export interface DefectConnectionPromise
  extends Promise<DefectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DefectEdge>>() => T;
  aggregate: <T = AggregateDefectPromise>() => T;
}

export interface DefectConnectionSubscription
  extends Promise<AsyncIterator<DefectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DefectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDefectSubscription>() => T;
}

export interface HonorPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface HonorPreviousValuesPromise
  extends Promise<HonorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface HonorPreviousValuesSubscription
  extends Promise<AsyncIterator<HonorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCrusade {
  count: Int;
}

export interface AggregateCrusadePromise
  extends Promise<AggregateCrusade>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCrusadeSubscription
  extends Promise<AsyncIterator<AggregateCrusade>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BodyConnection {
  pageInfo: PageInfo;
  edges: BodyEdge[];
}

export interface BodyConnectionPromise
  extends Promise<BodyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BodyEdge>>() => T;
  aggregate: <T = AggregateBodyPromise>() => T;
}

export interface BodyConnectionSubscription
  extends Promise<AsyncIterator<BodyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BodyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBodySubscription>() => T;
}

export interface CrusadeConnection {
  pageInfo: PageInfo;
  edges: CrusadeEdge[];
}

export interface CrusadeConnectionPromise
  extends Promise<CrusadeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CrusadeEdge>>() => T;
  aggregate: <T = AggregateCrusadePromise>() => T;
}

export interface CrusadeConnectionSubscription
  extends Promise<AsyncIterator<CrusadeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CrusadeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCrusadeSubscription>() => T;
}

export interface HopeSubscriptionPayload {
  mutation: MutationType;
  node: Hope;
  updatedFields: String[];
  previousValues: HopePreviousValues;
}

export interface HopeSubscriptionPayloadPromise
  extends Promise<HopeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HopePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HopePreviousValuesPromise>() => T;
}

export interface HopeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HopeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HopeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HopePreviousValuesSubscription>() => T;
}

export interface CrownEdge {
  node: Crown;
  cursor: String;
}

export interface CrownEdgePromise extends Promise<CrownEdge>, Fragmentable {
  node: <T = CrownPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CrownEdgeSubscription
  extends Promise<AsyncIterator<CrownEdge>>,
    Fragmentable {
  node: <T = CrownSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HopePreviousValues {
  id: ID_Output;
}

export interface HopePreviousValuesPromise
  extends Promise<HopePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface HopePreviousValuesSubscription
  extends Promise<AsyncIterator<HopePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateCross {
  count: Int;
}

export interface AggregateCrossPromise
  extends Promise<AggregateCross>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCrossSubscription
  extends Promise<AsyncIterator<AggregateCross>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Gut {
  id: ID_Output;
}

export interface GutPromise extends Promise<Gut>, Fragmentable {
  id: () => Promise<ID_Output>;
  anger: <T = FragmentableArray<Anger>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = FragmentableArray<Fear>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = FragmentableArray<Pride>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = FragmentableArray<SelfPity>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GutSubscription
  extends Promise<AsyncIterator<Gut>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  anger: <T = Promise<AsyncIterator<AngerSubscription>>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = Promise<AsyncIterator<FearSubscription>>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = Promise<AsyncIterator<PrideSubscription>>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = Promise<AsyncIterator<SelfPitySubscription>>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CrossConnection {
  pageInfo: PageInfo;
  edges: CrossEdge[];
}

export interface CrossConnectionPromise
  extends Promise<CrossConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CrossEdge>>() => T;
  aggregate: <T = AggregateCrossPromise>() => T;
}

export interface CrossConnectionSubscription
  extends Promise<AsyncIterator<CrossConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CrossEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCrossSubscription>() => T;
}

export interface ImpatienceSubscriptionPayload {
  mutation: MutationType;
  node: Impatience;
  updatedFields: String[];
  previousValues: ImpatiencePreviousValues;
}

export interface ImpatienceSubscriptionPayloadPromise
  extends Promise<ImpatienceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImpatiencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImpatiencePreviousValuesPromise>() => T;
}

export interface ImpatienceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImpatienceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImpatienceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImpatiencePreviousValuesSubscription>() => T;
}

export interface CourageEdge {
  node: Courage;
  cursor: String;
}

export interface CourageEdgePromise extends Promise<CourageEdge>, Fragmentable {
  node: <T = CouragePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourageEdgeSubscription
  extends Promise<AsyncIterator<CourageEdge>>,
    Fragmentable {
  node: <T = CourageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImpatiencePreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolveAt?: DateTimeOutput;
}

export interface ImpatiencePreviousValuesPromise
  extends Promise<ImpatiencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolveAt: () => Promise<DateTimeOutput>;
}

export interface ImpatiencePreviousValuesSubscription
  extends Promise<AsyncIterator<ImpatiencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateConstruct {
  count: Int;
}

export interface AggregateConstructPromise
  extends Promise<AggregateConstruct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConstructSubscription
  extends Promise<AsyncIterator<AggregateConstruct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Sternum {
  id: ID_Output;
}

export interface SternumPromise extends Promise<Sternum>, Fragmentable {
  id: () => Promise<ID_Output>;
  anger: <T = FragmentableArray<Anger>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = FragmentableArray<Fear>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = FragmentableArray<Pride>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = FragmentableArray<SelfPity>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SternumSubscription
  extends Promise<AsyncIterator<Sternum>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  anger: <T = Promise<AsyncIterator<AngerSubscription>>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = Promise<AsyncIterator<FearSubscription>>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = Promise<AsyncIterator<PrideSubscription>>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = Promise<AsyncIterator<SelfPitySubscription>>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ConstructConnection {
  pageInfo: PageInfo;
  edges: ConstructEdge[];
}

export interface ConstructConnectionPromise
  extends Promise<ConstructConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConstructEdge>>() => T;
  aggregate: <T = AggregateConstructPromise>() => T;
}

export interface ConstructConnectionSubscription
  extends Promise<AsyncIterator<ConstructConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConstructEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConstructSubscription>() => T;
}

export interface InfectionSubscriptionPayload {
  mutation: MutationType;
  node: Infection;
  updatedFields: String[];
  previousValues: InfectionPreviousValues;
}

export interface InfectionSubscriptionPayloadPromise
  extends Promise<InfectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InfectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InfectionPreviousValuesPromise>() => T;
}

export interface InfectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InfectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InfectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InfectionPreviousValuesSubscription>() => T;
}

export interface CongregantEdge {
  node: Congregant;
  cursor: String;
}

export interface CongregantEdgePromise
  extends Promise<CongregantEdge>,
    Fragmentable {
  node: <T = CongregantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CongregantEdgeSubscription
  extends Promise<AsyncIterator<CongregantEdge>>,
    Fragmentable {
  node: <T = CongregantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InfectionPreviousValues {
  id: ID_Output;
}

export interface InfectionPreviousValuesPromise
  extends Promise<InfectionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface InfectionPreviousValuesSubscription
  extends Promise<AsyncIterator<InfectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateConfusion {
  count: Int;
}

export interface AggregateConfusionPromise
  extends Promise<AggregateConfusion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConfusionSubscription
  extends Promise<AsyncIterator<AggregateConfusion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Heart {
  id: ID_Output;
}

export interface HeartPromise extends Promise<Heart>, Fragmentable {
  id: () => Promise<ID_Output>;
  anger: <T = FragmentableArray<Anger>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = FragmentableArray<Fear>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = FragmentableArray<Pride>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = FragmentableArray<SelfPity>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HeartSubscription
  extends Promise<AsyncIterator<Heart>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  anger: <T = Promise<AsyncIterator<AngerSubscription>>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = Promise<AsyncIterator<FearSubscription>>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = Promise<AsyncIterator<PrideSubscription>>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = Promise<AsyncIterator<SelfPitySubscription>>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ConfusionConnection {
  pageInfo: PageInfo;
  edges: ConfusionEdge[];
}

export interface ConfusionConnectionPromise
  extends Promise<ConfusionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConfusionEdge>>() => T;
  aggregate: <T = AggregateConfusionPromise>() => T;
}

export interface ConfusionConnectionSubscription
  extends Promise<AsyncIterator<ConfusionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConfusionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConfusionSubscription>() => T;
}

export interface InventorySubscriptionPayload {
  mutation: MutationType;
  node: Inventory;
  updatedFields: String[];
  previousValues: InventoryPreviousValues;
}

export interface InventorySubscriptionPayloadPromise
  extends Promise<InventorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryPreviousValuesPromise>() => T;
}

export interface InventorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryPreviousValuesSubscription>() => T;
}

export interface CompassionEdge {
  node: Compassion;
  cursor: String;
}

export interface CompassionEdgePromise
  extends Promise<CompassionEdge>,
    Fragmentable {
  node: <T = CompassionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompassionEdgeSubscription
  extends Promise<AsyncIterator<CompassionEdge>>,
    Fragmentable {
  node: <T = CompassionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InventoryPreviousValues {
  id: ID_Output;
}

export interface InventoryPreviousValuesPromise
  extends Promise<InventoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface InventoryPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateCharacters {
  count: Int;
}

export interface AggregateCharactersPromise
  extends Promise<AggregateCharacters>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharactersSubscription
  extends Promise<AsyncIterator<AggregateCharacters>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Vulnerability {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface VulnerabilityPromise
  extends Promise<Vulnerability>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface VulnerabilitySubscription
  extends Promise<AsyncIterator<Vulnerability>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CharactersConnection {
  pageInfo: PageInfo;
  edges: CharactersEdge[];
}

export interface CharactersConnectionPromise
  extends Promise<CharactersConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharactersEdge>>() => T;
  aggregate: <T = AggregateCharactersPromise>() => T;
}

export interface CharactersConnectionSubscription
  extends Promise<AsyncIterator<CharactersConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharactersEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharactersSubscription>() => T;
}

export interface IrritabilitySubscriptionPayload {
  mutation: MutationType;
  node: Irritability;
  updatedFields: String[];
  previousValues: IrritabilityPreviousValues;
}

export interface IrritabilitySubscriptionPayloadPromise
  extends Promise<IrritabilitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IrritabilityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IrritabilityPreviousValuesPromise>() => T;
}

export interface IrritabilitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IrritabilitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IrritabilitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IrritabilityPreviousValuesSubscription>() => T;
}

export interface Victim {
  id: ID_Output;
}

export interface VictimPromise extends Promise<Victim>, Fragmentable {
  id: () => Promise<ID_Output>;
  affliction: <T = FragmentableArray<Affliction>>(
    args?: {
      where?: AfflictionWhereInput;
      orderBy?: AfflictionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VictimSubscription
  extends Promise<AsyncIterator<Victim>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  affliction: <T = Promise<AsyncIterator<AfflictionSubscription>>>(
    args?: {
      where?: AfflictionWhereInput;
      orderBy?: AfflictionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface IrritabilityPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolveAt?: DateTimeOutput;
}

export interface IrritabilityPreviousValuesPromise
  extends Promise<IrritabilityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolveAt: () => Promise<DateTimeOutput>;
}

export interface IrritabilityPreviousValuesSubscription
  extends Promise<AsyncIterator<IrritabilityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Confusion {
  id: ID_Output;
}

export interface ConfusionPromise extends Promise<Confusion>, Fragmentable {
  id: () => Promise<ID_Output>;
  armor: <T = FragmentableArray<Armor>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ConfusionSubscription
  extends Promise<AsyncIterator<Confusion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  armor: <T = Promise<AsyncIterator<ArmorSubscription>>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Soul {
  id: ID_Output;
}

export interface SoulPromise extends Promise<Soul>, Fragmentable {
  id: () => Promise<ID_Output>;
  vulnerability: <T = FragmentableArray<Vulnerability>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = FragmentableArray<Acceptance>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SoulSubscription
  extends Promise<AsyncIterator<Soul>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  vulnerability: <T = Promise<AsyncIterator<VulnerabilitySubscription>>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = Promise<AsyncIterator<AcceptanceSubscription>>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Sarcasm {
  id: ID_Output;
}

export interface SarcasmPromise extends Promise<Sarcasm>, Fragmentable {
  id: () => Promise<ID_Output>;
  armor: <T = FragmentableArray<Armor>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SarcasmSubscription
  extends Promise<AsyncIterator<Sarcasm>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  armor: <T = Promise<AsyncIterator<ArmorSubscription>>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface JoySubscriptionPayload {
  mutation: MutationType;
  node: Joy;
  updatedFields: String[];
  previousValues: JoyPreviousValues;
}

export interface JoySubscriptionPayloadPromise
  extends Promise<JoySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = JoyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = JoyPreviousValuesPromise>() => T;
}

export interface JoySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<JoySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = JoySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = JoyPreviousValuesSubscription>() => T;
}

export interface WishEdge {
  node: Wish;
  cursor: String;
}

export interface WishEdgePromise extends Promise<WishEdge>, Fragmentable {
  node: <T = WishPromise>() => T;
  cursor: () => Promise<String>;
}

export interface WishEdgeSubscription
  extends Promise<AsyncIterator<WishEdge>>,
    Fragmentable {
  node: <T = WishSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface JoyPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolveAt?: DateTimeOutput;
}

export interface JoyPreviousValuesPromise
  extends Promise<JoyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolveAt: () => Promise<DateTimeOutput>;
}

export interface JoyPreviousValuesSubscription
  extends Promise<AsyncIterator<JoyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface WallConnection {
  pageInfo: PageInfo;
  edges: WallEdge[];
}

export interface WallConnectionPromise
  extends Promise<WallConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<WallEdge>>() => T;
  aggregate: <T = AggregateWallPromise>() => T;
}

export interface WallConnectionSubscription
  extends Promise<AsyncIterator<WallConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<WallEdgeSubscription>>>() => T;
  aggregate: <T = AggregateWallSubscription>() => T;
}

export interface Mouth {
  id: ID_Output;
}

export interface MouthPromise extends Promise<Mouth>, Fragmentable {
  id: () => Promise<ID_Output>;
  anger: <T = FragmentableArray<Anger>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = FragmentableArray<Fear>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = FragmentableArray<Pride>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = FragmentableArray<SelfPity>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface MouthSubscription
  extends Promise<AsyncIterator<Mouth>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  anger: <T = Promise<AsyncIterator<AngerSubscription>>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = Promise<AsyncIterator<FearSubscription>>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = Promise<AsyncIterator<PrideSubscription>>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = Promise<AsyncIterator<SelfPitySubscription>>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateVolunteer {
  count: Int;
}

export interface AggregateVolunteerPromise
  extends Promise<AggregateVolunteer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVolunteerSubscription
  extends Promise<AsyncIterator<AggregateVolunteer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoveSubscriptionPayload {
  mutation: MutationType;
  node: Love;
  updatedFields: String[];
  previousValues: LovePreviousValues;
}

export interface LoveSubscriptionPayloadPromise
  extends Promise<LoveSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LovePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LovePreviousValuesPromise>() => T;
}

export interface LoveSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoveSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoveSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LovePreviousValuesSubscription>() => T;
}

export interface VirtueEdge {
  node: Virtue;
  cursor: String;
}

export interface VirtueEdgePromise extends Promise<VirtueEdge>, Fragmentable {
  node: <T = VirtuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VirtueEdgeSubscription
  extends Promise<AsyncIterator<VirtueEdge>>,
    Fragmentable {
  node: <T = VirtueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LovePreviousValues {
  id: ID_Output;
}

export interface LovePreviousValuesPromise
  extends Promise<LovePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface LovePreviousValuesSubscription
  extends Promise<AsyncIterator<LovePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface VictimConnection {
  pageInfo: PageInfo;
  edges: VictimEdge[];
}

export interface VictimConnectionPromise
  extends Promise<VictimConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VictimEdge>>() => T;
  aggregate: <T = AggregateVictimPromise>() => T;
}

export interface VictimConnectionSubscription
  extends Promise<AsyncIterator<VictimConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VictimEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVictimSubscription>() => T;
}

export interface Face {
  id: ID_Output;
}

export interface FacePromise extends Promise<Face>, Fragmentable {
  id: () => Promise<ID_Output>;
  anger: <T = FragmentableArray<Anger>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = FragmentableArray<Fear>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = FragmentableArray<Pride>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = FragmentableArray<SelfPity>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface FaceSubscription
  extends Promise<AsyncIterator<Face>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  anger: <T = Promise<AsyncIterator<AngerSubscription>>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = Promise<AsyncIterator<FearSubscription>>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = Promise<AsyncIterator<PrideSubscription>>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = Promise<AsyncIterator<SelfPitySubscription>>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateTrauma {
  count: Int;
}

export interface AggregateTraumaPromise
  extends Promise<AggregateTrauma>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTraumaSubscription
  extends Promise<AsyncIterator<AggregateTrauma>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoyaltySubscriptionPayload {
  mutation: MutationType;
  node: Loyalty;
  updatedFields: String[];
  previousValues: LoyaltyPreviousValues;
}

export interface LoyaltySubscriptionPayloadPromise
  extends Promise<LoyaltySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoyaltyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoyaltyPreviousValuesPromise>() => T;
}

export interface LoyaltySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoyaltySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoyaltySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoyaltyPreviousValuesSubscription>() => T;
}

export interface ToxicityEdge {
  node: Toxicity;
  cursor: String;
}

export interface ToxicityEdgePromise
  extends Promise<ToxicityEdge>,
    Fragmentable {
  node: <T = ToxicityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ToxicityEdgeSubscription
  extends Promise<AsyncIterator<ToxicityEdge>>,
    Fragmentable {
  node: <T = ToxicitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LoyaltyPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface LoyaltyPreviousValuesPromise
  extends Promise<LoyaltyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface LoyaltyPreviousValuesSubscription
  extends Promise<AsyncIterator<LoyaltyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TowerConnection {
  pageInfo: PageInfo;
  edges: TowerEdge[];
}

export interface TowerConnectionPromise
  extends Promise<TowerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TowerEdge>>() => T;
  aggregate: <T = AggregateTowerPromise>() => T;
}

export interface TowerConnectionSubscription
  extends Promise<AsyncIterator<TowerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TowerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTowerSubscription>() => T;
}

export interface SelfPity {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SelfPityPromise extends Promise<SelfPity>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SelfPitySubscription
  extends Promise<AsyncIterator<SelfPity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSummoner {
  count: Int;
}

export interface AggregateSummonerPromise
  extends Promise<AggregateSummoner>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSummonerSubscription
  extends Promise<AsyncIterator<AggregateSummoner>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MartyrSubscriptionPayload {
  mutation: MutationType;
  node: Martyr;
  updatedFields: String[];
  previousValues: MartyrPreviousValues;
}

export interface MartyrSubscriptionPayloadPromise
  extends Promise<MartyrSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MartyrPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MartyrPreviousValuesPromise>() => T;
}

export interface MartyrSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MartyrSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MartyrSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MartyrPreviousValuesSubscription>() => T;
}

export interface SufferingEdge {
  node: Suffering;
  cursor: String;
}

export interface SufferingEdgePromise
  extends Promise<SufferingEdge>,
    Fragmentable {
  node: <T = SufferingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SufferingEdgeSubscription
  extends Promise<AsyncIterator<SufferingEdge>>,
    Fragmentable {
  node: <T = SufferingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MartyrPreviousValues {
  id: ID_Output;
}

export interface MartyrPreviousValuesPromise
  extends Promise<MartyrPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface MartyrPreviousValuesSubscription
  extends Promise<AsyncIterator<MartyrPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface StrengthConnection {
  pageInfo: PageInfo;
  edges: StrengthEdge[];
}

export interface StrengthConnectionPromise
  extends Promise<StrengthConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StrengthEdge>>() => T;
  aggregate: <T = AggregateStrengthPromise>() => T;
}

export interface StrengthConnectionSubscription
  extends Promise<AsyncIterator<StrengthConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StrengthEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStrengthSubscription>() => T;
}

export interface Pride {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface PridePromise extends Promise<Pride>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface PrideSubscription
  extends Promise<AsyncIterator<Pride>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSternum {
  count: Int;
}

export interface AggregateSternumPromise
  extends Promise<AggregateSternum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSternumSubscription
  extends Promise<AsyncIterator<AggregateSternum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MindSubscriptionPayload {
  mutation: MutationType;
  node: Mind;
  updatedFields: String[];
  previousValues: MindPreviousValues;
}

export interface MindSubscriptionPayloadPromise
  extends Promise<MindSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MindPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MindPreviousValuesPromise>() => T;
}

export interface MindSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MindSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MindSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MindPreviousValuesSubscription>() => T;
}

export interface SoulEdge {
  node: Soul;
  cursor: String;
}

export interface SoulEdgePromise extends Promise<SoulEdge>, Fragmentable {
  node: <T = SoulPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SoulEdgeSubscription
  extends Promise<AsyncIterator<SoulEdge>>,
    Fragmentable {
  node: <T = SoulSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface MindPreviousValues {
  id: ID_Output;
}

export interface MindPreviousValuesPromise
  extends Promise<MindPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface MindPreviousValuesSubscription
  extends Promise<AsyncIterator<MindPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SmithConnection {
  pageInfo: PageInfo;
  edges: SmithEdge[];
}

export interface SmithConnectionPromise
  extends Promise<SmithConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SmithEdge>>() => T;
  aggregate: <T = AggregateSmithPromise>() => T;
}

export interface SmithConnectionSubscription
  extends Promise<AsyncIterator<SmithConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SmithEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSmithSubscription>() => T;
}

export interface Fear {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface FearPromise extends Promise<Fear>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface FearSubscription
  extends Promise<AsyncIterator<Fear>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Skin {
  id: ID_Output;
}

export interface SkinPromise extends Promise<Skin>, Fragmentable {
  id: () => Promise<ID_Output>;
  anger: <T = FragmentableArray<Anger>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = FragmentableArray<Fear>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = FragmentableArray<Pride>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = FragmentableArray<SelfPity>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SkinSubscription
  extends Promise<AsyncIterator<Skin>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  anger: <T = Promise<AsyncIterator<AngerSubscription>>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = Promise<AsyncIterator<FearSubscription>>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = Promise<AsyncIterator<PrideSubscription>>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = Promise<AsyncIterator<SelfPitySubscription>>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface MouthSubscriptionPayload {
  mutation: MutationType;
  node: Mouth;
  updatedFields: String[];
  previousValues: MouthPreviousValues;
}

export interface MouthSubscriptionPayloadPromise
  extends Promise<MouthSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MouthPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MouthPreviousValuesPromise>() => T;
}

export interface MouthSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MouthSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MouthSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MouthPreviousValuesSubscription>() => T;
}

export interface AggregateShield {
  count: Int;
}

export interface AggregateShieldPromise
  extends Promise<AggregateShield>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShieldSubscription
  extends Promise<AsyncIterator<AggregateShield>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MouthPreviousValues {
  id: ID_Output;
}

export interface MouthPreviousValuesPromise
  extends Promise<MouthPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface MouthPreviousValuesSubscription
  extends Promise<AsyncIterator<MouthPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ServiceEdge {
  node: Service;
  cursor: String;
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Brain {
  id: ID_Output;
}

export interface BrainPromise extends Promise<Brain>, Fragmentable {
  id: () => Promise<ID_Output>;
  anger: <T = FragmentableArray<Anger>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = FragmentableArray<Fear>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = FragmentableArray<Pride>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = FragmentableArray<SelfPity>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BrainSubscription
  extends Promise<AsyncIterator<Brain>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  anger: <T = Promise<AsyncIterator<AngerSubscription>>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = Promise<AsyncIterator<FearSubscription>>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = Promise<AsyncIterator<PrideSubscription>>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = Promise<AsyncIterator<SelfPitySubscription>>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SelfPityConnection {
  pageInfo: PageInfo;
  edges: SelfPityEdge[];
}

export interface SelfPityConnectionPromise
  extends Promise<SelfPityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SelfPityEdge>>() => T;
  aggregate: <T = AggregateSelfPityPromise>() => T;
}

export interface SelfPityConnectionSubscription
  extends Promise<AsyncIterator<SelfPityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SelfPityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSelfPitySubscription>() => T;
}

export interface NailSubscriptionPayload {
  mutation: MutationType;
  node: Nail;
  updatedFields: String[];
  previousValues: NailPreviousValues;
}

export interface NailSubscriptionPayloadPromise
  extends Promise<NailSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NailPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NailPreviousValuesPromise>() => T;
}

export interface NailSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NailSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NailSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NailPreviousValuesSubscription>() => T;
}

export interface AggregateSeeker {
  count: Int;
}

export interface AggregateSeekerPromise
  extends Promise<AggregateSeeker>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSeekerSubscription
  extends Promise<AsyncIterator<AggregateSeeker>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NailPreviousValues {
  id: ID_Output;
}

export interface NailPreviousValuesPromise
  extends Promise<NailPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface NailPreviousValuesSubscription
  extends Promise<AsyncIterator<NailPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ScarEdge {
  node: Scar;
  cursor: String;
}

export interface ScarEdgePromise extends Promise<ScarEdge>, Fragmentable {
  node: <T = ScarPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ScarEdgeSubscription
  extends Promise<AsyncIterator<ScarEdge>>,
    Fragmentable {
  node: <T = ScarSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Body {
  id: ID_Output;
}

export interface BodyPromise extends Promise<Body>, Fragmentable {
  id: () => Promise<ID_Output>;
  brain: <T = FragmentableArray<Brain>>(
    args?: {
      where?: BrainWhereInput;
      orderBy?: BrainOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  face: <T = FragmentableArray<Face>>(
    args?: {
      where?: FaceWhereInput;
      orderBy?: FaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  mouth: <T = FragmentableArray<Mouth>>(
    args?: {
      where?: MouthWhereInput;
      orderBy?: MouthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  soul: <T = FragmentableArray<Soul>>(
    args?: {
      where?: SoulWhereInput;
      orderBy?: SoulOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  heart: <T = FragmentableArray<Heart>>(
    args?: {
      where?: HeartWhereInput;
      orderBy?: HeartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sternum: <T = FragmentableArray<Sternum>>(
    args?: {
      where?: SternumWhereInput;
      orderBy?: SternumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  gut: <T = FragmentableArray<Gut>>(
    args?: {
      where?: GutWhereInput;
      orderBy?: GutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BodySubscription
  extends Promise<AsyncIterator<Body>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  brain: <T = Promise<AsyncIterator<BrainSubscription>>>(
    args?: {
      where?: BrainWhereInput;
      orderBy?: BrainOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  face: <T = Promise<AsyncIterator<FaceSubscription>>>(
    args?: {
      where?: FaceWhereInput;
      orderBy?: FaceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  mouth: <T = Promise<AsyncIterator<MouthSubscription>>>(
    args?: {
      where?: MouthWhereInput;
      orderBy?: MouthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  soul: <T = Promise<AsyncIterator<SoulSubscription>>>(
    args?: {
      where?: SoulWhereInput;
      orderBy?: SoulOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  heart: <T = Promise<AsyncIterator<HeartSubscription>>>(
    args?: {
      where?: HeartWhereInput;
      orderBy?: HeartOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sternum: <T = Promise<AsyncIterator<SternumSubscription>>>(
    args?: {
      where?: SternumWhereInput;
      orderBy?: SternumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  gut: <T = Promise<AsyncIterator<GutSubscription>>>(
    args?: {
      where?: GutWhereInput;
      orderBy?: GutOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SarcasmConnection {
  pageInfo: PageInfo;
  edges: SarcasmEdge[];
}

export interface SarcasmConnectionPromise
  extends Promise<SarcasmConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SarcasmEdge>>() => T;
  aggregate: <T = AggregateSarcasmPromise>() => T;
}

export interface SarcasmConnectionSubscription
  extends Promise<AsyncIterator<SarcasmConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SarcasmEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSarcasmSubscription>() => T;
}

export interface NightmareSubscriptionPayload {
  mutation: MutationType;
  node: Nightmare;
  updatedFields: String[];
  previousValues: NightmarePreviousValues;
}

export interface NightmareSubscriptionPayloadPromise
  extends Promise<NightmareSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NightmarePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NightmarePreviousValuesPromise>() => T;
}

export interface NightmareSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NightmareSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NightmareSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NightmarePreviousValuesSubscription>() => T;
}

export interface AggregateSacrifice {
  count: Int;
}

export interface AggregateSacrificePromise
  extends Promise<AggregateSacrifice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSacrificeSubscription
  extends Promise<AsyncIterator<AggregateSacrifice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NightmarePreviousValues {
  id: ID_Output;
}

export interface NightmarePreviousValuesPromise
  extends Promise<NightmarePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface NightmarePreviousValuesSubscription
  extends Promise<AsyncIterator<NightmarePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ResentmentEdge {
  node: Resentment;
  cursor: String;
}

export interface ResentmentEdgePromise
  extends Promise<ResentmentEdge>,
    Fragmentable {
  node: <T = ResentmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ResentmentEdgeSubscription
  extends Promise<AsyncIterator<ResentmentEdge>>,
    Fragmentable {
  node: <T = ResentmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateArmor {
  count: Int;
}

export interface AggregateArmorPromise
  extends Promise<AggregateArmor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArmorSubscription
  extends Promise<AsyncIterator<AggregateArmor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProcessConnection {
  pageInfo: PageInfo;
  edges: ProcessEdge[];
}

export interface ProcessConnectionPromise
  extends Promise<ProcessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProcessEdge>>() => T;
  aggregate: <T = AggregateProcessPromise>() => T;
}

export interface ProcessConnectionSubscription
  extends Promise<AsyncIterator<ProcessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProcessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProcessSubscription>() => T;
}

export interface OathSubscriptionPayload {
  mutation: MutationType;
  node: Oath;
  updatedFields: String[];
  previousValues: OathPreviousValues;
}

export interface OathSubscriptionPayloadPromise
  extends Promise<OathSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OathPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OathPreviousValuesPromise>() => T;
}

export interface OathSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OathSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OathSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OathPreviousValuesSubscription>() => T;
}

export interface AggregatePrayer {
  count: Int;
}

export interface AggregatePrayerPromise
  extends Promise<AggregatePrayer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePrayerSubscription
  extends Promise<AsyncIterator<AggregatePrayer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OathPreviousValues {
  id: ID_Output;
}

export interface OathPreviousValuesPromise
  extends Promise<OathPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface OathPreviousValuesSubscription
  extends Promise<AsyncIterator<OathPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface PledgeEdge {
  node: Pledge;
  cursor: String;
}

export interface PledgeEdgePromise extends Promise<PledgeEdge>, Fragmentable {
  node: <T = PledgePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PledgeEdgeSubscription
  extends Promise<AsyncIterator<PledgeEdge>>,
    Fragmentable {
  node: <T = PledgeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ArmorEdge {
  node: Armor;
  cursor: String;
}

export interface ArmorEdgePromise extends Promise<ArmorEdge>, Fragmentable {
  node: <T = ArmorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArmorEdgeSubscription
  extends Promise<AsyncIterator<ArmorEdge>>,
    Fragmentable {
  node: <T = ArmorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PathConnection {
  pageInfo: PageInfo;
  edges: PathEdge[];
}

export interface PathConnectionPromise
  extends Promise<PathConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PathEdge>>() => T;
  aggregate: <T = AggregatePathPromise>() => T;
}

export interface PathConnectionSubscription
  extends Promise<AsyncIterator<PathConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PathEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePathSubscription>() => T;
}

export interface ObsessionSubscriptionPayload {
  mutation: MutationType;
  node: Obsession;
  updatedFields: String[];
  previousValues: ObsessionPreviousValues;
}

export interface ObsessionSubscriptionPayloadPromise
  extends Promise<ObsessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ObsessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ObsessionPreviousValuesPromise>() => T;
}

export interface ObsessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ObsessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ObsessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ObsessionPreviousValuesSubscription>() => T;
}

export interface AggregateObsession {
  count: Int;
}

export interface AggregateObsessionPromise
  extends Promise<AggregateObsession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateObsessionSubscription
  extends Promise<AsyncIterator<AggregateObsession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ObsessionPreviousValues {
  id: ID_Output;
}

export interface ObsessionPreviousValuesPromise
  extends Promise<ObsessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ObsessionPreviousValuesSubscription
  extends Promise<AsyncIterator<ObsessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface OathEdge {
  node: Oath;
  cursor: String;
}

export interface OathEdgePromise extends Promise<OathEdge>, Fragmentable {
  node: <T = OathPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OathEdgeSubscription
  extends Promise<AsyncIterator<OathEdge>>,
    Fragmentable {
  node: <T = OathSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ArmorConnection {
  pageInfo: PageInfo;
  edges: ArmorEdge[];
}

export interface ArmorConnectionPromise
  extends Promise<ArmorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArmorEdge>>() => T;
  aggregate: <T = AggregateArmorPromise>() => T;
}

export interface ArmorConnectionSubscription
  extends Promise<AsyncIterator<ArmorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArmorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArmorSubscription>() => T;
}

export interface NightmareConnection {
  pageInfo: PageInfo;
  edges: NightmareEdge[];
}

export interface NightmareConnectionPromise
  extends Promise<NightmareConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NightmareEdge>>() => T;
  aggregate: <T = AggregateNightmarePromise>() => T;
}

export interface NightmareConnectionSubscription
  extends Promise<AsyncIterator<NightmareConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NightmareEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNightmareSubscription>() => T;
}

export interface PaladinSubscriptionPayload {
  mutation: MutationType;
  node: Paladin;
  updatedFields: String[];
  previousValues: PaladinPreviousValues;
}

export interface PaladinSubscriptionPayloadPromise
  extends Promise<PaladinSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaladinPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaladinPreviousValuesPromise>() => T;
}

export interface PaladinSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaladinSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaladinSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaladinPreviousValuesSubscription>() => T;
}

export interface AggregateMouth {
  count: Int;
}

export interface AggregateMouthPromise
  extends Promise<AggregateMouth>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMouthSubscription
  extends Promise<AsyncIterator<AggregateMouth>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaladinPreviousValues {
  id: ID_Output;
}

export interface PaladinPreviousValuesPromise
  extends Promise<PaladinPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PaladinPreviousValuesSubscription
  extends Promise<AsyncIterator<PaladinPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface MindEdge {
  node: Mind;
  cursor: String;
}

export interface MindEdgePromise extends Promise<MindEdge>, Fragmentable {
  node: <T = MindPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MindEdgeSubscription
  extends Promise<AsyncIterator<MindEdge>>,
    Fragmentable {
  node: <T = MindSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Armor {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ArmorPromise extends Promise<Armor>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ArmorSubscription
  extends Promise<AsyncIterator<Armor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateLove {
  count: Int;
}

export interface AggregateLovePromise
  extends Promise<AggregateLove>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoveSubscription
  extends Promise<AsyncIterator<AggregateLove>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PathSubscriptionPayload {
  mutation: MutationType;
  node: Path;
  updatedFields: String[];
  previousValues: PathPreviousValues;
}

export interface PathSubscriptionPayloadPromise
  extends Promise<PathSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PathPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PathPreviousValuesPromise>() => T;
}

export interface PathSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PathSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PathSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PathPreviousValuesSubscription>() => T;
}

export interface AggregateJoy {
  count: Int;
}

export interface AggregateJoyPromise
  extends Promise<AggregateJoy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateJoySubscription
  extends Promise<AsyncIterator<AggregateJoy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PathPreviousValues {
  id: ID_Output;
}

export interface PathPreviousValuesPromise
  extends Promise<PathPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PathPreviousValuesSubscription
  extends Promise<AsyncIterator<PathPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface IrritabilityEdge {
  node: Irritability;
  cursor: String;
}

export interface IrritabilityEdgePromise
  extends Promise<IrritabilityEdge>,
    Fragmentable {
  node: <T = IrritabilityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IrritabilityEdgeSubscription
  extends Promise<AsyncIterator<IrritabilityEdge>>,
    Fragmentable {
  node: <T = IrritabilitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAnger {
  count: Int;
}

export interface AggregateAngerPromise
  extends Promise<AggregateAnger>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAngerSubscription
  extends Promise<AsyncIterator<AggregateAnger>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InventoryConnection {
  pageInfo: PageInfo;
  edges: InventoryEdge[];
}

export interface InventoryConnectionPromise
  extends Promise<InventoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryEdge>>() => T;
  aggregate: <T = AggregateInventoryPromise>() => T;
}

export interface InventoryConnectionSubscription
  extends Promise<AsyncIterator<InventoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventorySubscription>() => T;
}

export interface PledgeSubscriptionPayload {
  mutation: MutationType;
  node: Pledge;
  updatedFields: String[];
  previousValues: PledgePreviousValues;
}

export interface PledgeSubscriptionPayloadPromise
  extends Promise<PledgeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PledgePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PledgePreviousValuesPromise>() => T;
}

export interface PledgeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PledgeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PledgeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PledgePreviousValuesSubscription>() => T;
}

export interface InfectionConnection {
  pageInfo: PageInfo;
  edges: InfectionEdge[];
}

export interface InfectionConnectionPromise
  extends Promise<InfectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InfectionEdge>>() => T;
  aggregate: <T = AggregateInfectionPromise>() => T;
}

export interface InfectionConnectionSubscription
  extends Promise<AsyncIterator<InfectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InfectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInfectionSubscription>() => T;
}

export interface PledgePreviousValues {
  id: ID_Output;
}

export interface PledgePreviousValuesPromise
  extends Promise<PledgePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PledgePreviousValuesSubscription
  extends Promise<AsyncIterator<PledgePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateHope {
  count: Int;
}

export interface AggregateHopePromise
  extends Promise<AggregateHope>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHopeSubscription
  extends Promise<AsyncIterator<AggregateHope>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AngerEdge {
  node: Anger;
  cursor: String;
}

export interface AngerEdgePromise extends Promise<AngerEdge>, Fragmentable {
  node: <T = AngerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AngerEdgeSubscription
  extends Promise<AsyncIterator<AngerEdge>>,
    Fragmentable {
  node: <T = AngerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HonorEdge {
  node: Honor;
  cursor: String;
}

export interface HonorEdgePromise extends Promise<HonorEdge>, Fragmentable {
  node: <T = HonorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HonorEdgeSubscription
  extends Promise<AsyncIterator<HonorEdge>>,
    Fragmentable {
  node: <T = HonorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PrayerSubscriptionPayload {
  mutation: MutationType;
  node: Prayer;
  updatedFields: String[];
  previousValues: PrayerPreviousValues;
}

export interface PrayerSubscriptionPayloadPromise
  extends Promise<PrayerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PrayerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PrayerPreviousValuesPromise>() => T;
}

export interface PrayerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PrayerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PrayerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PrayerPreviousValuesSubscription>() => T;
}

export interface HigherPowerConnection {
  pageInfo: PageInfo;
  edges: HigherPowerEdge[];
}

export interface HigherPowerConnectionPromise
  extends Promise<HigherPowerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HigherPowerEdge>>() => T;
  aggregate: <T = AggregateHigherPowerPromise>() => T;
}

export interface HigherPowerConnectionSubscription
  extends Promise<AsyncIterator<HigherPowerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HigherPowerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHigherPowerSubscription>() => T;
}

export interface PrayerPreviousValues {
  id: ID_Output;
}

export interface PrayerPreviousValuesPromise
  extends Promise<PrayerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface PrayerPreviousValuesSubscription
  extends Promise<AsyncIterator<PrayerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Obsession {
  id: ID_Output;
}

export interface ObsessionPromise extends Promise<Obsession>, Fragmentable {
  id: () => Promise<ID_Output>;
  suffering: <T = FragmentableArray<Suffering>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loyalty: <T = FragmentableArray<Loyalty>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = FragmentableArray<Honor>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vulnerability: <T = FragmentableArray<Vulnerability>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ObsessionSubscription
  extends Promise<AsyncIterator<Obsession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  suffering: <T = Promise<AsyncIterator<SufferingSubscription>>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loyalty: <T = Promise<AsyncIterator<LoyaltySubscription>>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = Promise<AsyncIterator<HonorSubscription>>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vulnerability: <T = Promise<AsyncIterator<VulnerabilitySubscription>>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AngerConnection {
  pageInfo: PageInfo;
  edges: AngerEdge[];
}

export interface AngerConnectionPromise
  extends Promise<AngerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AngerEdge>>() => T;
  aggregate: <T = AggregateAngerPromise>() => T;
}

export interface AngerConnectionSubscription
  extends Promise<AsyncIterator<AngerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AngerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAngerSubscription>() => T;
}

export interface Prayer {
  id: ID_Output;
}

export interface PrayerPromise extends Promise<Prayer>, Fragmentable {
  id: () => Promise<ID_Output>;
  process: <T = ProcessPromise>() => T;
  path: <T = PathPromise>() => T;
}

export interface PrayerSubscription
  extends Promise<AsyncIterator<Prayer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  process: <T = ProcessSubscription>() => T;
  path: <T = PathSubscription>() => T;
}

export interface PrideSubscriptionPayload {
  mutation: MutationType;
  node: Pride;
  updatedFields: String[];
  previousValues: PridePreviousValues;
}

export interface PrideSubscriptionPayloadPromise
  extends Promise<PrideSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PridePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PridePreviousValuesPromise>() => T;
}

export interface PrideSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PrideSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PrideSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PridePreviousValuesSubscription>() => T;
}

export interface HeartConnection {
  pageInfo: PageInfo;
  edges: HeartEdge[];
}

export interface HeartConnectionPromise
  extends Promise<HeartConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HeartEdge>>() => T;
  aggregate: <T = AggregateHeartPromise>() => T;
}

export interface HeartConnectionSubscription
  extends Promise<AsyncIterator<HeartConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HeartEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHeartSubscription>() => T;
}

export interface PridePreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface PridePreviousValuesPromise
  extends Promise<PridePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface PridePreviousValuesSubscription
  extends Promise<AsyncIterator<PridePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Has {
  id: ID_Output;
  defect: Boolean;
  discontent: Boolean;
  resentment: Boolean;
  obsession: Boolean;
  experience: Boolean;
  strength: Boolean;
  hope: Boolean;
  acceptance: Boolean;
  anger: Boolean;
  armor: Boolean;
  boundary: Boolean;
  compassion: Boolean;
  courage: Boolean;
  fear: Boolean;
  fun: Boolean;
  gratitude: Boolean;
  irritability: Boolean;
  impatience: Boolean;
  joy: Boolean;
  pride: Boolean;
  salvaltion: Boolean;
  selfPity: Boolean;
  suffering: Boolean;
  toxicity: Boolean;
  trauma: Boolean;
  vulnerability: Boolean;
}

export interface HasPromise extends Promise<Has>, Fragmentable {
  id: () => Promise<ID_Output>;
  defect: () => Promise<Boolean>;
  discontent: () => Promise<Boolean>;
  resentment: () => Promise<Boolean>;
  obsession: () => Promise<Boolean>;
  experience: () => Promise<Boolean>;
  strength: () => Promise<Boolean>;
  hope: () => Promise<Boolean>;
  acceptance: () => Promise<Boolean>;
  anger: () => Promise<Boolean>;
  armor: () => Promise<Boolean>;
  boundary: () => Promise<Boolean>;
  compassion: () => Promise<Boolean>;
  courage: () => Promise<Boolean>;
  fear: () => Promise<Boolean>;
  fun: () => Promise<Boolean>;
  gratitude: () => Promise<Boolean>;
  irritability: () => Promise<Boolean>;
  impatience: () => Promise<Boolean>;
  joy: () => Promise<Boolean>;
  pride: () => Promise<Boolean>;
  salvaltion: () => Promise<Boolean>;
  selfPity: () => Promise<Boolean>;
  suffering: () => Promise<Boolean>;
  toxicity: () => Promise<Boolean>;
  trauma: () => Promise<Boolean>;
  vulnerability: () => Promise<Boolean>;
}

export interface HasSubscription
  extends Promise<AsyncIterator<Has>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  defect: () => Promise<AsyncIterator<Boolean>>;
  discontent: () => Promise<AsyncIterator<Boolean>>;
  resentment: () => Promise<AsyncIterator<Boolean>>;
  obsession: () => Promise<AsyncIterator<Boolean>>;
  experience: () => Promise<AsyncIterator<Boolean>>;
  strength: () => Promise<AsyncIterator<Boolean>>;
  hope: () => Promise<AsyncIterator<Boolean>>;
  acceptance: () => Promise<AsyncIterator<Boolean>>;
  anger: () => Promise<AsyncIterator<Boolean>>;
  armor: () => Promise<AsyncIterator<Boolean>>;
  boundary: () => Promise<AsyncIterator<Boolean>>;
  compassion: () => Promise<AsyncIterator<Boolean>>;
  courage: () => Promise<AsyncIterator<Boolean>>;
  fear: () => Promise<AsyncIterator<Boolean>>;
  fun: () => Promise<AsyncIterator<Boolean>>;
  gratitude: () => Promise<AsyncIterator<Boolean>>;
  irritability: () => Promise<AsyncIterator<Boolean>>;
  impatience: () => Promise<AsyncIterator<Boolean>>;
  joy: () => Promise<AsyncIterator<Boolean>>;
  pride: () => Promise<AsyncIterator<Boolean>>;
  salvaltion: () => Promise<AsyncIterator<Boolean>>;
  selfPity: () => Promise<AsyncIterator<Boolean>>;
  suffering: () => Promise<AsyncIterator<Boolean>>;
  toxicity: () => Promise<AsyncIterator<Boolean>>;
  trauma: () => Promise<AsyncIterator<Boolean>>;
  vulnerability: () => Promise<AsyncIterator<Boolean>>;
}

export interface Anger {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface AngerPromise extends Promise<Anger>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface AngerSubscription
  extends Promise<AsyncIterator<Anger>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateGuardian {
  count: Int;
}

export interface AggregateGuardianPromise
  extends Promise<AggregateGuardian>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGuardianSubscription
  extends Promise<AsyncIterator<AggregateGuardian>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProcessSubscriptionPayload {
  mutation: MutationType;
  node: Process;
  updatedFields: String[];
  previousValues: ProcessPreviousValues;
}

export interface ProcessSubscriptionPayloadPromise
  extends Promise<ProcessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProcessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProcessPreviousValuesPromise>() => T;
}

export interface ProcessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProcessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProcessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProcessPreviousValuesSubscription>() => T;
}

export interface GratitudeEdge {
  node: Gratitude;
  cursor: String;
}

export interface GratitudeEdgePromise
  extends Promise<GratitudeEdge>,
    Fragmentable {
  node: <T = GratitudePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GratitudeEdgeSubscription
  extends Promise<AsyncIterator<GratitudeEdge>>,
    Fragmentable {
  node: <T = GratitudeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProcessPreviousValues {
  id: ID_Output;
}

export interface ProcessPreviousValuesPromise
  extends Promise<ProcessPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ProcessPreviousValuesSubscription
  extends Promise<AsyncIterator<ProcessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface GenieConnection {
  pageInfo: PageInfo;
  edges: GenieEdge[];
}

export interface GenieConnectionPromise
  extends Promise<GenieConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GenieEdge>>() => T;
  aggregate: <T = AggregateGeniePromise>() => T;
}

export interface GenieConnectionSubscription
  extends Promise<AsyncIterator<GenieConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GenieEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGenieSubscription>() => T;
}

export interface AggregateAffliction {
  count: Int;
}

export interface AggregateAfflictionPromise
  extends Promise<AggregateAffliction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAfflictionSubscription
  extends Promise<AsyncIterator<AggregateAffliction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateGash {
  count: Int;
}

export interface AggregateGashPromise
  extends Promise<AggregateGash>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGashSubscription
  extends Promise<AsyncIterator<AggregateGash>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ResentmentSubscriptionPayload {
  mutation: MutationType;
  node: Resentment;
  updatedFields: String[];
  previousValues: ResentmentPreviousValues;
}

export interface ResentmentSubscriptionPayloadPromise
  extends Promise<ResentmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ResentmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ResentmentPreviousValuesPromise>() => T;
}

export interface ResentmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResentmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResentmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ResentmentPreviousValuesSubscription>() => T;
}

export interface FunEdge {
  node: Fun;
  cursor: String;
}

export interface FunEdgePromise extends Promise<FunEdge>, Fragmentable {
  node: <T = FunPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FunEdgeSubscription
  extends Promise<AsyncIterator<FunEdge>>,
    Fragmentable {
  node: <T = FunSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ResentmentPreviousValues {
  id: ID_Output;
}

export interface ResentmentPreviousValuesPromise
  extends Promise<ResentmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ResentmentPreviousValuesSubscription
  extends Promise<AsyncIterator<ResentmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface FeelingEdge {
  node: Feeling;
  cursor: String;
}

export interface FeelingEdgePromise extends Promise<FeelingEdge>, Fragmentable {
  node: <T = FeelingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FeelingEdgeSubscription
  extends Promise<AsyncIterator<FeelingEdge>>,
    Fragmentable {
  node: <T = FeelingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AfflictionEdge {
  node: Affliction;
  cursor: String;
}

export interface AfflictionEdgePromise
  extends Promise<AfflictionEdge>,
    Fragmentable {
  node: <T = AfflictionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AfflictionEdgeSubscription
  extends Promise<AsyncIterator<AfflictionEdge>>,
    Fragmentable {
  node: <T = AfflictionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FearEdge {
  node: Fear;
  cursor: String;
}

export interface FearEdgePromise extends Promise<FearEdge>, Fragmentable {
  node: <T = FearPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FearEdgeSubscription
  extends Promise<AsyncIterator<FearEdge>>,
    Fragmentable {
  node: <T = FearSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SacrificeSubscriptionPayload {
  mutation: MutationType;
  node: Sacrifice;
  updatedFields: String[];
  previousValues: SacrificePreviousValues;
}

export interface SacrificeSubscriptionPayloadPromise
  extends Promise<SacrificeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SacrificePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SacrificePreviousValuesPromise>() => T;
}

export interface SacrificeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SacrificeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SacrificeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SacrificePreviousValuesSubscription>() => T;
}

export interface FaceConnection {
  pageInfo: PageInfo;
  edges: FaceEdge[];
}

export interface FaceConnectionPromise
  extends Promise<FaceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FaceEdge>>() => T;
  aggregate: <T = AggregateFacePromise>() => T;
}

export interface FaceConnectionSubscription
  extends Promise<AsyncIterator<FaceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FaceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFaceSubscription>() => T;
}

export interface SacrificePreviousValues {
  id: ID_Output;
}

export interface SacrificePreviousValuesPromise
  extends Promise<SacrificePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SacrificePreviousValuesSubscription
  extends Promise<AsyncIterator<SacrificePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Gratitude {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface GratitudePromise extends Promise<Gratitude>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface GratitudeSubscription
  extends Promise<AsyncIterator<Gratitude>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AfflictionConnection {
  pageInfo: PageInfo;
  edges: AfflictionEdge[];
}

export interface AfflictionConnectionPromise
  extends Promise<AfflictionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AfflictionEdge>>() => T;
  aggregate: <T = AggregateAfflictionPromise>() => T;
}

export interface AfflictionConnectionSubscription
  extends Promise<AsyncIterator<AfflictionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AfflictionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAfflictionSubscription>() => T;
}

export interface DreamConnection {
  pageInfo: PageInfo;
  edges: DreamEdge[];
}

export interface DreamConnectionPromise
  extends Promise<DreamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DreamEdge>>() => T;
  aggregate: <T = AggregateDreamPromise>() => T;
}

export interface DreamConnectionSubscription
  extends Promise<AsyncIterator<DreamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DreamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDreamSubscription>() => T;
}

export interface SalvationSubscriptionPayload {
  mutation: MutationType;
  node: Salvation;
  updatedFields: String[];
  previousValues: SalvationPreviousValues;
}

export interface SalvationSubscriptionPayloadPromise
  extends Promise<SalvationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SalvationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SalvationPreviousValuesPromise>() => T;
}

export interface SalvationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SalvationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SalvationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SalvationPreviousValuesSubscription>() => T;
}

export interface Impatience {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolveAt?: DateTimeOutput;
}

export interface ImpatiencePromise extends Promise<Impatience>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolveAt: () => Promise<DateTimeOutput>;
}

export interface ImpatienceSubscription
  extends Promise<AsyncIterator<Impatience>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SalvationPreviousValues {
  id: ID_Output;
  thought: String;
  character: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SalvationPreviousValuesPromise
  extends Promise<SalvationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  thought: () => Promise<String>;
  character: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SalvationPreviousValuesSubscription
  extends Promise<AsyncIterator<SalvationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  thought: () => Promise<AsyncIterator<String>>;
  character: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DenialEdge {
  node: Denial;
  cursor: String;
}

export interface DenialEdgePromise extends Promise<DenialEdge>, Fragmentable {
  node: <T = DenialPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DenialEdgeSubscription
  extends Promise<AsyncIterator<DenialEdge>>,
    Fragmentable {
  node: <T = DenialSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Delirium {
  id: ID_Output;
}

export interface DeliriumPromise extends Promise<Delirium>, Fragmentable {
  id: () => Promise<ID_Output>;
  trauma: <T = FragmentableArray<Trauma>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = FragmentableArray<Toxicity>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DeliriumSubscription
  extends Promise<AsyncIterator<Delirium>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  trauma: <T = Promise<AsyncIterator<TraumaSubscription>>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = Promise<AsyncIterator<ToxicitySubscription>>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DeliriumConnection {
  pageInfo: PageInfo;
  edges: DeliriumEdge[];
}

export interface DeliriumConnectionPromise
  extends Promise<DeliriumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DeliriumEdge>>() => T;
  aggregate: <T = AggregateDeliriumPromise>() => T;
}

export interface DeliriumConnectionSubscription
  extends Promise<AsyncIterator<DeliriumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DeliriumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDeliriumSubscription>() => T;
}

export interface SarcasmSubscriptionPayload {
  mutation: MutationType;
  node: Sarcasm;
  updatedFields: String[];
  previousValues: SarcasmPreviousValues;
}

export interface SarcasmSubscriptionPayloadPromise
  extends Promise<SarcasmSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SarcasmPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SarcasmPreviousValuesPromise>() => T;
}

export interface SarcasmSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SarcasmSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SarcasmSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SarcasmPreviousValuesSubscription>() => T;
}

export interface Defect {
  id: ID_Output;
}

export interface DefectPromise extends Promise<Defect>, Fragmentable {
  id: () => Promise<ID_Output>;
  trauma: <T = FragmentableArray<Trauma>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = FragmentableArray<Toxicity>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  suffering: <T = FragmentableArray<Suffering>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DefectSubscription
  extends Promise<AsyncIterator<Defect>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  trauma: <T = Promise<AsyncIterator<TraumaSubscription>>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = Promise<AsyncIterator<ToxicitySubscription>>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  suffering: <T = Promise<AsyncIterator<SufferingSubscription>>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SarcasmPreviousValues {
  id: ID_Output;
}

export interface SarcasmPreviousValuesPromise
  extends Promise<SarcasmPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SarcasmPreviousValuesSubscription
  extends Promise<AsyncIterator<SarcasmPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateCrown {
  count: Int;
}

export interface AggregateCrownPromise
  extends Promise<AggregateCrown>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCrownSubscription
  extends Promise<AsyncIterator<AggregateCrown>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Nightmare {
  id: ID_Output;
}

export interface NightmarePromise extends Promise<Nightmare>, Fragmentable {
  id: () => Promise<ID_Output>;
  trauma: <T = FragmentableArray<Trauma>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = FragmentableArray<Toxicity>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface NightmareSubscription
  extends Promise<AsyncIterator<Nightmare>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  trauma: <T = Promise<AsyncIterator<TraumaSubscription>>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = Promise<AsyncIterator<ToxicitySubscription>>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CrossEdge {
  node: Cross;
  cursor: String;
}

export interface CrossEdgePromise extends Promise<CrossEdge>, Fragmentable {
  node: <T = CrossPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CrossEdgeSubscription
  extends Promise<AsyncIterator<CrossEdge>>,
    Fragmentable {
  node: <T = CrossSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScarSubscriptionPayload {
  mutation: MutationType;
  node: Scar;
  updatedFields: String[];
  previousValues: ScarPreviousValues;
}

export interface ScarSubscriptionPayloadPromise
  extends Promise<ScarSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScarPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScarPreviousValuesPromise>() => T;
}

export interface ScarSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScarSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScarSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScarPreviousValuesSubscription>() => T;
}

export interface CourageConnection {
  pageInfo: PageInfo;
  edges: CourageEdge[];
}

export interface CourageConnectionPromise
  extends Promise<CourageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourageEdge>>() => T;
  aggregate: <T = AggregateCouragePromise>() => T;
}

export interface CourageConnectionSubscription
  extends Promise<AsyncIterator<CourageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourageSubscription>() => T;
}

export interface ScarPreviousValues {
  id: ID_Output;
}

export interface ScarPreviousValuesPromise
  extends Promise<ScarPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ScarPreviousValuesSubscription
  extends Promise<AsyncIterator<ScarPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateCongregant {
  count: Int;
}

export interface AggregateCongregantPromise
  extends Promise<AggregateCongregant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCongregantSubscription
  extends Promise<AsyncIterator<AggregateCongregant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Tremor {
  id: ID_Output;
}

export interface TremorPromise extends Promise<Tremor>, Fragmentable {
  id: () => Promise<ID_Output>;
  trauma: <T = FragmentableArray<Trauma>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = FragmentableArray<Toxicity>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TremorSubscription
  extends Promise<AsyncIterator<Tremor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  trauma: <T = Promise<AsyncIterator<TraumaSubscription>>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = Promise<AsyncIterator<ToxicitySubscription>>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ConfusionEdge {
  node: Confusion;
  cursor: String;
}

export interface ConfusionEdgePromise
  extends Promise<ConfusionEdge>,
    Fragmentable {
  node: <T = ConfusionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConfusionEdgeSubscription
  extends Promise<AsyncIterator<ConfusionEdge>>,
    Fragmentable {
  node: <T = ConfusionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SeekerSubscriptionPayload {
  mutation: MutationType;
  node: Seeker;
  updatedFields: String[];
  previousValues: SeekerPreviousValues;
}

export interface SeekerSubscriptionPayloadPromise
  extends Promise<SeekerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SeekerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SeekerPreviousValuesPromise>() => T;
}

export interface SeekerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SeekerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SeekerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SeekerPreviousValuesSubscription>() => T;
}

export interface CompassionConnection {
  pageInfo: PageInfo;
  edges: CompassionEdge[];
}

export interface CompassionConnectionPromise
  extends Promise<CompassionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompassionEdge>>() => T;
  aggregate: <T = AggregateCompassionPromise>() => T;
}

export interface CompassionConnectionSubscription
  extends Promise<AsyncIterator<CompassionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompassionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompassionSubscription>() => T;
}

export interface SeekerPreviousValues {
  id: ID_Output;
}

export interface SeekerPreviousValuesPromise
  extends Promise<SeekerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SeekerPreviousValuesSubscription
  extends Promise<AsyncIterator<SeekerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Volunteer {
  id: ID_Output;
}

export interface VolunteerPromise extends Promise<Volunteer>, Fragmentable {
  id: () => Promise<ID_Output>;
  act: <T = FragmentableArray<Act>>(
    args?: {
      where?: ActWhereInput;
      orderBy?: ActOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VolunteerSubscription
  extends Promise<AsyncIterator<Volunteer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  act: <T = Promise<AsyncIterator<ActSubscription>>>(
    args?: {
      where?: ActWhereInput;
      orderBy?: ActOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Infection {
  id: ID_Output;
}

export interface InfectionPromise extends Promise<Infection>, Fragmentable {
  id: () => Promise<ID_Output>;
  trauma: <T = FragmentableArray<Trauma>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = FragmentableArray<Toxicity>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface InfectionSubscription
  extends Promise<AsyncIterator<Infection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  trauma: <T = Promise<AsyncIterator<TraumaSubscription>>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = Promise<AsyncIterator<ToxicitySubscription>>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Denial {
  id: ID_Output;
}

export interface DenialPromise extends Promise<Denial>, Fragmentable {
  id: () => Promise<ID_Output>;
  armor: <T = FragmentableArray<Armor>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DenialSubscription
  extends Promise<AsyncIterator<Denial>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  armor: <T = Promise<AsyncIterator<ArmorSubscription>>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SelfSubscriptionPayload {
  mutation: MutationType;
  node: Self;
  updatedFields: String[];
  previousValues: SelfPreviousValues;
}

export interface SelfSubscriptionPayloadPromise
  extends Promise<SelfSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SelfPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SelfPreviousValuesPromise>() => T;
}

export interface SelfSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SelfSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SelfSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SelfPreviousValuesSubscription>() => T;
}

export interface AggregateWall {
  count: Int;
}

export interface AggregateWallPromise
  extends Promise<AggregateWall>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateWallSubscription
  extends Promise<AsyncIterator<AggregateWall>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SelfPreviousValues {
  id: ID_Output;
}

export interface SelfPreviousValuesPromise
  extends Promise<SelfPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SelfPreviousValuesSubscription
  extends Promise<AsyncIterator<SelfPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface VolunteerConnection {
  pageInfo: PageInfo;
  edges: VolunteerEdge[];
}

export interface VolunteerConnectionPromise
  extends Promise<VolunteerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VolunteerEdge>>() => T;
  aggregate: <T = AggregateVolunteerPromise>() => T;
}

export interface VolunteerConnectionSubscription
  extends Promise<AsyncIterator<VolunteerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VolunteerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVolunteerSubscription>() => T;
}

export interface Gash {
  id: ID_Output;
}

export interface GashPromise extends Promise<Gash>, Fragmentable {
  id: () => Promise<ID_Output>;
  trauma: <T = FragmentableArray<Trauma>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = FragmentableArray<Toxicity>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface GashSubscription
  extends Promise<AsyncIterator<Gash>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  trauma: <T = Promise<AsyncIterator<TraumaSubscription>>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = Promise<AsyncIterator<ToxicitySubscription>>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TremorEdge {
  node: Tremor;
  cursor: String;
}

export interface TremorEdgePromise extends Promise<TremorEdge>, Fragmentable {
  node: <T = TremorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TremorEdgeSubscription
  extends Promise<AsyncIterator<TremorEdge>>,
    Fragmentable {
  node: <T = TremorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SelfPitySubscriptionPayload {
  mutation: MutationType;
  node: SelfPity;
  updatedFields: String[];
  previousValues: SelfPityPreviousValues;
}

export interface SelfPitySubscriptionPayloadPromise
  extends Promise<SelfPitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SelfPityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SelfPityPreviousValuesPromise>() => T;
}

export interface SelfPitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SelfPitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SelfPitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SelfPityPreviousValuesSubscription>() => T;
}

export interface AggregateTower {
  count: Int;
}

export interface AggregateTowerPromise
  extends Promise<AggregateTower>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTowerSubscription
  extends Promise<AsyncIterator<AggregateTower>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SelfPityPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SelfPityPreviousValuesPromise
  extends Promise<SelfPityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SelfPityPreviousValuesSubscription
  extends Promise<AsyncIterator<SelfPityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SummonerConnection {
  pageInfo: PageInfo;
  edges: SummonerEdge[];
}

export interface SummonerConnectionPromise
  extends Promise<SummonerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SummonerEdge>>() => T;
  aggregate: <T = AggregateSummonerPromise>() => T;
}

export interface SummonerConnectionSubscription
  extends Promise<AsyncIterator<SummonerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SummonerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSummonerSubscription>() => T;
}

export interface Toxicity {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ToxicityPromise extends Promise<Toxicity>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ToxicitySubscription
  extends Promise<AsyncIterator<Toxicity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StigmataEdge {
  node: Stigmata;
  cursor: String;
}

export interface StigmataEdgePromise
  extends Promise<StigmataEdge>,
    Fragmentable {
  node: <T = StigmataPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StigmataEdgeSubscription
  extends Promise<AsyncIterator<StigmataEdge>>,
    Fragmentable {
  node: <T = StigmataSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType;
  node: Service;
  updatedFields: String[];
  previousValues: ServicePreviousValues;
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServicePreviousValuesPromise>() => T;
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServicePreviousValuesSubscription>() => T;
}

export interface AggregateSmith {
  count: Int;
}

export interface AggregateSmithPromise
  extends Promise<AggregateSmith>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSmithSubscription
  extends Promise<AsyncIterator<AggregateSmith>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ServicePreviousValues {
  id: ID_Output;
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SilenceEdge {
  node: Silence;
  cursor: String;
}

export interface SilenceEdgePromise extends Promise<SilenceEdge>, Fragmentable {
  node: <T = SilencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SilenceEdgeSubscription
  extends Promise<AsyncIterator<SilenceEdge>>,
    Fragmentable {
  node: <T = SilenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Trauma {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface TraumaPromise extends Promise<Trauma>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface TraumaSubscription
  extends Promise<AsyncIterator<Trauma>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateSelfPity {
  count: Int;
}

export interface AggregateSelfPityPromise
  extends Promise<AggregateSelfPity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSelfPitySubscription
  extends Promise<AsyncIterator<AggregateSelfPity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShieldSubscriptionPayload {
  mutation: MutationType;
  node: Shield;
  updatedFields: String[];
  previousValues: ShieldPreviousValues;
}

export interface ShieldSubscriptionPayloadPromise
  extends Promise<ShieldSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShieldPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShieldPreviousValuesPromise>() => T;
}

export interface ShieldSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShieldSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShieldSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShieldPreviousValuesSubscription>() => T;
}

export interface SeekerConnection {
  pageInfo: PageInfo;
  edges: SeekerEdge[];
}

export interface SeekerConnectionPromise
  extends Promise<SeekerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SeekerEdge>>() => T;
  aggregate: <T = AggregateSeekerPromise>() => T;
}

export interface SeekerConnectionSubscription
  extends Promise<AsyncIterator<SeekerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SeekerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSeekerSubscription>() => T;
}

export interface ShieldPreviousValues {
  id: ID_Output;
}

export interface ShieldPreviousValuesPromise
  extends Promise<ShieldPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface ShieldPreviousValuesSubscription
  extends Promise<AsyncIterator<ShieldPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SalvationEdge {
  node: Salvation;
  cursor: String;
}

export interface SalvationEdgePromise
  extends Promise<SalvationEdge>,
    Fragmentable {
  node: <T = SalvationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SalvationEdgeSubscription
  extends Promise<AsyncIterator<SalvationEdge>>,
    Fragmentable {
  node: <T = SalvationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Scar {
  id: ID_Output;
}

export interface ScarPromise extends Promise<Scar>, Fragmentable {
  id: () => Promise<ID_Output>;
  trauma: <T = FragmentableArray<Trauma>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = FragmentableArray<Toxicity>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ScarSubscription
  extends Promise<AsyncIterator<Scar>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  trauma: <T = Promise<AsyncIterator<TraumaSubscription>>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = Promise<AsyncIterator<ToxicitySubscription>>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateProcess {
  count: Int;
}

export interface AggregateProcessPromise
  extends Promise<AggregateProcess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProcessSubscription
  extends Promise<AsyncIterator<AggregateProcess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SilenceSubscriptionPayload {
  mutation: MutationType;
  node: Silence;
  updatedFields: String[];
  previousValues: SilencePreviousValues;
}

export interface SilenceSubscriptionPayloadPromise
  extends Promise<SilenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SilencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SilencePreviousValuesPromise>() => T;
}

export interface SilenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SilenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SilenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SilencePreviousValuesSubscription>() => T;
}

export interface PrayerConnection {
  pageInfo: PageInfo;
  edges: PrayerEdge[];
}

export interface PrayerConnectionPromise
  extends Promise<PrayerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PrayerEdge>>() => T;
  aggregate: <T = AggregatePrayerPromise>() => T;
}

export interface PrayerConnectionSubscription
  extends Promise<AsyncIterator<PrayerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PrayerEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePrayerSubscription>() => T;
}

export interface SilencePreviousValues {
  id: ID_Output;
}

export interface SilencePreviousValuesPromise
  extends Promise<SilencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SilencePreviousValuesSubscription
  extends Promise<AsyncIterator<SilencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface PaladinEdge {
  node: Paladin;
  cursor: String;
}

export interface PaladinEdgePromise extends Promise<PaladinEdge>, Fragmentable {
  node: <T = PaladinPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaladinEdgeSubscription
  extends Promise<AsyncIterator<PaladinEdge>>,
    Fragmentable {
  node: <T = PaladinSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Affliction {
  id: ID_Output;
}

export interface AfflictionPromise extends Promise<Affliction>, Fragmentable {
  id: () => Promise<ID_Output>;
  scar: <T = FragmentableArray<Scar>>(
    args?: {
      where?: ScarWhereInput;
      orderBy?: ScarOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  gash: <T = FragmentableArray<Gash>>(
    args?: {
      where?: GashWhereInput;
      orderBy?: GashOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  infection: <T = FragmentableArray<Infection>>(
    args?: {
      where?: InfectionWhereInput;
      orderBy?: InfectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tremor: <T = FragmentableArray<Tremor>>(
    args?: {
      where?: TremorWhereInput;
      orderBy?: TremorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  nightmare: <T = FragmentableArray<Nightmare>>(
    args?: {
      where?: NightmareWhereInput;
      orderBy?: NightmareOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  delirium: <T = FragmentableArray<Delirium>>(
    args?: {
      where?: DeliriumWhereInput;
      orderBy?: DeliriumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AfflictionSubscription
  extends Promise<AsyncIterator<Affliction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  scar: <T = Promise<AsyncIterator<ScarSubscription>>>(
    args?: {
      where?: ScarWhereInput;
      orderBy?: ScarOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  gash: <T = Promise<AsyncIterator<GashSubscription>>>(
    args?: {
      where?: GashWhereInput;
      orderBy?: GashOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  infection: <T = Promise<AsyncIterator<InfectionSubscription>>>(
    args?: {
      where?: InfectionWhereInput;
      orderBy?: InfectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tremor: <T = Promise<AsyncIterator<TremorSubscription>>>(
    args?: {
      where?: TremorWhereInput;
      orderBy?: TremorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  nightmare: <T = Promise<AsyncIterator<NightmareSubscription>>>(
    args?: {
      where?: NightmareWhereInput;
      orderBy?: NightmareOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  delirium: <T = Promise<AsyncIterator<DeliriumSubscription>>>(
    args?: {
      where?: DeliriumWhereInput;
      orderBy?: DeliriumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateNightmare {
  count: Int;
}

export interface AggregateNightmarePromise
  extends Promise<AggregateNightmare>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNightmareSubscription
  extends Promise<AsyncIterator<AggregateNightmare>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SkinSubscriptionPayload {
  mutation: MutationType;
  node: Skin;
  updatedFields: String[];
  previousValues: SkinPreviousValues;
}

export interface SkinSubscriptionPayloadPromise
  extends Promise<SkinSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SkinPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SkinPreviousValuesPromise>() => T;
}

export interface SkinSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SkinSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SkinSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SkinPreviousValuesSubscription>() => T;
}

export interface MouthConnection {
  pageInfo: PageInfo;
  edges: MouthEdge[];
}

export interface MouthConnectionPromise
  extends Promise<MouthConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MouthEdge>>() => T;
  aggregate: <T = AggregateMouthPromise>() => T;
}

export interface MouthConnectionSubscription
  extends Promise<AsyncIterator<MouthConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MouthEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMouthSubscription>() => T;
}

export interface SkinPreviousValues {
  id: ID_Output;
}

export interface SkinPreviousValuesPromise
  extends Promise<SkinPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SkinPreviousValuesSubscription
  extends Promise<AsyncIterator<SkinPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface LoveConnection {
  pageInfo: PageInfo;
  edges: LoveEdge[];
}

export interface LoveConnectionPromise
  extends Promise<LoveConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoveEdge>>() => T;
  aggregate: <T = AggregateLovePromise>() => T;
}

export interface LoveConnectionSubscription
  extends Promise<AsyncIterator<LoveConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoveEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoveSubscription>() => T;
}

export interface AggregateAct {
  count: Int;
}

export interface AggregateActPromise
  extends Promise<AggregateAct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateActSubscription
  extends Promise<AsyncIterator<AggregateAct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateInventory {
  count: Int;
}

export interface AggregateInventoryPromise
  extends Promise<AggregateInventory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventorySubscription
  extends Promise<AsyncIterator<AggregateInventory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SmithSubscriptionPayload {
  mutation: MutationType;
  node: Smith;
  updatedFields: String[];
  previousValues: SmithPreviousValues;
}

export interface SmithSubscriptionPayloadPromise
  extends Promise<SmithSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SmithPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SmithPreviousValuesPromise>() => T;
}

export interface SmithSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SmithSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SmithSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SmithPreviousValuesSubscription>() => T;
}

export interface ImpatienceEdge {
  node: Impatience;
  cursor: String;
}

export interface ImpatienceEdgePromise
  extends Promise<ImpatienceEdge>,
    Fragmentable {
  node: <T = ImpatiencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImpatienceEdgeSubscription
  extends Promise<AsyncIterator<ImpatienceEdge>>,
    Fragmentable {
  node: <T = ImpatienceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SmithPreviousValues {
  id: ID_Output;
}

export interface SmithPreviousValuesPromise
  extends Promise<SmithPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SmithPreviousValuesSubscription
  extends Promise<AsyncIterator<SmithPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateHigherPower {
  count: Int;
}

export interface AggregateHigherPowerPromise
  extends Promise<AggregateHigherPower>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHigherPowerSubscription
  extends Promise<AsyncIterator<AggregateHigherPower>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ActEdge {
  node: Act;
  cursor: String;
}

export interface ActEdgePromise extends Promise<ActEdge>, Fragmentable {
  node: <T = ActPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ActEdgeSubscription
  extends Promise<AsyncIterator<ActEdge>>,
    Fragmentable {
  node: <T = ActSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Path {
  id: ID_Output;
}

export interface PathPromise extends Promise<Path>, Fragmentable {
  id: () => Promise<ID_Output>;
  defect: <T = DefectPromise>() => T;
  discontent: <T = DiscontentPromise>() => T;
  resentment: <T = ResentmentPromise>() => T;
  obsession: <T = ObsessionPromise>() => T;
  experience: <T = ExperiencePromise>() => T;
  strength: <T = StrengthPromise>() => T;
  hope: <T = HopePromise>() => T;
}

export interface PathSubscription
  extends Promise<AsyncIterator<Path>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  defect: <T = DefectSubscription>() => T;
  discontent: <T = DiscontentSubscription>() => T;
  resentment: <T = ResentmentSubscription>() => T;
  obsession: <T = ObsessionSubscription>() => T;
  experience: <T = ExperienceSubscription>() => T;
  strength: <T = StrengthSubscription>() => T;
  hope: <T = HopeSubscription>() => T;
}

export interface SoulSubscriptionPayload {
  mutation: MutationType;
  node: Soul;
  updatedFields: String[];
  previousValues: SoulPreviousValues;
}

export interface SoulSubscriptionPayloadPromise
  extends Promise<SoulSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SoulPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SoulPreviousValuesPromise>() => T;
}

export interface SoulSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SoulSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SoulSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SoulPreviousValuesSubscription>() => T;
}

export interface HasEdge {
  node: Has;
  cursor: String;
}

export interface HasEdgePromise extends Promise<HasEdge>, Fragmentable {
  node: <T = HasPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HasEdgeSubscription
  extends Promise<AsyncIterator<HasEdge>>,
    Fragmentable {
  node: <T = HasSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SoulPreviousValues {
  id: ID_Output;
}

export interface SoulPreviousValuesPromise
  extends Promise<SoulPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SoulPreviousValuesSubscription
  extends Promise<AsyncIterator<SoulPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface GuardianConnection {
  pageInfo: PageInfo;
  edges: GuardianEdge[];
}

export interface GuardianConnectionPromise
  extends Promise<GuardianConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GuardianEdge>>() => T;
  aggregate: <T = AggregateGuardianPromise>() => T;
}

export interface GuardianConnectionSubscription
  extends Promise<AsyncIterator<GuardianConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GuardianEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGuardianSubscription>() => T;
}

export interface ActConnection {
  pageInfo: PageInfo;
  edges: ActEdge[];
}

export interface ActConnectionPromise
  extends Promise<ActConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ActEdge>>() => T;
  aggregate: <T = AggregateActPromise>() => T;
}

export interface ActConnectionSubscription
  extends Promise<AsyncIterator<ActConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ActEdgeSubscription>>>() => T;
  aggregate: <T = AggregateActSubscription>() => T;
}

export interface GateEdge {
  node: Gate;
  cursor: String;
}

export interface GateEdgePromise extends Promise<GateEdge>, Fragmentable {
  node: <T = GatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GateEdgeSubscription
  extends Promise<AsyncIterator<GateEdge>>,
    Fragmentable {
  node: <T = GateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SternumSubscriptionPayload {
  mutation: MutationType;
  node: Sternum;
  updatedFields: String[];
  previousValues: SternumPreviousValues;
}

export interface SternumSubscriptionPayloadPromise
  extends Promise<SternumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SternumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SternumPreviousValuesPromise>() => T;
}

export interface SternumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SternumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SternumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SternumPreviousValuesSubscription>() => T;
}

export interface Fun {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolveAt?: DateTimeOutput;
}

export interface FunPromise extends Promise<Fun>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolveAt: () => Promise<DateTimeOutput>;
}

export interface FunSubscription
  extends Promise<AsyncIterator<Fun>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolveAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SternumPreviousValues {
  id: ID_Output;
}

export interface SternumPreviousValuesPromise
  extends Promise<SternumPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SternumPreviousValuesSubscription
  extends Promise<AsyncIterator<SternumPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateFace {
  count: Int;
}

export interface AggregateFacePromise
  extends Promise<AggregateFace>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFaceSubscription
  extends Promise<AsyncIterator<AggregateFace>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Sacrifice {
  id: ID_Output;
}

export interface SacrificePromise extends Promise<Sacrifice>, Fragmentable {
  id: () => Promise<ID_Output>;
  courage: <T = FragmentableArray<Courage>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  compassion: <T = FragmentableArray<Compassion>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SacrificeSubscription
  extends Promise<AsyncIterator<Sacrifice>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  courage: <T = Promise<AsyncIterator<CourageSubscription>>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  compassion: <T = Promise<AsyncIterator<CompassionSubscription>>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateDream {
  count: Int;
}

export interface AggregateDreamPromise
  extends Promise<AggregateDream>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDreamSubscription
  extends Promise<AsyncIterator<AggregateDream>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StigmataSubscriptionPayload {
  mutation: MutationType;
  node: Stigmata;
  updatedFields: String[];
  previousValues: StigmataPreviousValues;
}

export interface StigmataSubscriptionPayloadPromise
  extends Promise<StigmataSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StigmataPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StigmataPreviousValuesPromise>() => T;
}

export interface StigmataSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StigmataSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StigmataSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StigmataPreviousValuesSubscription>() => T;
}

export interface Discontent {
  id: ID_Output;
}

export interface DiscontentPromise extends Promise<Discontent>, Fragmentable {
  id: () => Promise<ID_Output>;
  irritability: <T = FragmentableArray<Irritability>>(
    args?: {
      where?: IrritabilityWhereInput;
      orderBy?: IrritabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  impatience: <T = FragmentableArray<Impatience>>(
    args?: {
      where?: ImpatienceWhereInput;
      orderBy?: ImpatienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DiscontentSubscription
  extends Promise<AsyncIterator<Discontent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  irritability: <T = Promise<AsyncIterator<IrritabilitySubscription>>>(
    args?: {
      where?: IrritabilityWhereInput;
      orderBy?: IrritabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  impatience: <T = Promise<AsyncIterator<ImpatienceSubscription>>>(
    args?: {
      where?: ImpatienceWhereInput;
      orderBy?: ImpatienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StigmataPreviousValues {
  id: ID_Output;
}

export interface StigmataPreviousValuesPromise
  extends Promise<StigmataPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface StigmataPreviousValuesSubscription
  extends Promise<AsyncIterator<StigmataPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface DefectEdge {
  node: Defect;
  cursor: String;
}

export interface DefectEdgePromise extends Promise<DefectEdge>, Fragmentable {
  node: <T = DefectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DefectEdgeSubscription
  extends Promise<AsyncIterator<DefectEdge>>,
    Fragmentable {
  node: <T = DefectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Support {
  id: ID_Output;
}

export interface SupportPromise extends Promise<Support>, Fragmentable {
  id: () => Promise<ID_Output>;
  courage: <T = FragmentableArray<Courage>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  compassion: <T = FragmentableArray<Compassion>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SupportSubscription
  extends Promise<AsyncIterator<Support>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  courage: <T = Promise<AsyncIterator<CourageSubscription>>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  compassion: <T = Promise<AsyncIterator<CompassionSubscription>>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CrownConnection {
  pageInfo: PageInfo;
  edges: CrownEdge[];
}

export interface CrownConnectionPromise
  extends Promise<CrownConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CrownEdge>>() => T;
  aggregate: <T = AggregateCrownPromise>() => T;
}

export interface CrownConnectionSubscription
  extends Promise<AsyncIterator<CrownConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CrownEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCrownSubscription>() => T;
}

export interface StrengthSubscriptionPayload {
  mutation: MutationType;
  node: Strength;
  updatedFields: String[];
  previousValues: StrengthPreviousValues;
}

export interface StrengthSubscriptionPayloadPromise
  extends Promise<StrengthSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StrengthPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StrengthPreviousValuesPromise>() => T;
}

export interface StrengthSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StrengthSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StrengthSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StrengthPreviousValuesSubscription>() => T;
}

export interface ConstructEdge {
  node: Construct;
  cursor: String;
}

export interface ConstructEdgePromise
  extends Promise<ConstructEdge>,
    Fragmentable {
  node: <T = ConstructPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConstructEdgeSubscription
  extends Promise<AsyncIterator<ConstructEdge>>,
    Fragmentable {
  node: <T = ConstructSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface StrengthPreviousValues {
  id: ID_Output;
}

export interface StrengthPreviousValuesPromise
  extends Promise<StrengthPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface StrengthPreviousValuesSubscription
  extends Promise<AsyncIterator<StrengthPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateCompassion {
  count: Int;
}

export interface AggregateCompassionPromise
  extends Promise<AggregateCompassion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompassionSubscription
  extends Promise<AsyncIterator<AggregateCompassion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Compassion {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface CompassionPromise extends Promise<Compassion>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface CompassionSubscription
  extends Promise<AsyncIterator<Compassion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Summoner {
  id: ID_Output;
}

export interface SummonerPromise extends Promise<Summoner>, Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SummonerSubscription
  extends Promise<AsyncIterator<Summoner>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SufferingSubscriptionPayload {
  mutation: MutationType;
  node: Suffering;
  updatedFields: String[];
  previousValues: SufferingPreviousValues;
}

export interface SufferingSubscriptionPayloadPromise
  extends Promise<SufferingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SufferingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SufferingPreviousValuesPromise>() => T;
}

export interface SufferingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SufferingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SufferingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SufferingPreviousValuesSubscription>() => T;
}

export interface VulnerabilityEdge {
  node: Vulnerability;
  cursor: String;
}

export interface VulnerabilityEdgePromise
  extends Promise<VulnerabilityEdge>,
    Fragmentable {
  node: <T = VulnerabilityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VulnerabilityEdgeSubscription
  extends Promise<AsyncIterator<VulnerabilityEdge>>,
    Fragmentable {
  node: <T = VulnerabilitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SufferingPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SufferingPreviousValuesPromise
  extends Promise<SufferingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SufferingPreviousValuesSubscription
  extends Promise<AsyncIterator<SufferingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TraumaConnection {
  pageInfo: PageInfo;
  edges: TraumaEdge[];
}

export interface TraumaConnectionPromise
  extends Promise<TraumaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TraumaEdge>>() => T;
  aggregate: <T = AggregateTraumaPromise>() => T;
}

export interface TraumaConnectionSubscription
  extends Promise<AsyncIterator<TraumaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TraumaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTraumaSubscription>() => T;
}

export interface Courage {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface CouragePromise extends Promise<Courage>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface CourageSubscription
  extends Promise<AsyncIterator<Courage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateStrength {
  count: Int;
}

export interface AggregateStrengthPromise
  extends Promise<AggregateStrength>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStrengthSubscription
  extends Promise<AsyncIterator<AggregateStrength>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SummonerSubscriptionPayload {
  mutation: MutationType;
  node: Summoner;
  updatedFields: String[];
  previousValues: SummonerPreviousValues;
}

export interface SummonerSubscriptionPayloadPromise
  extends Promise<SummonerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SummonerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SummonerPreviousValuesPromise>() => T;
}

export interface SummonerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SummonerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SummonerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SummonerPreviousValuesSubscription>() => T;
}

export interface SkinEdge {
  node: Skin;
  cursor: String;
}

export interface SkinEdgePromise extends Promise<SkinEdge>, Fragmentable {
  node: <T = SkinPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SkinEdgeSubscription
  extends Promise<AsyncIterator<SkinEdge>>,
    Fragmentable {
  node: <T = SkinSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SummonerPreviousValues {
  id: ID_Output;
}

export interface SummonerPreviousValuesPromise
  extends Promise<SummonerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SummonerPreviousValuesSubscription
  extends Promise<AsyncIterator<SummonerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SelfEdge {
  node: Self;
  cursor: String;
}

export interface SelfEdgePromise extends Promise<SelfEdge>, Fragmentable {
  node: <T = SelfPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SelfEdgeSubscription
  extends Promise<AsyncIterator<SelfEdge>>,
    Fragmentable {
  node: <T = SelfSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Service {
  id: ID_Output;
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<ID_Output>;
  courage: <T = FragmentableArray<Courage>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  compassion: <T = FragmentableArray<Compassion>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  courage: <T = Promise<AsyncIterator<CourageSubscription>>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  compassion: <T = Promise<AsyncIterator<CompassionSubscription>>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SacrificeConnection {
  pageInfo: PageInfo;
  edges: SacrificeEdge[];
}

export interface SacrificeConnectionPromise
  extends Promise<SacrificeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SacrificeEdge>>() => T;
  aggregate: <T = AggregateSacrificePromise>() => T;
}

export interface SacrificeConnectionSubscription
  extends Promise<AsyncIterator<SacrificeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SacrificeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSacrificeSubscription>() => T;
}

export interface SupportSubscriptionPayload {
  mutation: MutationType;
  node: Support;
  updatedFields: String[];
  previousValues: SupportPreviousValues;
}

export interface SupportSubscriptionPayloadPromise
  extends Promise<SupportSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SupportPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SupportPreviousValuesPromise>() => T;
}

export interface SupportSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SupportSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SupportSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SupportPreviousValuesSubscription>() => T;
}

export interface AggregatePath {
  count: Int;
}

export interface AggregatePathPromise
  extends Promise<AggregatePath>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePathSubscription
  extends Promise<AsyncIterator<AggregatePath>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SupportPreviousValues {
  id: ID_Output;
}

export interface SupportPreviousValuesPromise
  extends Promise<SupportPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface SupportPreviousValuesSubscription
  extends Promise<AsyncIterator<SupportPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface NailEdge {
  node: Nail;
  cursor: String;
}

export interface NailEdgePromise extends Promise<NailEdge>, Fragmentable {
  node: <T = NailPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NailEdgeSubscription
  extends Promise<AsyncIterator<NailEdge>>,
    Fragmentable {
  node: <T = NailSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Act {
  id: ID_Output;
}

export interface ActPromise extends Promise<Act>, Fragmentable {
  id: () => Promise<ID_Output>;
  service: <T = FragmentableArray<Service>>(
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  support: <T = FragmentableArray<Support>>(
    args?: {
      where?: SupportWhereInput;
      orderBy?: SupportOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sacrifice: <T = FragmentableArray<Sacrifice>>(
    args?: {
      where?: SacrificeWhereInput;
      orderBy?: SacrificeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ActSubscription
  extends Promise<AsyncIterator<Act>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  service: <T = Promise<AsyncIterator<ServiceSubscription>>>(
    args?: {
      where?: ServiceWhereInput;
      orderBy?: ServiceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  support: <T = Promise<AsyncIterator<SupportSubscription>>>(
    args?: {
      where?: SupportWhereInput;
      orderBy?: SupportOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  sacrifice: <T = Promise<AsyncIterator<SacrificeSubscription>>>(
    args?: {
      where?: SacrificeWhereInput;
      orderBy?: SacrificeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface JoyConnection {
  pageInfo: PageInfo;
  edges: JoyEdge[];
}

export interface JoyConnectionPromise
  extends Promise<JoyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<JoyEdge>>() => T;
  aggregate: <T = AggregateJoyPromise>() => T;
}

export interface JoyConnectionSubscription
  extends Promise<AsyncIterator<JoyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<JoyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateJoySubscription>() => T;
}

export interface TowerSubscriptionPayload {
  mutation: MutationType;
  node: Tower;
  updatedFields: String[];
  previousValues: TowerPreviousValues;
}

export interface TowerSubscriptionPayloadPromise
  extends Promise<TowerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TowerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TowerPreviousValuesPromise>() => T;
}

export interface TowerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TowerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TowerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TowerPreviousValuesSubscription>() => T;
}

export interface HopeConnection {
  pageInfo: PageInfo;
  edges: HopeEdge[];
}

export interface HopeConnectionPromise
  extends Promise<HopeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HopeEdge>>() => T;
  aggregate: <T = AggregateHopePromise>() => T;
}

export interface HopeConnectionSubscription
  extends Promise<AsyncIterator<HopeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HopeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHopeSubscription>() => T;
}

export interface TowerPreviousValues {
  id: ID_Output;
}

export interface TowerPreviousValuesPromise
  extends Promise<TowerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface TowerPreviousValuesSubscription
  extends Promise<AsyncIterator<TowerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateHeart {
  count: Int;
}

export interface AggregateHeartPromise
  extends Promise<AggregateHeart>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHeartSubscription
  extends Promise<AsyncIterator<AggregateHeart>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateAcceptance {
  count: Int;
}

export interface AggregateAcceptancePromise
  extends Promise<AggregateAcceptance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAcceptanceSubscription
  extends Promise<AsyncIterator<AggregateAcceptance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateGenie {
  count: Int;
}

export interface AggregateGeniePromise
  extends Promise<AggregateGenie>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGenieSubscription
  extends Promise<AsyncIterator<AggregateGenie>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ToxicitySubscriptionPayload {
  mutation: MutationType;
  node: Toxicity;
  updatedFields: String[];
  previousValues: ToxicityPreviousValues;
}

export interface ToxicitySubscriptionPayloadPromise
  extends Promise<ToxicitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ToxicityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ToxicityPreviousValuesPromise>() => T;
}

export interface ToxicitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ToxicitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ToxicitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ToxicityPreviousValuesSubscription>() => T;
}

export interface Feeling {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface FeelingPromise extends Promise<Feeling>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface FeelingSubscription
  extends Promise<AsyncIterator<Feeling>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ToxicityPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ToxicityPreviousValuesPromise
  extends Promise<ToxicityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ToxicityPreviousValuesSubscription
  extends Promise<AsyncIterator<ToxicityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DiscontentEdge {
  node: Discontent;
  cursor: String;
}

export interface DiscontentEdgePromise
  extends Promise<DiscontentEdge>,
    Fragmentable {
  node: <T = DiscontentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DiscontentEdgeSubscription
  extends Promise<AsyncIterator<DiscontentEdge>>,
    Fragmentable {
  node: <T = DiscontentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AcceptanceEdge {
  node: Acceptance;
  cursor: String;
}

export interface AcceptanceEdgePromise
  extends Promise<AcceptanceEdge>,
    Fragmentable {
  node: <T = AcceptancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AcceptanceEdgeSubscription
  extends Promise<AsyncIterator<AcceptanceEdge>>,
    Fragmentable {
  node: <T = AcceptanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CrusadeEdge {
  node: Crusade;
  cursor: String;
}

export interface CrusadeEdgePromise extends Promise<CrusadeEdge>, Fragmentable {
  node: <T = CrusadePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CrusadeEdgeSubscription
  extends Promise<AsyncIterator<CrusadeEdge>>,
    Fragmentable {
  node: <T = CrusadeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TraumaSubscriptionPayload {
  mutation: MutationType;
  node: Trauma;
  updatedFields: String[];
  previousValues: TraumaPreviousValues;
}

export interface TraumaSubscriptionPayloadPromise
  extends Promise<TraumaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TraumaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TraumaPreviousValuesPromise>() => T;
}

export interface TraumaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TraumaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TraumaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TraumaPreviousValuesSubscription>() => T;
}

export interface CongregantConnection {
  pageInfo: PageInfo;
  edges: CongregantEdge[];
}

export interface CongregantConnectionPromise
  extends Promise<CongregantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CongregantEdge>>() => T;
  aggregate: <T = AggregateCongregantPromise>() => T;
}

export interface CongregantConnectionSubscription
  extends Promise<AsyncIterator<CongregantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CongregantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCongregantSubscription>() => T;
}

export interface TraumaPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface TraumaPreviousValuesPromise
  extends Promise<TraumaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface TraumaPreviousValuesSubscription
  extends Promise<AsyncIterator<TraumaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface WishSubscriptionPayload {
  mutation: MutationType;
  node: Wish;
  updatedFields: String[];
  previousValues: WishPreviousValues;
}

export interface WishSubscriptionPayloadPromise
  extends Promise<WishSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = WishPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = WishPreviousValuesPromise>() => T;
}

export interface WishSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<WishSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = WishSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = WishPreviousValuesSubscription>() => T;
}

export interface SupportEdge {
  node: Support;
  cursor: String;
}

export interface SupportEdgePromise extends Promise<SupportEdge>, Fragmentable {
  node: <T = SupportPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SupportEdgeSubscription
  extends Promise<AsyncIterator<SupportEdge>>,
    Fragmentable {
  node: <T = SupportSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TremorSubscriptionPayload {
  mutation: MutationType;
  node: Tremor;
  updatedFields: String[];
  previousValues: TremorPreviousValues;
}

export interface TremorSubscriptionPayloadPromise
  extends Promise<TremorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TremorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TremorPreviousValuesPromise>() => T;
}

export interface TremorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TremorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TremorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TremorPreviousValuesSubscription>() => T;
}

export interface ShieldConnection {
  pageInfo: PageInfo;
  edges: ShieldEdge[];
}

export interface ShieldConnectionPromise
  extends Promise<ShieldConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ShieldEdge>>() => T;
  aggregate: <T = AggregateShieldPromise>() => T;
}

export interface ShieldConnectionSubscription
  extends Promise<AsyncIterator<ShieldConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShieldEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShieldSubscription>() => T;
}

export interface TremorPreviousValues {
  id: ID_Output;
}

export interface TremorPreviousValuesPromise
  extends Promise<TremorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface TremorPreviousValuesSubscription
  extends Promise<AsyncIterator<TremorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface PrideEdge {
  node: Pride;
  cursor: String;
}

export interface PrideEdgePromise extends Promise<PrideEdge>, Fragmentable {
  node: <T = PridePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PrideEdgeSubscription
  extends Promise<AsyncIterator<PrideEdge>>,
    Fragmentable {
  node: <T = PrideSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface LoyaltyEdge {
  node: Loyalty;
  cursor: String;
}

export interface LoyaltyEdgePromise extends Promise<LoyaltyEdge>, Fragmentable {
  node: <T = LoyaltyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoyaltyEdgeSubscription
  extends Promise<AsyncIterator<LoyaltyEdge>>,
    Fragmentable {
  node: <T = LoyaltySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VictimSubscriptionPayload {
  mutation: MutationType;
  node: Victim;
  updatedFields: String[];
  previousValues: VictimPreviousValues;
}

export interface VictimSubscriptionPayloadPromise
  extends Promise<VictimSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VictimPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VictimPreviousValuesPromise>() => T;
}

export interface VictimSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VictimSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VictimSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VictimPreviousValuesSubscription>() => T;
}

export interface Hope {
  id: ID_Output;
}

export interface HopePromise extends Promise<Hope>, Fragmentable {
  id: () => Promise<ID_Output>;
  salvation: <T = FragmentableArray<Salvation>>(
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fun: <T = FragmentableArray<Fun>>(
    args?: {
      where?: FunWhereInput;
      orderBy?: FunOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  joy: <T = FragmentableArray<Joy>>(
    args?: {
      where?: JoyWhereInput;
      orderBy?: JoyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HopeSubscription
  extends Promise<AsyncIterator<Hope>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  salvation: <T = Promise<AsyncIterator<SalvationSubscription>>>(
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fun: <T = Promise<AsyncIterator<FunSubscription>>>(
    args?: {
      where?: FunWhereInput;
      orderBy?: FunOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  joy: <T = Promise<AsyncIterator<JoySubscription>>>(
    args?: {
      where?: JoyWhereInput;
      orderBy?: JoyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface VictimPreviousValues {
  id: ID_Output;
}

export interface VictimPreviousValuesPromise
  extends Promise<VictimPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface VictimPreviousValuesSubscription
  extends Promise<AsyncIterator<VictimPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface GashConnection {
  pageInfo: PageInfo;
  edges: GashEdge[];
}

export interface GashConnectionPromise
  extends Promise<GashConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GashEdge>>() => T;
  aggregate: <T = AggregateGashPromise>() => T;
}

export interface GashConnectionSubscription
  extends Promise<AsyncIterator<GashConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GashEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGashSubscription>() => T;
}

export interface AcceptanceConnection {
  pageInfo: PageInfo;
  edges: AcceptanceEdge[];
}

export interface AcceptanceConnectionPromise
  extends Promise<AcceptanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AcceptanceEdge>>() => T;
  aggregate: <T = AggregateAcceptancePromise>() => T;
}

export interface AcceptanceConnectionSubscription
  extends Promise<AsyncIterator<AcceptanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AcceptanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAcceptanceSubscription>() => T;
}

export interface AggregateDelirium {
  count: Int;
}

export interface AggregateDeliriumPromise
  extends Promise<AggregateDelirium>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDeliriumSubscription
  extends Promise<AsyncIterator<AggregateDelirium>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VirtueSubscriptionPayload {
  mutation: MutationType;
  node: Virtue;
  updatedFields: String[];
  previousValues: VirtuePreviousValues;
}

export interface VirtueSubscriptionPayloadPromise
  extends Promise<VirtueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VirtuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VirtuePreviousValuesPromise>() => T;
}

export interface VirtueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VirtueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VirtueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VirtuePreviousValuesSubscription>() => T;
}

export interface CharactersEdge {
  node: Characters;
  cursor: String;
}

export interface CharactersEdgePromise
  extends Promise<CharactersEdge>,
    Fragmentable {
  node: <T = CharactersPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharactersEdgeSubscription
  extends Promise<AsyncIterator<CharactersEdge>>,
    Fragmentable {
  node: <T = CharactersSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VirtuePreviousValues {
  id: ID_Output;
}

export interface VirtuePreviousValuesPromise
  extends Promise<VirtuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface VirtuePreviousValuesSubscription
  extends Promise<AsyncIterator<VirtuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SternumConnection {
  pageInfo: PageInfo;
  edges: SternumEdge[];
}

export interface SternumConnectionPromise
  extends Promise<SternumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SternumEdge>>() => T;
  aggregate: <T = AggregateSternumPromise>() => T;
}

export interface SternumConnectionSubscription
  extends Promise<AsyncIterator<SternumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SternumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSternumSubscription>() => T;
}

export interface Acceptance {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface AcceptancePromise extends Promise<Acceptance>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface AcceptanceSubscription
  extends Promise<AsyncIterator<Acceptance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ObsessionConnection {
  pageInfo: PageInfo;
  edges: ObsessionEdge[];
}

export interface ObsessionConnectionPromise
  extends Promise<ObsessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ObsessionEdge>>() => T;
  aggregate: <T = AggregateObsessionPromise>() => T;
}

export interface ObsessionConnectionSubscription
  extends Promise<AsyncIterator<ObsessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ObsessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateObsessionSubscription>() => T;
}

export interface VolunteerSubscriptionPayload {
  mutation: MutationType;
  node: Volunteer;
  updatedFields: String[];
  previousValues: VolunteerPreviousValues;
}

export interface VolunteerSubscriptionPayloadPromise
  extends Promise<VolunteerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VolunteerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VolunteerPreviousValuesPromise>() => T;
}

export interface VolunteerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VolunteerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VolunteerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VolunteerPreviousValuesSubscription>() => T;
}

export interface GutEdge {
  node: Gut;
  cursor: String;
}

export interface GutEdgePromise extends Promise<GutEdge>, Fragmentable {
  node: <T = GutPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GutEdgeSubscription
  extends Promise<AsyncIterator<GutEdge>>,
    Fragmentable {
  node: <T = GutSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCourage {
  count: Int;
}

export interface AggregateCouragePromise
  extends Promise<AggregateCourage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourageSubscription
  extends Promise<AsyncIterator<AggregateCourage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VulnerabilityPreviousValues {
  id: ID_Output;
  character: String;
  thought: String;
  source: String;
  process: String;
  path: String;
  feeling: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface VulnerabilityPreviousValuesPromise
  extends Promise<VulnerabilityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<String>;
  thought: () => Promise<String>;
  source: () => Promise<String>;
  process: () => Promise<String>;
  path: () => Promise<String>;
  feeling: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface VulnerabilityPreviousValuesSubscription
  extends Promise<AsyncIterator<VulnerabilityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<String>>;
  thought: () => Promise<AsyncIterator<String>>;
  source: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  feeling: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VulnerabilitySubscriptionPayload {
  mutation: MutationType;
  node: Vulnerability;
  updatedFields: String[];
  previousValues: VulnerabilityPreviousValues;
}

export interface VulnerabilitySubscriptionPayloadPromise
  extends Promise<VulnerabilitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VulnerabilityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VulnerabilityPreviousValuesPromise>() => T;
}

export interface VulnerabilitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VulnerabilitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VulnerabilitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VulnerabilityPreviousValuesSubscription>() => T;
}

export interface WallPreviousValues {
  id: ID_Output;
}

export interface WallPreviousValuesPromise
  extends Promise<WallPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface WallPreviousValuesSubscription
  extends Promise<AsyncIterator<WallPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface VolunteerPreviousValues {
  id: ID_Output;
}

export interface VolunteerPreviousValuesPromise
  extends Promise<VolunteerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface VolunteerPreviousValuesSubscription
  extends Promise<AsyncIterator<VolunteerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateVictim {
  count: Int;
}

export interface AggregateVictimPromise
  extends Promise<AggregateVictim>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVictimSubscription
  extends Promise<AsyncIterator<AggregateVictim>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExperienceEdge {
  node: Experience;
  cursor: String;
}

export interface ExperienceEdgePromise
  extends Promise<ExperienceEdge>,
    Fragmentable {
  node: <T = ExperiencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceEdgeSubscription
  extends Promise<AsyncIterator<ExperienceEdge>>,
    Fragmentable {
  node: <T = ExperienceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInfection {
  count: Int;
}

export interface AggregateInfectionPromise
  extends Promise<AggregateInfection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInfectionSubscription
  extends Promise<AsyncIterator<AggregateInfection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSarcasm {
  count: Int;
}

export interface AggregateSarcasmPromise
  extends Promise<AggregateSarcasm>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSarcasmSubscription
  extends Promise<AsyncIterator<AggregateSarcasm>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Has",
    embedded: false
  },
  {
    name: "Congregant",
    embedded: false
  },
  {
    name: "Genie",
    embedded: false
  },
  {
    name: "Guardian",
    embedded: false
  },
  {
    name: "Martyr",
    embedded: false
  },
  {
    name: "Paladin",
    embedded: false
  },
  {
    name: "Seeker",
    embedded: false
  },
  {
    name: "Self",
    embedded: false
  },
  {
    name: "Smith",
    embedded: false
  },
  {
    name: "Summoner",
    embedded: false
  },
  {
    name: "Victim",
    embedded: false
  },
  {
    name: "Volunteer",
    embedded: false
  },
  {
    name: "Act",
    embedded: false
  },
  {
    name: "Affliction",
    embedded: false
  },
  {
    name: "Body",
    embedded: false
  },
  {
    name: "Construct",
    embedded: false
  },
  {
    name: "Oath",
    embedded: false
  },
  {
    name: "Shield",
    embedded: false
  },
  {
    name: "Stigmata",
    embedded: false
  },
  {
    name: "Virtue",
    embedded: false
  },
  {
    name: "Wish",
    embedded: false
  },
  {
    name: "Brain",
    embedded: false
  },
  {
    name: "Campaign",
    embedded: false
  },
  {
    name: "Confusion",
    embedded: false
  },
  {
    name: "Cross",
    embedded: false
  },
  {
    name: "Crown",
    embedded: false
  },
  {
    name: "Crusade",
    embedded: false
  },
  {
    name: "Delirium",
    embedded: false
  },
  {
    name: "Denial",
    embedded: false
  },
  {
    name: "Dream",
    embedded: false
  },
  {
    name: "Face",
    embedded: false
  },
  {
    name: "Gash",
    embedded: false
  },
  {
    name: "Gate",
    embedded: false
  },
  {
    name: "Gut",
    embedded: false
  },
  {
    name: "Heart",
    embedded: false
  },
  {
    name: "Infection",
    embedded: false
  },
  {
    name: "Love",
    embedded: false
  },
  {
    name: "Mind",
    embedded: false
  },
  {
    name: "Mouth",
    embedded: false
  },
  {
    name: "Nail",
    embedded: false
  },
  {
    name: "Nightmare",
    embedded: false
  },
  {
    name: "Pledge",
    embedded: false
  },
  {
    name: "Sacrifice",
    embedded: false
  },
  {
    name: "Sarcasm",
    embedded: false
  },
  {
    name: "Scar",
    embedded: false
  },
  {
    name: "Service",
    embedded: false
  },
  {
    name: "Silence",
    embedded: false
  },
  {
    name: "Skin",
    embedded: false
  },
  {
    name: "Soul",
    embedded: false
  },
  {
    name: "Sternum",
    embedded: false
  },
  {
    name: "Support",
    embedded: false
  },
  {
    name: "Tower",
    embedded: false
  },
  {
    name: "Tremor",
    embedded: false
  },
  {
    name: "Wall",
    embedded: false
  },
  {
    name: "Defect",
    embedded: false
  },
  {
    name: "Discontent",
    embedded: false
  },
  {
    name: "Resentment",
    embedded: false
  },
  {
    name: "Obsession",
    embedded: false
  },
  {
    name: "Experience",
    embedded: false
  },
  {
    name: "Strength",
    embedded: false
  },
  {
    name: "Hope",
    embedded: false
  },
  {
    name: "Trauma",
    embedded: false
  },
  {
    name: "Toxicity",
    embedded: false
  },
  {
    name: "Suffering",
    embedded: false
  },
  {
    name: "Anger",
    embedded: false
  },
  {
    name: "SelfPity",
    embedded: false
  },
  {
    name: "Fear",
    embedded: false
  },
  {
    name: "Pride",
    embedded: false
  },
  {
    name: "Compassion",
    embedded: false
  },
  {
    name: "Courage",
    embedded: false
  },
  {
    name: "Acceptance",
    embedded: false
  },
  {
    name: "Vulnerability",
    embedded: false
  },
  {
    name: "Gratitude",
    embedded: false
  },
  {
    name: "Armor",
    embedded: false
  },
  {
    name: "Boundary",
    embedded: false
  },
  {
    name: "Loyalty",
    embedded: false
  },
  {
    name: "Honor",
    embedded: false
  },
  {
    name: "Salvation",
    embedded: false
  },
  {
    name: "Fun",
    embedded: false
  },
  {
    name: "Joy",
    embedded: false
  },
  {
    name: "Irritability",
    embedded: false
  },
  {
    name: "Impatience",
    embedded: false
  },
  {
    name: "Feeling",
    embedded: false
  },
  {
    name: "Path",
    embedded: false
  },
  {
    name: "Process",
    embedded: false
  },
  {
    name: "Prayer",
    embedded: false
  },
  {
    name: "Characters",
    embedded: false
  },
  {
    name: "Inventory",
    embedded: false
  },
  {
    name: "HigherPower",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
