// Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  acceptance: (where?: AcceptanceWhereInput) => Promise<boolean>;
  anger: (where?: AngerWhereInput) => Promise<boolean>;
  armor: (where?: ArmorWhereInput) => Promise<boolean>;
  boundary: (where?: BoundaryWhereInput) => Promise<boolean>;
  compassion: (where?: CompassionWhereInput) => Promise<boolean>;
  courage: (where?: CourageWhereInput) => Promise<boolean>;
  defect: (where?: DefectWhereInput) => Promise<boolean>;
  experience: (where?: ExperienceWhereInput) => Promise<boolean>;
  fear: (where?: FearWhereInput) => Promise<boolean>;
  higherPower: (where?: HigherPowerWhereInput) => Promise<boolean>;
  honor: (where?: HonorWhereInput) => Promise<boolean>;
  hope: (where?: HopeWhereInput) => Promise<boolean>;
  inventory: (where?: InventoryWhereInput) => Promise<boolean>;
  loyalty: (where?: LoyaltyWhereInput) => Promise<boolean>;
  obsession: (where?: ObsessionWhereInput) => Promise<boolean>;
  pride: (where?: PrideWhereInput) => Promise<boolean>;
  resentment: (where?: ResentmentWhereInput) => Promise<boolean>;
  salvation: (where?: SalvationWhereInput) => Promise<boolean>;
  selfPity: (where?: SelfPityWhereInput) => Promise<boolean>;
  strength: (where?: StrengthWhereInput) => Promise<boolean>;
  suffering: (where?: SufferingWhereInput) => Promise<boolean>;
  toxicity: (where?: ToxicityWhereInput) => Promise<boolean>;
  trauma: (where?: TraumaWhereInput) => Promise<boolean>;
  vulnerability: (where?: VulnerabilityWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  acceptance: (where: AcceptanceWhereUniqueInput) => AcceptancePromise;
  acceptances: (
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Acceptance>;
  acceptancesConnection: (
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AcceptanceConnectionPromise;
  anger: (where: AngerWhereUniqueInput) => AngerPromise;
  angers: (
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Anger>;
  angersConnection: (
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AngerConnectionPromise;
  armor: (where: ArmorWhereUniqueInput) => ArmorPromise;
  armors: (
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Armor>;
  armorsConnection: (
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ArmorConnectionPromise;
  boundary: (where: BoundaryWhereUniqueInput) => BoundaryPromise;
  boundaries: (
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Boundary>;
  boundariesConnection: (
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => BoundaryConnectionPromise;
  compassion: (where: CompassionWhereUniqueInput) => CompassionPromise;
  compassions: (
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Compassion>;
  compassionsConnection: (
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompassionConnectionPromise;
  courage: (where: CourageWhereUniqueInput) => CouragePromise;
  courages: (
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Courage>;
  couragesConnection: (
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CourageConnectionPromise;
  defects: (
    args?: {
      where?: DefectWhereInput;
      orderBy?: DefectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Defect>;
  defectsConnection: (
    args?: {
      where?: DefectWhereInput;
      orderBy?: DefectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DefectConnectionPromise;
  experiences: (
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Experience>;
  experiencesConnection: (
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExperienceConnectionPromise;
  fear: (where: FearWhereUniqueInput) => FearPromise;
  fears: (
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Fear>;
  fearsConnection: (
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FearConnectionPromise;
  higherPower: (where: HigherPowerWhereUniqueInput) => HigherPowerPromise;
  higherPowers: (
    args?: {
      where?: HigherPowerWhereInput;
      orderBy?: HigherPowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HigherPower>;
  higherPowersConnection: (
    args?: {
      where?: HigherPowerWhereInput;
      orderBy?: HigherPowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HigherPowerConnectionPromise;
  honor: (where: HonorWhereUniqueInput) => HonorPromise;
  honors: (
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Honor>;
  honorsConnection: (
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HonorConnectionPromise;
  hopes: (
    args?: {
      where?: HopeWhereInput;
      orderBy?: HopeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Hope>;
  hopesConnection: (
    args?: {
      where?: HopeWhereInput;
      orderBy?: HopeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HopeConnectionPromise;
  inventories: (
    args?: {
      where?: InventoryWhereInput;
      orderBy?: InventoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Inventory>;
  inventoriesConnection: (
    args?: {
      where?: InventoryWhereInput;
      orderBy?: InventoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InventoryConnectionPromise;
  loyalty: (where: LoyaltyWhereUniqueInput) => LoyaltyPromise;
  loyalties: (
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Loyalty>;
  loyaltiesConnection: (
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LoyaltyConnectionPromise;
  obsessions: (
    args?: {
      where?: ObsessionWhereInput;
      orderBy?: ObsessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Obsession>;
  obsessionsConnection: (
    args?: {
      where?: ObsessionWhereInput;
      orderBy?: ObsessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ObsessionConnectionPromise;
  pride: (where: PrideWhereUniqueInput) => PridePromise;
  prides: (
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Pride>;
  pridesConnection: (
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PrideConnectionPromise;
  resentments: (
    args?: {
      where?: ResentmentWhereInput;
      orderBy?: ResentmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Resentment>;
  resentmentsConnection: (
    args?: {
      where?: ResentmentWhereInput;
      orderBy?: ResentmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ResentmentConnectionPromise;
  salvation: (where: SalvationWhereUniqueInput) => SalvationPromise;
  salvations: (
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Salvation>;
  salvationsConnection: (
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SalvationConnectionPromise;
  selfPity: (where: SelfPityWhereUniqueInput) => SelfPityPromise;
  selfPities: (
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SelfPity>;
  selfPitiesConnection: (
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SelfPityConnectionPromise;
  strengths: (
    args?: {
      where?: StrengthWhereInput;
      orderBy?: StrengthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Strength>;
  strengthsConnection: (
    args?: {
      where?: StrengthWhereInput;
      orderBy?: StrengthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => StrengthConnectionPromise;
  suffering: (where: SufferingWhereUniqueInput) => SufferingPromise;
  sufferings: (
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Suffering>;
  sufferingsConnection: (
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SufferingConnectionPromise;
  toxicity: (where: ToxicityWhereUniqueInput) => ToxicityPromise;
  toxicities: (
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Toxicity>;
  toxicitiesConnection: (
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ToxicityConnectionPromise;
  trauma: (where: TraumaWhereUniqueInput) => TraumaPromise;
  traumas: (
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Trauma>;
  traumasConnection: (
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TraumaConnectionPromise;
  vulnerability: (where: VulnerabilityWhereUniqueInput) => VulnerabilityPromise;
  vulnerabilities: (
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Vulnerability>;
  vulnerabilitiesConnection: (
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => VulnerabilityConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAcceptance: (data: AcceptanceCreateInput) => AcceptancePromise;
  updateAcceptance: (
    args: { data: AcceptanceUpdateInput; where: AcceptanceWhereUniqueInput }
  ) => AcceptancePromise;
  updateManyAcceptances: (
    args: {
      data: AcceptanceUpdateManyMutationInput;
      where?: AcceptanceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAcceptance: (
    args: {
      where: AcceptanceWhereUniqueInput;
      create: AcceptanceCreateInput;
      update: AcceptanceUpdateInput;
    }
  ) => AcceptancePromise;
  deleteAcceptance: (where: AcceptanceWhereUniqueInput) => AcceptancePromise;
  deleteManyAcceptances: (where?: AcceptanceWhereInput) => BatchPayloadPromise;
  createAnger: (data: AngerCreateInput) => AngerPromise;
  updateAnger: (
    args: { data: AngerUpdateInput; where: AngerWhereUniqueInput }
  ) => AngerPromise;
  updateManyAngers: (
    args: { data: AngerUpdateManyMutationInput; where?: AngerWhereInput }
  ) => BatchPayloadPromise;
  upsertAnger: (
    args: {
      where: AngerWhereUniqueInput;
      create: AngerCreateInput;
      update: AngerUpdateInput;
    }
  ) => AngerPromise;
  deleteAnger: (where: AngerWhereUniqueInput) => AngerPromise;
  deleteManyAngers: (where?: AngerWhereInput) => BatchPayloadPromise;
  createArmor: (data: ArmorCreateInput) => ArmorPromise;
  updateArmor: (
    args: { data: ArmorUpdateInput; where: ArmorWhereUniqueInput }
  ) => ArmorPromise;
  updateManyArmors: (
    args: { data: ArmorUpdateManyMutationInput; where?: ArmorWhereInput }
  ) => BatchPayloadPromise;
  upsertArmor: (
    args: {
      where: ArmorWhereUniqueInput;
      create: ArmorCreateInput;
      update: ArmorUpdateInput;
    }
  ) => ArmorPromise;
  deleteArmor: (where: ArmorWhereUniqueInput) => ArmorPromise;
  deleteManyArmors: (where?: ArmorWhereInput) => BatchPayloadPromise;
  createBoundary: (data: BoundaryCreateInput) => BoundaryPromise;
  updateBoundary: (
    args: { data: BoundaryUpdateInput; where: BoundaryWhereUniqueInput }
  ) => BoundaryPromise;
  updateManyBoundaries: (
    args: { data: BoundaryUpdateManyMutationInput; where?: BoundaryWhereInput }
  ) => BatchPayloadPromise;
  upsertBoundary: (
    args: {
      where: BoundaryWhereUniqueInput;
      create: BoundaryCreateInput;
      update: BoundaryUpdateInput;
    }
  ) => BoundaryPromise;
  deleteBoundary: (where: BoundaryWhereUniqueInput) => BoundaryPromise;
  deleteManyBoundaries: (where?: BoundaryWhereInput) => BatchPayloadPromise;
  createCompassion: (data: CompassionCreateInput) => CompassionPromise;
  updateCompassion: (
    args: { data: CompassionUpdateInput; where: CompassionWhereUniqueInput }
  ) => CompassionPromise;
  updateManyCompassions: (
    args: {
      data: CompassionUpdateManyMutationInput;
      where?: CompassionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCompassion: (
    args: {
      where: CompassionWhereUniqueInput;
      create: CompassionCreateInput;
      update: CompassionUpdateInput;
    }
  ) => CompassionPromise;
  deleteCompassion: (where: CompassionWhereUniqueInput) => CompassionPromise;
  deleteManyCompassions: (where?: CompassionWhereInput) => BatchPayloadPromise;
  createCourage: (data: CourageCreateInput) => CouragePromise;
  updateCourage: (
    args: { data: CourageUpdateInput; where: CourageWhereUniqueInput }
  ) => CouragePromise;
  updateManyCourages: (
    args: { data: CourageUpdateManyMutationInput; where?: CourageWhereInput }
  ) => BatchPayloadPromise;
  upsertCourage: (
    args: {
      where: CourageWhereUniqueInput;
      create: CourageCreateInput;
      update: CourageUpdateInput;
    }
  ) => CouragePromise;
  deleteCourage: (where: CourageWhereUniqueInput) => CouragePromise;
  deleteManyCourages: (where?: CourageWhereInput) => BatchPayloadPromise;
  createDefect: (data: DefectCreateInput) => DefectPromise;
  deleteManyDefects: (where?: DefectWhereInput) => BatchPayloadPromise;
  createExperience: (data: ExperienceCreateInput) => ExperiencePromise;
  deleteManyExperiences: (where?: ExperienceWhereInput) => BatchPayloadPromise;
  createFear: (data: FearCreateInput) => FearPromise;
  updateFear: (
    args: { data: FearUpdateInput; where: FearWhereUniqueInput }
  ) => FearPromise;
  updateManyFears: (
    args: { data: FearUpdateManyMutationInput; where?: FearWhereInput }
  ) => BatchPayloadPromise;
  upsertFear: (
    args: {
      where: FearWhereUniqueInput;
      create: FearCreateInput;
      update: FearUpdateInput;
    }
  ) => FearPromise;
  deleteFear: (where: FearWhereUniqueInput) => FearPromise;
  deleteManyFears: (where?: FearWhereInput) => BatchPayloadPromise;
  createHigherPower: (data: HigherPowerCreateInput) => HigherPowerPromise;
  updateHigherPower: (
    args: { data: HigherPowerUpdateInput; where: HigherPowerWhereUniqueInput }
  ) => HigherPowerPromise;
  upsertHigherPower: (
    args: {
      where: HigherPowerWhereUniqueInput;
      create: HigherPowerCreateInput;
      update: HigherPowerUpdateInput;
    }
  ) => HigherPowerPromise;
  deleteHigherPower: (where: HigherPowerWhereUniqueInput) => HigherPowerPromise;
  deleteManyHigherPowers: (
    where?: HigherPowerWhereInput
  ) => BatchPayloadPromise;
  createHonor: (data: HonorCreateInput) => HonorPromise;
  updateHonor: (
    args: { data: HonorUpdateInput; where: HonorWhereUniqueInput }
  ) => HonorPromise;
  updateManyHonors: (
    args: { data: HonorUpdateManyMutationInput; where?: HonorWhereInput }
  ) => BatchPayloadPromise;
  upsertHonor: (
    args: {
      where: HonorWhereUniqueInput;
      create: HonorCreateInput;
      update: HonorUpdateInput;
    }
  ) => HonorPromise;
  deleteHonor: (where: HonorWhereUniqueInput) => HonorPromise;
  deleteManyHonors: (where?: HonorWhereInput) => BatchPayloadPromise;
  createHope: (data: HopeCreateInput) => HopePromise;
  deleteManyHopes: (where?: HopeWhereInput) => BatchPayloadPromise;
  createInventory: (data: InventoryCreateInput) => InventoryPromise;
  deleteManyInventories: (where?: InventoryWhereInput) => BatchPayloadPromise;
  createLoyalty: (data: LoyaltyCreateInput) => LoyaltyPromise;
  updateLoyalty: (
    args: { data: LoyaltyUpdateInput; where: LoyaltyWhereUniqueInput }
  ) => LoyaltyPromise;
  updateManyLoyalties: (
    args: { data: LoyaltyUpdateManyMutationInput; where?: LoyaltyWhereInput }
  ) => BatchPayloadPromise;
  upsertLoyalty: (
    args: {
      where: LoyaltyWhereUniqueInput;
      create: LoyaltyCreateInput;
      update: LoyaltyUpdateInput;
    }
  ) => LoyaltyPromise;
  deleteLoyalty: (where: LoyaltyWhereUniqueInput) => LoyaltyPromise;
  deleteManyLoyalties: (where?: LoyaltyWhereInput) => BatchPayloadPromise;
  createObsession: (data: ObsessionCreateInput) => ObsessionPromise;
  deleteManyObsessions: (where?: ObsessionWhereInput) => BatchPayloadPromise;
  createPride: (data: PrideCreateInput) => PridePromise;
  updatePride: (
    args: { data: PrideUpdateInput; where: PrideWhereUniqueInput }
  ) => PridePromise;
  updateManyPrides: (
    args: { data: PrideUpdateManyMutationInput; where?: PrideWhereInput }
  ) => BatchPayloadPromise;
  upsertPride: (
    args: {
      where: PrideWhereUniqueInput;
      create: PrideCreateInput;
      update: PrideUpdateInput;
    }
  ) => PridePromise;
  deletePride: (where: PrideWhereUniqueInput) => PridePromise;
  deleteManyPrides: (where?: PrideWhereInput) => BatchPayloadPromise;
  createResentment: (data: ResentmentCreateInput) => ResentmentPromise;
  deleteManyResentments: (where?: ResentmentWhereInput) => BatchPayloadPromise;
  createSalvation: (data: SalvationCreateInput) => SalvationPromise;
  updateSalvation: (
    args: { data: SalvationUpdateInput; where: SalvationWhereUniqueInput }
  ) => SalvationPromise;
  updateManySalvations: (
    args: {
      data: SalvationUpdateManyMutationInput;
      where?: SalvationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSalvation: (
    args: {
      where: SalvationWhereUniqueInput;
      create: SalvationCreateInput;
      update: SalvationUpdateInput;
    }
  ) => SalvationPromise;
  deleteSalvation: (where: SalvationWhereUniqueInput) => SalvationPromise;
  deleteManySalvations: (where?: SalvationWhereInput) => BatchPayloadPromise;
  createSelfPity: (data: SelfPityCreateInput) => SelfPityPromise;
  updateSelfPity: (
    args: { data: SelfPityUpdateInput; where: SelfPityWhereUniqueInput }
  ) => SelfPityPromise;
  updateManySelfPities: (
    args: { data: SelfPityUpdateManyMutationInput; where?: SelfPityWhereInput }
  ) => BatchPayloadPromise;
  upsertSelfPity: (
    args: {
      where: SelfPityWhereUniqueInput;
      create: SelfPityCreateInput;
      update: SelfPityUpdateInput;
    }
  ) => SelfPityPromise;
  deleteSelfPity: (where: SelfPityWhereUniqueInput) => SelfPityPromise;
  deleteManySelfPities: (where?: SelfPityWhereInput) => BatchPayloadPromise;
  createStrength: (data: StrengthCreateInput) => StrengthPromise;
  deleteManyStrengths: (where?: StrengthWhereInput) => BatchPayloadPromise;
  createSuffering: (data: SufferingCreateInput) => SufferingPromise;
  updateSuffering: (
    args: { data: SufferingUpdateInput; where: SufferingWhereUniqueInput }
  ) => SufferingPromise;
  updateManySufferings: (
    args: {
      data: SufferingUpdateManyMutationInput;
      where?: SufferingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSuffering: (
    args: {
      where: SufferingWhereUniqueInput;
      create: SufferingCreateInput;
      update: SufferingUpdateInput;
    }
  ) => SufferingPromise;
  deleteSuffering: (where: SufferingWhereUniqueInput) => SufferingPromise;
  deleteManySufferings: (where?: SufferingWhereInput) => BatchPayloadPromise;
  createToxicity: (data: ToxicityCreateInput) => ToxicityPromise;
  updateToxicity: (
    args: { data: ToxicityUpdateInput; where: ToxicityWhereUniqueInput }
  ) => ToxicityPromise;
  updateManyToxicities: (
    args: { data: ToxicityUpdateManyMutationInput; where?: ToxicityWhereInput }
  ) => BatchPayloadPromise;
  upsertToxicity: (
    args: {
      where: ToxicityWhereUniqueInput;
      create: ToxicityCreateInput;
      update: ToxicityUpdateInput;
    }
  ) => ToxicityPromise;
  deleteToxicity: (where: ToxicityWhereUniqueInput) => ToxicityPromise;
  deleteManyToxicities: (where?: ToxicityWhereInput) => BatchPayloadPromise;
  createTrauma: (data: TraumaCreateInput) => TraumaPromise;
  updateTrauma: (
    args: { data: TraumaUpdateInput; where: TraumaWhereUniqueInput }
  ) => TraumaPromise;
  updateManyTraumas: (
    args: { data: TraumaUpdateManyMutationInput; where?: TraumaWhereInput }
  ) => BatchPayloadPromise;
  upsertTrauma: (
    args: {
      where: TraumaWhereUniqueInput;
      create: TraumaCreateInput;
      update: TraumaUpdateInput;
    }
  ) => TraumaPromise;
  deleteTrauma: (where: TraumaWhereUniqueInput) => TraumaPromise;
  deleteManyTraumas: (where?: TraumaWhereInput) => BatchPayloadPromise;
  createVulnerability: (data: VulnerabilityCreateInput) => VulnerabilityPromise;
  updateVulnerability: (
    args: {
      data: VulnerabilityUpdateInput;
      where: VulnerabilityWhereUniqueInput;
    }
  ) => VulnerabilityPromise;
  updateManyVulnerabilities: (
    args: {
      data: VulnerabilityUpdateManyMutationInput;
      where?: VulnerabilityWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertVulnerability: (
    args: {
      where: VulnerabilityWhereUniqueInput;
      create: VulnerabilityCreateInput;
      update: VulnerabilityUpdateInput;
    }
  ) => VulnerabilityPromise;
  deleteVulnerability: (
    where: VulnerabilityWhereUniqueInput
  ) => VulnerabilityPromise;
  deleteManyVulnerabilities: (
    where?: VulnerabilityWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  acceptance: (
    where?: AcceptanceSubscriptionWhereInput
  ) => AcceptanceSubscriptionPayloadSubscription;
  anger: (
    where?: AngerSubscriptionWhereInput
  ) => AngerSubscriptionPayloadSubscription;
  armor: (
    where?: ArmorSubscriptionWhereInput
  ) => ArmorSubscriptionPayloadSubscription;
  boundary: (
    where?: BoundarySubscriptionWhereInput
  ) => BoundarySubscriptionPayloadSubscription;
  compassion: (
    where?: CompassionSubscriptionWhereInput
  ) => CompassionSubscriptionPayloadSubscription;
  courage: (
    where?: CourageSubscriptionWhereInput
  ) => CourageSubscriptionPayloadSubscription;
  defect: (
    where?: DefectSubscriptionWhereInput
  ) => DefectSubscriptionPayloadSubscription;
  experience: (
    where?: ExperienceSubscriptionWhereInput
  ) => ExperienceSubscriptionPayloadSubscription;
  fear: (
    where?: FearSubscriptionWhereInput
  ) => FearSubscriptionPayloadSubscription;
  higherPower: (
    where?: HigherPowerSubscriptionWhereInput
  ) => HigherPowerSubscriptionPayloadSubscription;
  honor: (
    where?: HonorSubscriptionWhereInput
  ) => HonorSubscriptionPayloadSubscription;
  hope: (
    where?: HopeSubscriptionWhereInput
  ) => HopeSubscriptionPayloadSubscription;
  inventory: (
    where?: InventorySubscriptionWhereInput
  ) => InventorySubscriptionPayloadSubscription;
  loyalty: (
    where?: LoyaltySubscriptionWhereInput
  ) => LoyaltySubscriptionPayloadSubscription;
  obsession: (
    where?: ObsessionSubscriptionWhereInput
  ) => ObsessionSubscriptionPayloadSubscription;
  pride: (
    where?: PrideSubscriptionWhereInput
  ) => PrideSubscriptionPayloadSubscription;
  resentment: (
    where?: ResentmentSubscriptionWhereInput
  ) => ResentmentSubscriptionPayloadSubscription;
  salvation: (
    where?: SalvationSubscriptionWhereInput
  ) => SalvationSubscriptionPayloadSubscription;
  selfPity: (
    where?: SelfPitySubscriptionWhereInput
  ) => SelfPitySubscriptionPayloadSubscription;
  strength: (
    where?: StrengthSubscriptionWhereInput
  ) => StrengthSubscriptionPayloadSubscription;
  suffering: (
    where?: SufferingSubscriptionWhereInput
  ) => SufferingSubscriptionPayloadSubscription;
  toxicity: (
    where?: ToxicitySubscriptionWhereInput
  ) => ToxicitySubscriptionPayloadSubscription;
  trauma: (
    where?: TraumaSubscriptionWhereInput
  ) => TraumaSubscriptionPayloadSubscription;
  vulnerability: (
    where?: VulnerabilitySubscriptionWhereInput
  ) => VulnerabilitySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type FearOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type BoundaryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type AngerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type HigherPowerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VulnerabilityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type AcceptanceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type ExperienceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type StrengthOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SufferingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type LoyaltyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type ToxicityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type PrideOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type TraumaOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type ResentmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DefectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SalvationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type CompassionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CourageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type ArmorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type HopeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InventoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SelfPityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type ObsessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HonorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "attribute_ASC"
  | "attribute_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export interface ObsessionWhereInput {
  suffering_every?: SufferingWhereInput;
  suffering_some?: SufferingWhereInput;
  suffering_none?: SufferingWhereInput;
  loyalty_every?: LoyaltyWhereInput;
  loyalty_some?: LoyaltyWhereInput;
  loyalty_none?: LoyaltyWhereInput;
  honor_every?: HonorWhereInput;
  honor_some?: HonorWhereInput;
  honor_none?: HonorWhereInput;
  vulnerability_every?: VulnerabilityWhereInput;
  vulnerability_some?: VulnerabilityWhereInput;
  vulnerability_none?: VulnerabilityWhereInput;
  AND?: ObsessionWhereInput[] | ObsessionWhereInput;
  OR?: ObsessionWhereInput[] | ObsessionWhereInput;
  NOT?: ObsessionWhereInput[] | ObsessionWhereInput;
}

export interface BoundaryUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SalvationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: SalvationWhereInput[] | SalvationWhereInput;
  OR?: SalvationWhereInput[] | SalvationWhereInput;
  NOT?: SalvationWhereInput[] | SalvationWhereInput;
}

export type AcceptanceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SufferingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SufferingWhereInput;
  AND?: SufferingSubscriptionWhereInput[] | SufferingSubscriptionWhereInput;
  OR?: SufferingSubscriptionWhereInput[] | SufferingSubscriptionWhereInput;
  NOT?: SufferingSubscriptionWhereInput[] | SufferingSubscriptionWhereInput;
}

export interface DefectSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DefectWhereInput;
  AND?: DefectSubscriptionWhereInput[] | DefectSubscriptionWhereInput;
  OR?: DefectSubscriptionWhereInput[] | DefectSubscriptionWhereInput;
  NOT?: DefectSubscriptionWhereInput[] | DefectSubscriptionWhereInput;
}

export interface SalvationCreateManyInput {
  create?: SalvationCreateInput[] | SalvationCreateInput;
  connect?: SalvationWhereUniqueInput[] | SalvationWhereUniqueInput;
}

export type BoundaryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AcceptanceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: AcceptanceWhereInput[] | AcceptanceWhereInput;
  OR?: AcceptanceWhereInput[] | AcceptanceWhereInput;
  NOT?: AcceptanceWhereInput[] | AcceptanceWhereInput;
}

export interface CompassionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompassionWhereInput;
  AND?: CompassionSubscriptionWhereInput[] | CompassionSubscriptionWhereInput;
  OR?: CompassionSubscriptionWhereInput[] | CompassionSubscriptionWhereInput;
  NOT?: CompassionSubscriptionWhereInput[] | CompassionSubscriptionWhereInput;
}

export interface HopeCreateInput {
  salvation?: SalvationCreateManyInput;
}

export type CompassionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HigherPowerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  inventory?: InventoryWhereInput;
  AND?: HigherPowerWhereInput[] | HigherPowerWhereInput;
  OR?: HigherPowerWhereInput[] | HigherPowerWhereInput;
  NOT?: HigherPowerWhereInput[] | HigherPowerWhereInput;
}

export interface CompassionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: CompassionWhereInput[] | CompassionWhereInput;
  OR?: CompassionWhereInput[] | CompassionWhereInput;
  NOT?: CompassionWhereInput[] | CompassionWhereInput;
}

export interface InventoryWhereInput {
  defect_every?: DefectWhereInput;
  defect_some?: DefectWhereInput;
  defect_none?: DefectWhereInput;
  resentment_every?: ResentmentWhereInput;
  resentment_some?: ResentmentWhereInput;
  resentment_none?: ResentmentWhereInput;
  obsession_every?: ObsessionWhereInput;
  obsession_some?: ObsessionWhereInput;
  obsession_none?: ObsessionWhereInput;
  experience_every?: ExperienceWhereInput;
  experience_some?: ExperienceWhereInput;
  experience_none?: ExperienceWhereInput;
  strength_every?: StrengthWhereInput;
  strength_some?: StrengthWhereInput;
  strength_none?: StrengthWhereInput;
  hope_every?: HopeWhereInput;
  hope_some?: HopeWhereInput;
  hope_none?: HopeWhereInput;
  AND?: InventoryWhereInput[] | InventoryWhereInput;
  OR?: InventoryWhereInput[] | InventoryWhereInput;
  NOT?: InventoryWhereInput[] | InventoryWhereInput;
}

export interface AngerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AngerWhereInput;
  AND?: AngerSubscriptionWhereInput[] | AngerSubscriptionWhereInput;
  OR?: AngerSubscriptionWhereInput[] | AngerSubscriptionWhereInput;
  NOT?: AngerSubscriptionWhereInput[] | AngerSubscriptionWhereInput;
}

export interface ToxicitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ToxicityWhereInput;
  AND?: ToxicitySubscriptionWhereInput[] | ToxicitySubscriptionWhereInput;
  OR?: ToxicitySubscriptionWhereInput[] | ToxicitySubscriptionWhereInput;
  NOT?: ToxicitySubscriptionWhereInput[] | ToxicitySubscriptionWhereInput;
}

export interface AcceptanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AcceptanceWhereInput;
  AND?: AcceptanceSubscriptionWhereInput[] | AcceptanceSubscriptionWhereInput;
  OR?: AcceptanceSubscriptionWhereInput[] | AcceptanceSubscriptionWhereInput;
  NOT?: AcceptanceSubscriptionWhereInput[] | AcceptanceSubscriptionWhereInput;
}

export interface HopeCreateManyInput {
  create?: HopeCreateInput[] | HopeCreateInput;
}

export interface VulnerabilityUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface BoundaryCreateManyInput {
  create?: BoundaryCreateInput[] | BoundaryCreateInput;
  connect?: BoundaryWhereUniqueInput[] | BoundaryWhereUniqueInput;
}

export interface HigherPowerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HigherPowerWhereInput;
  AND?: HigherPowerSubscriptionWhereInput[] | HigherPowerSubscriptionWhereInput;
  OR?: HigherPowerSubscriptionWhereInput[] | HigherPowerSubscriptionWhereInput;
  NOT?: HigherPowerSubscriptionWhereInput[] | HigherPowerSubscriptionWhereInput;
}

export interface ArmorCreateManyInput {
  create?: ArmorCreateInput[] | ArmorCreateInput;
  connect?: ArmorWhereUniqueInput[] | ArmorWhereUniqueInput;
}

export interface TraumaUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type HonorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface DefectWhereInput {
  trauma_every?: TraumaWhereInput;
  trauma_some?: TraumaWhereInput;
  trauma_none?: TraumaWhereInput;
  toxicity_every?: ToxicityWhereInput;
  toxicity_some?: ToxicityWhereInput;
  toxicity_none?: ToxicityWhereInput;
  suffering_every?: SufferingWhereInput;
  suffering_some?: SufferingWhereInput;
  suffering_none?: SufferingWhereInput;
  AND?: DefectWhereInput[] | DefectWhereInput;
  OR?: DefectWhereInput[] | DefectWhereInput;
  NOT?: DefectWhereInput[] | DefectWhereInput;
}

export interface StrengthCreateInput {
  armor?: ArmorCreateManyInput;
  boundary?: BoundaryCreateManyInput;
  loyalty?: LoyaltyCreateManyInput;
  honor?: HonorCreateManyInput;
}

export interface ToxicityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: ToxicityWhereInput[] | ToxicityWhereInput;
  OR?: ToxicityWhereInput[] | ToxicityWhereInput;
  NOT?: ToxicityWhereInput[] | ToxicityWhereInput;
}

export interface StrengthCreateManyInput {
  create?: StrengthCreateInput[] | StrengthCreateInput;
}

export interface ArmorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: ArmorWhereInput[] | ArmorWhereInput;
  OR?: ArmorWhereInput[] | ArmorWhereInput;
  NOT?: ArmorWhereInput[] | ArmorWhereInput;
}

export interface ExperienceCreateManyInput {
  create?: ExperienceCreateInput[] | ExperienceCreateInput;
}

export interface HonorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HonorWhereInput;
  AND?: HonorSubscriptionWhereInput[] | HonorSubscriptionWhereInput;
  OR?: HonorSubscriptionWhereInput[] | HonorSubscriptionWhereInput;
  NOT?: HonorSubscriptionWhereInput[] | HonorSubscriptionWhereInput;
}

export interface HonorCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type ArmorWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HonorCreateManyInput {
  create?: HonorCreateInput[] | HonorCreateInput;
  connect?: HonorWhereUniqueInput[] | HonorWhereUniqueInput;
}

export interface HopeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HopeWhereInput;
  AND?: HopeSubscriptionWhereInput[] | HopeSubscriptionWhereInput;
  OR?: HopeSubscriptionWhereInput[] | HopeSubscriptionWhereInput;
  NOT?: HopeSubscriptionWhereInput[] | HopeSubscriptionWhereInput;
}

export interface LoyaltyCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SelfPityUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface TraumaSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TraumaWhereInput;
  AND?: TraumaSubscriptionWhereInput[] | TraumaSubscriptionWhereInput;
  OR?: TraumaSubscriptionWhereInput[] | TraumaSubscriptionWhereInput;
  NOT?: TraumaSubscriptionWhereInput[] | TraumaSubscriptionWhereInput;
}

export interface SalvationUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface LoyaltyCreateManyInput {
  create?: LoyaltyCreateInput[] | LoyaltyCreateInput;
  connect?: LoyaltyWhereUniqueInput[] | LoyaltyWhereUniqueInput;
}

export interface VulnerabilityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: VulnerabilityWhereInput[] | VulnerabilityWhereInput;
  OR?: VulnerabilityWhereInput[] | VulnerabilityWhereInput;
  NOT?: VulnerabilityWhereInput[] | VulnerabilityWhereInput;
}

export interface ObsessionCreateInput {
  suffering?: SufferingCreateManyInput;
  loyalty?: LoyaltyCreateManyInput;
  honor?: HonorCreateManyInput;
  vulnerability?: VulnerabilityCreateManyInput;
}

export interface SalvationUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ObsessionCreateManyInput {
  create?: ObsessionCreateInput[] | ObsessionCreateInput;
}

export interface PrideUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type LoyaltyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface LoyaltyUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface PrideCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type FearWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PrideCreateManyInput {
  create?: PrideCreateInput[] | PrideCreateInput;
  connect?: PrideWhereUniqueInput[] | PrideWhereUniqueInput;
}

export interface FearWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: FearWhereInput[] | FearWhereInput;
  OR?: FearWhereInput[] | FearWhereInput;
  NOT?: FearWhereInput[] | FearWhereInput;
}

export interface FearCreateManyInput {
  create?: FearCreateInput[] | FearCreateInput;
  connect?: FearWhereUniqueInput[] | FearWhereUniqueInput;
}

export interface HonorUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SelfPityCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface HopeUpdateManyInput {
  create?: HopeCreateInput[] | HopeCreateInput;
}

export interface SelfPityCreateManyInput {
  create?: SelfPityCreateInput[] | SelfPityCreateInput;
  connect?: SelfPityWhereUniqueInput[] | SelfPityWhereUniqueInput;
}

export interface StrengthUpdateManyInput {
  create?: StrengthCreateInput[] | StrengthCreateInput;
}

export interface AngerCreateManyInput {
  create?: AngerCreateInput[] | AngerCreateInput;
  connect?: AngerWhereUniqueInput[] | AngerWhereUniqueInput;
}

export interface ResentmentWhereInput {
  anger_every?: AngerWhereInput;
  anger_some?: AngerWhereInput;
  anger_none?: AngerWhereInput;
  selfPity_every?: SelfPityWhereInput;
  selfPity_some?: SelfPityWhereInput;
  selfPity_none?: SelfPityWhereInput;
  fear_every?: FearWhereInput;
  fear_some?: FearWhereInput;
  fear_none?: FearWhereInput;
  pride_every?: PrideWhereInput;
  pride_some?: PrideWhereInput;
  pride_none?: PrideWhereInput;
  AND?: ResentmentWhereInput[] | ResentmentWhereInput;
  OR?: ResentmentWhereInput[] | ResentmentWhereInput;
  NOT?: ResentmentWhereInput[] | ResentmentWhereInput;
}

export type PrideWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PrideWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: PrideWhereInput[] | PrideWhereInput;
  OR?: PrideWhereInput[] | PrideWhereInput;
  NOT?: PrideWhereInput[] | PrideWhereInput;
}

export interface ResentmentCreateInput {
  anger?: AngerCreateManyInput;
  selfPity?: SelfPityCreateManyInput;
  fear?: FearCreateManyInput;
  pride?: PrideCreateManyInput;
}

export interface ObsessionUpdateManyInput {
  create?: ObsessionCreateInput[] | ObsessionCreateInput;
}

export interface ResentmentCreateManyInput {
  create?: ResentmentCreateInput[] | ResentmentCreateInput;
}

export interface ResentmentUpdateManyInput {
  create?: ResentmentCreateInput[] | ResentmentCreateInput;
}

export interface DefectCreateManyInput {
  create?: DefectCreateInput[] | DefectCreateInput;
}

export interface DefectUpdateManyInput {
  create?: DefectCreateInput[] | DefectCreateInput;
}

export interface InventoryCreateInput {
  defect?: DefectCreateManyInput;
  resentment?: ResentmentCreateManyInput;
  obsession?: ObsessionCreateManyInput;
  experience?: ExperienceCreateManyInput;
  strength?: StrengthCreateManyInput;
  hope?: HopeCreateManyInput;
}

export interface LoyaltyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: LoyaltyWhereInput[] | LoyaltyWhereInput;
  OR?: LoyaltyWhereInput[] | LoyaltyWhereInput;
  NOT?: LoyaltyWhereInput[] | LoyaltyWhereInput;
}

export interface InventoryCreateOneInput {
  create?: InventoryCreateInput;
}

export interface ResentmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ResentmentWhereInput;
  AND?: ResentmentSubscriptionWhereInput[] | ResentmentSubscriptionWhereInput;
  OR?: ResentmentSubscriptionWhereInput[] | ResentmentSubscriptionWhereInput;
  NOT?: ResentmentSubscriptionWhereInput[] | ResentmentSubscriptionWhereInput;
}

export interface HigherPowerCreateInput {
  inventory?: InventoryCreateOneInput;
}

export interface SalvationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SalvationWhereInput;
  AND?: SalvationSubscriptionWhereInput[] | SalvationSubscriptionWhereInput;
  OR?: SalvationSubscriptionWhereInput[] | SalvationSubscriptionWhereInput;
  NOT?: SalvationSubscriptionWhereInput[] | SalvationSubscriptionWhereInput;
}

export type SalvationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SelfPitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SelfPityWhereInput;
  AND?: SelfPitySubscriptionWhereInput[] | SelfPitySubscriptionWhereInput;
  OR?: SelfPitySubscriptionWhereInput[] | SelfPitySubscriptionWhereInput;
  NOT?: SelfPitySubscriptionWhereInput[] | SelfPitySubscriptionWhereInput;
}

export interface FearUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface StrengthWhereInput {
  armor_every?: ArmorWhereInput;
  armor_some?: ArmorWhereInput;
  armor_none?: ArmorWhereInput;
  boundary_every?: BoundaryWhereInput;
  boundary_some?: BoundaryWhereInput;
  boundary_none?: BoundaryWhereInput;
  loyalty_every?: LoyaltyWhereInput;
  loyalty_some?: LoyaltyWhereInput;
  loyalty_none?: LoyaltyWhereInput;
  honor_every?: HonorWhereInput;
  honor_some?: HonorWhereInput;
  honor_none?: HonorWhereInput;
  AND?: StrengthWhereInput[] | StrengthWhereInput;
  OR?: StrengthWhereInput[] | StrengthWhereInput;
  NOT?: StrengthWhereInput[] | StrengthWhereInput;
}

export interface FearUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SalvationCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface FearCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface BoundaryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: BoundaryWhereInput[] | BoundaryWhereInput;
  OR?: BoundaryWhereInput[] | BoundaryWhereInput;
  NOT?: BoundaryWhereInput[] | BoundaryWhereInput;
}

export type SelfPityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface BoundarySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: BoundaryWhereInput;
  AND?: BoundarySubscriptionWhereInput[] | BoundarySubscriptionWhereInput;
  OR?: BoundarySubscriptionWhereInput[] | BoundarySubscriptionWhereInput;
  NOT?: BoundarySubscriptionWhereInput[] | BoundarySubscriptionWhereInput;
}

export interface VulnerabilityCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ExperienceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExperienceWhereInput;
  AND?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  OR?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
  NOT?: ExperienceSubscriptionWhereInput[] | ExperienceSubscriptionWhereInput;
}

export interface VulnerabilityCreateManyInput {
  create?: VulnerabilityCreateInput[] | VulnerabilityCreateInput;
  connect?: VulnerabilityWhereUniqueInput[] | VulnerabilityWhereUniqueInput;
}

export type CourageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AcceptanceCreateManyInput {
  create?: AcceptanceCreateInput[] | AcceptanceCreateInput;
  connect?: AcceptanceWhereUniqueInput[] | AcceptanceWhereUniqueInput;
}

export interface VulnerabilityUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CourageCreateManyInput {
  create?: CourageCreateInput[] | CourageCreateInput;
  connect?: CourageWhereUniqueInput[] | CourageWhereUniqueInput;
}

export interface TraumaWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: TraumaWhereInput[] | TraumaWhereInput;
  OR?: TraumaWhereInput[] | TraumaWhereInput;
  NOT?: TraumaWhereInput[] | TraumaWhereInput;
}

export interface CompassionCreateManyInput {
  create?: CompassionCreateInput[] | CompassionCreateInput;
  connect?: CompassionWhereUniqueInput[] | CompassionWhereUniqueInput;
}

export interface ToxicityUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ExperienceCreateInput {
  compassion?: CompassionCreateManyInput;
  courage?: CourageCreateManyInput;
  acceptance?: AcceptanceCreateManyInput;
  vulnerability?: VulnerabilityCreateManyInput;
}

export interface SufferingUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type SufferingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SelfPityUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SufferingCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface InventorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InventoryWhereInput;
  AND?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
  OR?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
  NOT?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
}

export interface SufferingCreateManyInput {
  create?: SufferingCreateInput[] | SufferingCreateInput;
  connect?: SufferingWhereUniqueInput[] | SufferingWhereUniqueInput;
}

export interface PrideUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ToxicityCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface HonorUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type ToxicityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface InventoryUpsertNestedInput {
  update: InventoryUpdateDataInput;
  create: InventoryCreateInput;
}

export interface ToxicityCreateManyInput {
  create?: ToxicityCreateInput[] | ToxicityCreateInput;
  connect?: ToxicityWhereUniqueInput[] | ToxicityWhereUniqueInput;
}

export interface ExperienceUpdateManyInput {
  create?: ExperienceCreateInput[] | ExperienceCreateInput;
}

export interface TraumaCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ObsessionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ObsessionWhereInput;
  AND?: ObsessionSubscriptionWhereInput[] | ObsessionSubscriptionWhereInput;
  OR?: ObsessionSubscriptionWhereInput[] | ObsessionSubscriptionWhereInput;
  NOT?: ObsessionSubscriptionWhereInput[] | ObsessionSubscriptionWhereInput;
}

export interface TraumaCreateManyInput {
  create?: TraumaCreateInput[] | TraumaCreateInput;
  connect?: TraumaWhereUniqueInput[] | TraumaWhereUniqueInput;
}

export interface PrideSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PrideWhereInput;
  AND?: PrideSubscriptionWhereInput[] | PrideSubscriptionWhereInput;
  OR?: PrideSubscriptionWhereInput[] | PrideSubscriptionWhereInput;
  NOT?: PrideSubscriptionWhereInput[] | PrideSubscriptionWhereInput;
}

export type TraumaWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HonorWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: HonorWhereInput[] | HonorWhereInput;
  OR?: HonorWhereInput[] | HonorWhereInput;
  NOT?: HonorWhereInput[] | HonorWhereInput;
}

export interface DefectCreateInput {
  trauma?: TraumaCreateManyInput;
  toxicity?: ToxicityCreateManyInput;
  suffering?: SufferingCreateManyInput;
}

export interface InventoryUpdateOneInput {
  create?: InventoryCreateInput;
  update?: InventoryUpdateDataInput;
  upsert?: InventoryUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
}

export interface CourageUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface StrengthSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: StrengthWhereInput;
  AND?: StrengthSubscriptionWhereInput[] | StrengthSubscriptionWhereInput;
  OR?: StrengthSubscriptionWhereInput[] | StrengthSubscriptionWhereInput;
  NOT?: StrengthSubscriptionWhereInput[] | StrengthSubscriptionWhereInput;
}

export interface CourageUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CourageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CourageWhereInput;
  AND?: CourageSubscriptionWhereInput[] | CourageSubscriptionWhereInput;
  OR?: CourageSubscriptionWhereInput[] | CourageSubscriptionWhereInput;
  NOT?: CourageSubscriptionWhereInput[] | CourageSubscriptionWhereInput;
}

export type VulnerabilityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface FearSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FearWhereInput;
  AND?: FearSubscriptionWhereInput[] | FearSubscriptionWhereInput;
  OR?: FearSubscriptionWhereInput[] | FearSubscriptionWhereInput;
  NOT?: FearSubscriptionWhereInput[] | FearSubscriptionWhereInput;
}

export interface CourageCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface TraumaUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CompassionUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ToxicityUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CompassionUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ExperienceWhereInput {
  compassion_every?: CompassionWhereInput;
  compassion_some?: CompassionWhereInput;
  compassion_none?: CompassionWhereInput;
  courage_every?: CourageWhereInput;
  courage_some?: CourageWhereInput;
  courage_none?: CourageWhereInput;
  acceptance_every?: AcceptanceWhereInput;
  acceptance_some?: AcceptanceWhereInput;
  acceptance_none?: AcceptanceWhereInput;
  vulnerability_every?: VulnerabilityWhereInput;
  vulnerability_some?: VulnerabilityWhereInput;
  vulnerability_none?: VulnerabilityWhereInput;
  AND?: ExperienceWhereInput[] | ExperienceWhereInput;
  OR?: ExperienceWhereInput[] | ExperienceWhereInput;
  NOT?: ExperienceWhereInput[] | ExperienceWhereInput;
}

export interface LoyaltyUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type HigherPowerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AcceptanceCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export type AngerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AcceptanceUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface InventoryUpdateDataInput {
  defect?: DefectUpdateManyInput;
  resentment?: ResentmentUpdateManyInput;
  obsession?: ObsessionUpdateManyInput;
  experience?: ExperienceUpdateManyInput;
  strength?: StrengthUpdateManyInput;
  hope?: HopeUpdateManyInput;
}

export interface AcceptanceUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface HopeWhereInput {
  salvation_every?: SalvationWhereInput;
  salvation_some?: SalvationWhereInput;
  salvation_none?: SalvationWhereInput;
  AND?: HopeWhereInput[] | HopeWhereInput;
  OR?: HopeWhereInput[] | HopeWhereInput;
  NOT?: HopeWhereInput[] | HopeWhereInput;
}

export interface CompassionCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CourageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: CourageWhereInput[] | CourageWhereInput;
  OR?: CourageWhereInput[] | CourageWhereInput;
  NOT?: CourageWhereInput[] | CourageWhereInput;
}

export interface BoundaryUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SufferingUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface AngerCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface AngerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: AngerWhereInput[] | AngerWhereInput;
  OR?: AngerWhereInput[] | AngerWhereInput;
  NOT?: AngerWhereInput[] | AngerWhereInput;
}

export interface AngerUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface VulnerabilitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: VulnerabilityWhereInput;
  AND?:
    | VulnerabilitySubscriptionWhereInput[]
    | VulnerabilitySubscriptionWhereInput;
  OR?:
    | VulnerabilitySubscriptionWhereInput[]
    | VulnerabilitySubscriptionWhereInput;
  NOT?:
    | VulnerabilitySubscriptionWhereInput[]
    | VulnerabilitySubscriptionWhereInput;
}

export interface AngerUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ArmorSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ArmorWhereInput;
  AND?: ArmorSubscriptionWhereInput[] | ArmorSubscriptionWhereInput;
  OR?: ArmorSubscriptionWhereInput[] | ArmorSubscriptionWhereInput;
  NOT?: ArmorSubscriptionWhereInput[] | ArmorSubscriptionWhereInput;
}

export interface BoundaryCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ArmorUpdateManyMutationInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ArmorUpdateInput {
  name?: String;
  description?: String;
  attribute?: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface ArmorCreateInput {
  name: String;
  description: String;
  attribute: String;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SufferingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: SufferingWhereInput[] | SufferingWhereInput;
  OR?: SufferingWhereInput[] | SufferingWhereInput;
  NOT?: SufferingWhereInput[] | SufferingWhereInput;
}

export interface HigherPowerUpdateInput {
  inventory?: InventoryUpdateOneInput;
}

export interface SelfPityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  attribute?: String;
  attribute_not?: String;
  attribute_in?: String[] | String;
  attribute_not_in?: String[] | String;
  attribute_lt?: String;
  attribute_lte?: String;
  attribute_gt?: String;
  attribute_gte?: String;
  attribute_contains?: String;
  attribute_not_contains?: String;
  attribute_starts_with?: String;
  attribute_not_starts_with?: String;
  attribute_ends_with?: String;
  attribute_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: SelfPityWhereInput[] | SelfPityWhereInput;
  OR?: SelfPityWhereInput[] | SelfPityWhereInput;
  NOT?: SelfPityWhereInput[] | SelfPityWhereInput;
}

export interface LoyaltySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LoyaltyWhereInput;
  AND?: LoyaltySubscriptionWhereInput[] | LoyaltySubscriptionWhereInput;
  OR?: LoyaltySubscriptionWhereInput[] | LoyaltySubscriptionWhereInput;
  NOT?: LoyaltySubscriptionWhereInput[] | LoyaltySubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AggregateTrauma {
  count: Int;
}

export interface AggregateTraumaPromise
  extends Promise<AggregateTrauma>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTraumaSubscription
  extends Promise<AsyncIterator<AggregateTrauma>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Trauma {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface TraumaPromise extends Promise<Trauma>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface TraumaSubscription
  extends Promise<AsyncIterator<Trauma>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface VulnerabilityPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface VulnerabilityPreviousValuesPromise
  extends Promise<VulnerabilityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface VulnerabilityPreviousValuesSubscription
  extends Promise<AsyncIterator<VulnerabilityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Defect {}

export interface DefectPromise extends Promise<Defect>, Fragmentable {
  trauma: <T = FragmentableArray<Trauma>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = FragmentableArray<Toxicity>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  suffering: <T = FragmentableArray<Suffering>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DefectSubscription
  extends Promise<AsyncIterator<Defect>>,
    Fragmentable {
  trauma: <T = Promise<AsyncIterator<TraumaSubscription>>>(
    args?: {
      where?: TraumaWhereInput;
      orderBy?: TraumaOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  toxicity: <T = Promise<AsyncIterator<ToxicitySubscription>>>(
    args?: {
      where?: ToxicityWhereInput;
      orderBy?: ToxicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  suffering: <T = Promise<AsyncIterator<SufferingSubscription>>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateVulnerability {
  count: Int;
}

export interface AggregateVulnerabilityPromise
  extends Promise<AggregateVulnerability>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVulnerabilitySubscription
  extends Promise<AsyncIterator<AggregateVulnerability>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCourage {
  count: Int;
}

export interface AggregateCouragePromise
  extends Promise<AggregateCourage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCourageSubscription
  extends Promise<AsyncIterator<AggregateCourage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VulnerabilityConnection {
  pageInfo: PageInfo;
  edges: VulnerabilityEdge[];
}

export interface VulnerabilityConnectionPromise
  extends Promise<VulnerabilityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VulnerabilityEdge>>() => T;
  aggregate: <T = AggregateVulnerabilityPromise>() => T;
}

export interface VulnerabilityConnectionSubscription
  extends Promise<AsyncIterator<VulnerabilityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VulnerabilityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVulnerabilitySubscription>() => T;
}

export interface CourageEdge {
  node: Courage;
  cursor: String;
}

export interface CourageEdgePromise extends Promise<CourageEdge>, Fragmentable {
  node: <T = CouragePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CourageEdgeSubscription
  extends Promise<AsyncIterator<CourageEdge>>,
    Fragmentable {
  node: <T = CourageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TraumaEdge {
  node: Trauma;
  cursor: String;
}

export interface TraumaEdgePromise extends Promise<TraumaEdge>, Fragmentable {
  node: <T = TraumaPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TraumaEdgeSubscription
  extends Promise<AsyncIterator<TraumaEdge>>,
    Fragmentable {
  node: <T = TraumaSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CourageConnection {
  pageInfo: PageInfo;
  edges: CourageEdge[];
}

export interface CourageConnectionPromise
  extends Promise<CourageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CourageEdge>>() => T;
  aggregate: <T = AggregateCouragePromise>() => T;
}

export interface CourageConnectionSubscription
  extends Promise<AsyncIterator<CourageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CourageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCourageSubscription>() => T;
}

export interface AggregateToxicity {
  count: Int;
}

export interface AggregateToxicityPromise
  extends Promise<AggregateToxicity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateToxicitySubscription
  extends Promise<AsyncIterator<AggregateToxicity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Courage {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface CouragePromise extends Promise<Courage>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface CourageSubscription
  extends Promise<AsyncIterator<Courage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ToxicityConnection {
  pageInfo: PageInfo;
  edges: ToxicityEdge[];
}

export interface ToxicityConnectionPromise
  extends Promise<ToxicityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ToxicityEdge>>() => T;
  aggregate: <T = AggregateToxicityPromise>() => T;
}

export interface ToxicityConnectionSubscription
  extends Promise<AsyncIterator<ToxicityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ToxicityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateToxicitySubscription>() => T;
}

export interface AggregateCompassion {
  count: Int;
}

export interface AggregateCompassionPromise
  extends Promise<AggregateCompassion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompassionSubscription
  extends Promise<AsyncIterator<AggregateCompassion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SufferingEdge {
  node: Suffering;
  cursor: String;
}

export interface SufferingEdgePromise
  extends Promise<SufferingEdge>,
    Fragmentable {
  node: <T = SufferingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SufferingEdgeSubscription
  extends Promise<AsyncIterator<SufferingEdge>>,
    Fragmentable {
  node: <T = SufferingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompassionEdge {
  node: Compassion;
  cursor: String;
}

export interface CompassionEdgePromise
  extends Promise<CompassionEdge>,
    Fragmentable {
  node: <T = CompassionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompassionEdgeSubscription
  extends Promise<AsyncIterator<CompassionEdge>>,
    Fragmentable {
  node: <T = CompassionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStrength {
  count: Int;
}

export interface AggregateStrengthPromise
  extends Promise<AggregateStrength>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStrengthSubscription
  extends Promise<AsyncIterator<AggregateStrength>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AcceptanceSubscriptionPayload {
  mutation: MutationType;
  node: Acceptance;
  updatedFields: String[];
  previousValues: AcceptancePreviousValues;
}

export interface AcceptanceSubscriptionPayloadPromise
  extends Promise<AcceptanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AcceptancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AcceptancePreviousValuesPromise>() => T;
}

export interface AcceptanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AcceptanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AcceptanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AcceptancePreviousValuesSubscription>() => T;
}

export interface StrengthConnection {}

export interface StrengthConnectionPromise
  extends Promise<StrengthConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StrengthEdge>>() => T;
  aggregate: <T = AggregateStrengthPromise>() => T;
}

export interface StrengthConnectionSubscription
  extends Promise<AsyncIterator<StrengthConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StrengthEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStrengthSubscription>() => T;
}

export interface AcceptancePreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface AcceptancePreviousValuesPromise
  extends Promise<AcceptancePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface AcceptancePreviousValuesSubscription
  extends Promise<AsyncIterator<AcceptancePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SelfPityEdge {
  node: SelfPity;
  cursor: String;
}

export interface SelfPityEdgePromise
  extends Promise<SelfPityEdge>,
    Fragmentable {
  node: <T = SelfPityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SelfPityEdgeSubscription
  extends Promise<AsyncIterator<SelfPityEdge>>,
    Fragmentable {
  node: <T = SelfPitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CompassionConnection {
  pageInfo: PageInfo;
  edges: CompassionEdge[];
}

export interface CompassionConnectionPromise
  extends Promise<CompassionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompassionEdge>>() => T;
  aggregate: <T = AggregateCompassionPromise>() => T;
}

export interface CompassionConnectionSubscription
  extends Promise<AsyncIterator<CompassionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompassionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompassionSubscription>() => T;
}

export interface AggregateSalvation {
  count: Int;
}

export interface AggregateSalvationPromise
  extends Promise<AggregateSalvation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSalvationSubscription
  extends Promise<AsyncIterator<AggregateSalvation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AngerSubscriptionPayload {
  mutation: MutationType;
  node: Anger;
  updatedFields: String[];
  previousValues: AngerPreviousValues;
}

export interface AngerSubscriptionPayloadPromise
  extends Promise<AngerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AngerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AngerPreviousValuesPromise>() => T;
}

export interface AngerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AngerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AngerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AngerPreviousValuesSubscription>() => T;
}

export interface SalvationConnection {
  pageInfo: PageInfo;
  edges: SalvationEdge[];
}

export interface SalvationConnectionPromise
  extends Promise<SalvationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SalvationEdge>>() => T;
  aggregate: <T = AggregateSalvationPromise>() => T;
}

export interface SalvationConnectionSubscription
  extends Promise<AsyncIterator<SalvationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SalvationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSalvationSubscription>() => T;
}

export interface AngerPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface AngerPreviousValuesPromise
  extends Promise<AngerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface AngerPreviousValuesSubscription
  extends Promise<AsyncIterator<AngerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ResentmentEdge {
  node: Resentment;
  cursor: String;
}

export interface ResentmentEdgePromise
  extends Promise<ResentmentEdge>,
    Fragmentable {
  node: <T = ResentmentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ResentmentEdgeSubscription
  extends Promise<AsyncIterator<ResentmentEdge>>,
    Fragmentable {
  node: <T = ResentmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Compassion {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface CompassionPromise extends Promise<Compassion>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface CompassionSubscription
  extends Promise<AsyncIterator<Compassion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregatePride {
  count: Int;
}

export interface AggregatePridePromise
  extends Promise<AggregatePride>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePrideSubscription
  extends Promise<AsyncIterator<AggregatePride>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArmorSubscriptionPayload {
  mutation: MutationType;
  node: Armor;
  updatedFields: String[];
  previousValues: ArmorPreviousValues;
}

export interface ArmorSubscriptionPayloadPromise
  extends Promise<ArmorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ArmorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ArmorPreviousValuesPromise>() => T;
}

export interface ArmorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ArmorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ArmorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ArmorPreviousValuesSubscription>() => T;
}

export interface PrideConnection {
  pageInfo: PageInfo;
  edges: PrideEdge[];
}

export interface PrideConnectionPromise
  extends Promise<PrideConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PrideEdge>>() => T;
  aggregate: <T = AggregatePridePromise>() => T;
}

export interface PrideConnectionSubscription
  extends Promise<AsyncIterator<PrideConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PrideEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePrideSubscription>() => T;
}

export interface ArmorPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ArmorPreviousValuesPromise
  extends Promise<ArmorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ArmorPreviousValuesSubscription
  extends Promise<AsyncIterator<ArmorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ObsessionEdge {
  node: Obsession;
  cursor: String;
}

export interface ObsessionEdgePromise
  extends Promise<ObsessionEdge>,
    Fragmentable {
  node: <T = ObsessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ObsessionEdgeSubscription
  extends Promise<AsyncIterator<ObsessionEdge>>,
    Fragmentable {
  node: <T = ObsessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBoundary {
  count: Int;
}

export interface AggregateBoundaryPromise
  extends Promise<AggregateBoundary>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBoundarySubscription
  extends Promise<AsyncIterator<AggregateBoundary>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateLoyalty {
  count: Int;
}

export interface AggregateLoyaltyPromise
  extends Promise<AggregateLoyalty>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoyaltySubscription
  extends Promise<AsyncIterator<AggregateLoyalty>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BoundarySubscriptionPayload {
  mutation: MutationType;
  node: Boundary;
  updatedFields: String[];
  previousValues: BoundaryPreviousValues;
}

export interface BoundarySubscriptionPayloadPromise
  extends Promise<BoundarySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BoundaryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BoundaryPreviousValuesPromise>() => T;
}

export interface BoundarySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BoundarySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BoundarySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BoundaryPreviousValuesSubscription>() => T;
}

export interface LoyaltyConnection {
  pageInfo: PageInfo;
  edges: LoyaltyEdge[];
}

export interface LoyaltyConnectionPromise
  extends Promise<LoyaltyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoyaltyEdge>>() => T;
  aggregate: <T = AggregateLoyaltyPromise>() => T;
}

export interface LoyaltyConnectionSubscription
  extends Promise<AsyncIterator<LoyaltyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoyaltyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoyaltySubscription>() => T;
}

export interface BoundaryPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface BoundaryPreviousValuesPromise
  extends Promise<BoundaryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface BoundaryPreviousValuesSubscription
  extends Promise<AsyncIterator<BoundaryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryEdge {
  node: Inventory;
  cursor: String;
}

export interface InventoryEdgePromise
  extends Promise<InventoryEdge>,
    Fragmentable {
  node: <T = InventoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryEdgeSubscription
  extends Promise<AsyncIterator<InventoryEdge>>,
    Fragmentable {
  node: <T = InventorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BoundaryEdge {
  node: Boundary;
  cursor: String;
}

export interface BoundaryEdgePromise
  extends Promise<BoundaryEdge>,
    Fragmentable {
  node: <T = BoundaryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BoundaryEdgeSubscription
  extends Promise<AsyncIterator<BoundaryEdge>>,
    Fragmentable {
  node: <T = BoundarySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateHope {
  count: Int;
}

export interface AggregateHopePromise
  extends Promise<AggregateHope>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHopeSubscription
  extends Promise<AsyncIterator<AggregateHope>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompassionSubscriptionPayload {
  mutation: MutationType;
  node: Compassion;
  updatedFields: String[];
  previousValues: CompassionPreviousValues;
}

export interface CompassionSubscriptionPayloadPromise
  extends Promise<CompassionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompassionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompassionPreviousValuesPromise>() => T;
}

export interface CompassionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompassionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompassionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompassionPreviousValuesSubscription>() => T;
}

export interface HopeConnection {}

export interface HopeConnectionPromise
  extends Promise<HopeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HopeEdge>>() => T;
  aggregate: <T = AggregateHopePromise>() => T;
}

export interface HopeConnectionSubscription
  extends Promise<AsyncIterator<HopeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HopeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHopeSubscription>() => T;
}

export interface CompassionPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface CompassionPreviousValuesPromise
  extends Promise<CompassionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface CompassionPreviousValuesSubscription
  extends Promise<AsyncIterator<CompassionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HonorEdge {
  node: Honor;
  cursor: String;
}

export interface HonorEdgePromise extends Promise<HonorEdge>, Fragmentable {
  node: <T = HonorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HonorEdgeSubscription
  extends Promise<AsyncIterator<HonorEdge>>,
    Fragmentable {
  node: <T = HonorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BoundaryConnection {
  pageInfo: PageInfo;
  edges: BoundaryEdge[];
}

export interface BoundaryConnectionPromise
  extends Promise<BoundaryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BoundaryEdge>>() => T;
  aggregate: <T = AggregateBoundaryPromise>() => T;
}

export interface BoundaryConnectionSubscription
  extends Promise<AsyncIterator<BoundaryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BoundaryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBoundarySubscription>() => T;
}

export interface AggregateHigherPower {
  count: Int;
}

export interface AggregateHigherPowerPromise
  extends Promise<AggregateHigherPower>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHigherPowerSubscription
  extends Promise<AsyncIterator<AggregateHigherPower>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CourageSubscriptionPayload {
  mutation: MutationType;
  node: Courage;
  updatedFields: String[];
  previousValues: CouragePreviousValues;
}

export interface CourageSubscriptionPayloadPromise
  extends Promise<CourageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CouragePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CouragePreviousValuesPromise>() => T;
}

export interface CourageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CourageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CourageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CouragePreviousValuesSubscription>() => T;
}

export interface HigherPowerConnection {
  pageInfo: PageInfo;
  edges: HigherPowerEdge[];
}

export interface HigherPowerConnectionPromise
  extends Promise<HigherPowerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HigherPowerEdge>>() => T;
  aggregate: <T = AggregateHigherPowerPromise>() => T;
}

export interface HigherPowerConnectionSubscription
  extends Promise<AsyncIterator<HigherPowerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HigherPowerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHigherPowerSubscription>() => T;
}

export interface CouragePreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface CouragePreviousValuesPromise
  extends Promise<CouragePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface CouragePreviousValuesSubscription
  extends Promise<AsyncIterator<CouragePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Hope {}

export interface HopePromise extends Promise<Hope>, Fragmentable {
  salvation: <T = FragmentableArray<Salvation>>(
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HopeSubscription
  extends Promise<AsyncIterator<Hope>>,
    Fragmentable {
  salvation: <T = Promise<AsyncIterator<SalvationSubscription>>>(
    args?: {
      where?: SalvationWhereInput;
      orderBy?: SalvationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Boundary {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface BoundaryPromise extends Promise<Boundary>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface BoundarySubscription
  extends Promise<AsyncIterator<Boundary>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Honor {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface HonorPromise extends Promise<Honor>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface HonorSubscription
  extends Promise<AsyncIterator<Honor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface DefectSubscriptionPayload {
  mutation: MutationType;
  node: Defect;
  updatedFields: String[];
}

export interface DefectSubscriptionPayloadPromise
  extends Promise<DefectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DefectPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface DefectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DefectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DefectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface Obsession {}

export interface ObsessionPromise extends Promise<Obsession>, Fragmentable {
  suffering: <T = FragmentableArray<Suffering>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loyalty: <T = FragmentableArray<Loyalty>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = FragmentableArray<Honor>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vulnerability: <T = FragmentableArray<Vulnerability>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ObsessionSubscription
  extends Promise<AsyncIterator<Obsession>>,
    Fragmentable {
  suffering: <T = Promise<AsyncIterator<SufferingSubscription>>>(
    args?: {
      where?: SufferingWhereInput;
      orderBy?: SufferingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loyalty: <T = Promise<AsyncIterator<LoyaltySubscription>>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = Promise<AsyncIterator<HonorSubscription>>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vulnerability: <T = Promise<AsyncIterator<VulnerabilitySubscription>>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateArmor {
  count: Int;
}

export interface AggregateArmorPromise
  extends Promise<AggregateArmor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateArmorSubscription
  extends Promise<AsyncIterator<AggregateArmor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SelfPity {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SelfPityPromise extends Promise<SelfPity>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SelfPitySubscription
  extends Promise<AsyncIterator<SelfPity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExperienceSubscriptionPayload {
  mutation: MutationType;
  node: Experience;
  updatedFields: String[];
}

export interface ExperienceSubscriptionPayloadPromise
  extends Promise<ExperienceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExperiencePromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface ExperienceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExperienceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExperienceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface Inventory {}

export interface InventoryPromise extends Promise<Inventory>, Fragmentable {
  defect: <T = FragmentableArray<Defect>>(
    args?: {
      where?: DefectWhereInput;
      orderBy?: DefectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  resentment: <T = FragmentableArray<Resentment>>(
    args?: {
      where?: ResentmentWhereInput;
      orderBy?: ResentmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  obsession: <T = FragmentableArray<Obsession>>(
    args?: {
      where?: ObsessionWhereInput;
      orderBy?: ObsessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  experience: <T = FragmentableArray<Experience>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  strength: <T = FragmentableArray<Strength>>(
    args?: {
      where?: StrengthWhereInput;
      orderBy?: StrengthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hope: <T = FragmentableArray<Hope>>(
    args?: {
      where?: HopeWhereInput;
      orderBy?: HopeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface InventorySubscription
  extends Promise<AsyncIterator<Inventory>>,
    Fragmentable {
  defect: <T = Promise<AsyncIterator<DefectSubscription>>>(
    args?: {
      where?: DefectWhereInput;
      orderBy?: DefectOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  resentment: <T = Promise<AsyncIterator<ResentmentSubscription>>>(
    args?: {
      where?: ResentmentWhereInput;
      orderBy?: ResentmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  obsession: <T = Promise<AsyncIterator<ObsessionSubscription>>>(
    args?: {
      where?: ObsessionWhereInput;
      orderBy?: ObsessionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  experience: <T = Promise<AsyncIterator<ExperienceSubscription>>>(
    args?: {
      where?: ExperienceWhereInput;
      orderBy?: ExperienceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  strength: <T = Promise<AsyncIterator<StrengthSubscription>>>(
    args?: {
      where?: StrengthWhereInput;
      orderBy?: StrengthOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hope: <T = Promise<AsyncIterator<HopeSubscription>>>(
    args?: {
      where?: HopeWhereInput;
      orderBy?: HopeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ArmorEdge {
  node: Armor;
  cursor: String;
}

export interface ArmorEdgePromise extends Promise<ArmorEdge>, Fragmentable {
  node: <T = ArmorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ArmorEdgeSubscription
  extends Promise<AsyncIterator<ArmorEdge>>,
    Fragmentable {
  node: <T = ArmorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFear {
  count: Int;
}

export interface AggregateFearPromise
  extends Promise<AggregateFear>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFearSubscription
  extends Promise<AsyncIterator<AggregateFear>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FearSubscriptionPayload {
  mutation: MutationType;
  node: Fear;
  updatedFields: String[];
  previousValues: FearPreviousValues;
}

export interface FearSubscriptionPayloadPromise
  extends Promise<FearSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FearPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FearPreviousValuesPromise>() => T;
}

export interface FearSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FearSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FearSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FearPreviousValuesSubscription>() => T;
}

export interface FearConnection {
  pageInfo: PageInfo;
  edges: FearEdge[];
}

export interface FearConnectionPromise
  extends Promise<FearConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FearEdge>>() => T;
  aggregate: <T = AggregateFearPromise>() => T;
}

export interface FearConnectionSubscription
  extends Promise<AsyncIterator<FearConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FearEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFearSubscription>() => T;
}

export interface FearPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface FearPreviousValuesPromise
  extends Promise<FearPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface FearPreviousValuesSubscription
  extends Promise<AsyncIterator<FearPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateExperience {
  count: Int;
}

export interface AggregateExperiencePromise
  extends Promise<AggregateExperience>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExperienceSubscription
  extends Promise<AsyncIterator<AggregateExperience>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ArmorConnection {
  pageInfo: PageInfo;
  edges: ArmorEdge[];
}

export interface ArmorConnectionPromise
  extends Promise<ArmorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ArmorEdge>>() => T;
  aggregate: <T = AggregateArmorPromise>() => T;
}

export interface ArmorConnectionSubscription
  extends Promise<AsyncIterator<ArmorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ArmorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateArmorSubscription>() => T;
}

export interface ExperienceConnection {}

export interface ExperienceConnectionPromise
  extends Promise<ExperienceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ExperienceEdge>>() => T;
  aggregate: <T = AggregateExperiencePromise>() => T;
}

export interface ExperienceConnectionSubscription
  extends Promise<AsyncIterator<ExperienceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExperienceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExperienceSubscription>() => T;
}

export interface HigherPowerSubscriptionPayload {
  mutation: MutationType;
  node: HigherPower;
  updatedFields: String[];
  previousValues: HigherPowerPreviousValues;
}

export interface HigherPowerSubscriptionPayloadPromise
  extends Promise<HigherPowerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HigherPowerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HigherPowerPreviousValuesPromise>() => T;
}

export interface HigherPowerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HigherPowerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HigherPowerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HigherPowerPreviousValuesSubscription>() => T;
}

export interface Experience {}

export interface ExperiencePromise extends Promise<Experience>, Fragmentable {
  compassion: <T = FragmentableArray<Compassion>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  courage: <T = FragmentableArray<Courage>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = FragmentableArray<Acceptance>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vulnerability: <T = FragmentableArray<Vulnerability>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ExperienceSubscription
  extends Promise<AsyncIterator<Experience>>,
    Fragmentable {
  compassion: <T = Promise<AsyncIterator<CompassionSubscription>>>(
    args?: {
      where?: CompassionWhereInput;
      orderBy?: CompassionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  courage: <T = Promise<AsyncIterator<CourageSubscription>>>(
    args?: {
      where?: CourageWhereInput;
      orderBy?: CourageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  acceptance: <T = Promise<AsyncIterator<AcceptanceSubscription>>>(
    args?: {
      where?: AcceptanceWhereInput;
      orderBy?: AcceptanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  vulnerability: <T = Promise<AsyncIterator<VulnerabilitySubscription>>>(
    args?: {
      where?: VulnerabilityWhereInput;
      orderBy?: VulnerabilityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HigherPowerPreviousValues {
  id: ID_Output;
}

export interface HigherPowerPreviousValuesPromise
  extends Promise<HigherPowerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface HigherPowerPreviousValuesSubscription
  extends Promise<AsyncIterator<HigherPowerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface DefectEdge {
  node: Defect;
  cursor: String;
}

export interface DefectEdgePromise extends Promise<DefectEdge>, Fragmentable {
  node: <T = DefectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DefectEdgeSubscription
  extends Promise<AsyncIterator<DefectEdge>>,
    Fragmentable {
  node: <T = DefectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Armor {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ArmorPromise extends Promise<Armor>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ArmorSubscription
  extends Promise<AsyncIterator<Armor>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Suffering {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SufferingPromise extends Promise<Suffering>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SufferingSubscription
  extends Promise<AsyncIterator<Suffering>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HonorSubscriptionPayload {
  mutation: MutationType;
  node: Honor;
  updatedFields: String[];
  previousValues: HonorPreviousValues;
}

export interface HonorSubscriptionPayloadPromise
  extends Promise<HonorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HonorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HonorPreviousValuesPromise>() => T;
}

export interface HonorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HonorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HonorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HonorPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Toxicity {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ToxicityPromise extends Promise<Toxicity>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ToxicitySubscription
  extends Promise<AsyncIterator<Toxicity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TraumaSubscriptionPayload {
  mutation: MutationType;
  node: Trauma;
  updatedFields: String[];
  previousValues: TraumaPreviousValues;
}

export interface TraumaSubscriptionPayloadPromise
  extends Promise<TraumaSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TraumaPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TraumaPreviousValuesPromise>() => T;
}

export interface TraumaSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TraumaSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TraumaSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TraumaPreviousValuesSubscription>() => T;
}

export interface VulnerabilityEdge {
  node: Vulnerability;
  cursor: String;
}

export interface VulnerabilityEdgePromise
  extends Promise<VulnerabilityEdge>,
    Fragmentable {
  node: <T = VulnerabilityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VulnerabilityEdgeSubscription
  extends Promise<AsyncIterator<VulnerabilityEdge>>,
    Fragmentable {
  node: <T = VulnerabilitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HonorPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface HonorPreviousValuesPromise
  extends Promise<HonorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface HonorPreviousValuesSubscription
  extends Promise<AsyncIterator<HonorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TraumaConnection {
  pageInfo: PageInfo;
  edges: TraumaEdge[];
}

export interface TraumaConnectionPromise
  extends Promise<TraumaConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TraumaEdge>>() => T;
  aggregate: <T = AggregateTraumaPromise>() => T;
}

export interface TraumaConnectionSubscription
  extends Promise<AsyncIterator<TraumaConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TraumaEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTraumaSubscription>() => T;
}

export interface AggregateSuffering {
  count: Int;
}

export interface AggregateSufferingPromise
  extends Promise<AggregateSuffering>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSufferingSubscription
  extends Promise<AsyncIterator<AggregateSuffering>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateAnger {
  count: Int;
}

export interface AggregateAngerPromise
  extends Promise<AggregateAnger>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAngerSubscription
  extends Promise<AsyncIterator<AggregateAnger>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StrengthEdge {
  node: Strength;
  cursor: String;
}

export interface StrengthEdgePromise
  extends Promise<StrengthEdge>,
    Fragmentable {
  node: <T = StrengthPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StrengthEdgeSubscription
  extends Promise<AsyncIterator<StrengthEdge>>,
    Fragmentable {
  node: <T = StrengthSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HopeSubscriptionPayload {
  mutation: MutationType;
  node: Hope;
  updatedFields: String[];
}

export interface HopeSubscriptionPayloadPromise
  extends Promise<HopeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HopePromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface HopeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HopeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HopeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface SelfPityConnection {
  pageInfo: PageInfo;
  edges: SelfPityEdge[];
}

export interface SelfPityConnectionPromise
  extends Promise<SelfPityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SelfPityEdge>>() => T;
  aggregate: <T = AggregateSelfPityPromise>() => T;
}

export interface SelfPityConnectionSubscription
  extends Promise<AsyncIterator<SelfPityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SelfPityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSelfPitySubscription>() => T;
}

export interface AngerEdge {
  node: Anger;
  cursor: String;
}

export interface AngerEdgePromise extends Promise<AngerEdge>, Fragmentable {
  node: <T = AngerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AngerEdgeSubscription
  extends Promise<AsyncIterator<AngerEdge>>,
    Fragmentable {
  node: <T = AngerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateResentment {
  count: Int;
}

export interface AggregateResentmentPromise
  extends Promise<AggregateResentment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateResentmentSubscription
  extends Promise<AsyncIterator<AggregateResentment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InventorySubscriptionPayload {
  mutation: MutationType;
  node: Inventory;
  updatedFields: String[];
}

export interface InventorySubscriptionPayloadPromise
  extends Promise<InventorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface InventorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface PrideEdge {
  node: Pride;
  cursor: String;
}

export interface PrideEdgePromise extends Promise<PrideEdge>, Fragmentable {
  node: <T = PridePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PrideEdgeSubscription
  extends Promise<AsyncIterator<PrideEdge>>,
    Fragmentable {
  node: <T = PrideSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AngerConnection {
  pageInfo: PageInfo;
  edges: AngerEdge[];
}

export interface AngerConnectionPromise
  extends Promise<AngerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AngerEdge>>() => T;
  aggregate: <T = AggregateAngerPromise>() => T;
}

export interface AngerConnectionSubscription
  extends Promise<AsyncIterator<AngerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AngerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAngerSubscription>() => T;
}

export interface ObsessionConnection {}

export interface ObsessionConnectionPromise
  extends Promise<ObsessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ObsessionEdge>>() => T;
  aggregate: <T = AggregateObsessionPromise>() => T;
}

export interface ObsessionConnectionSubscription
  extends Promise<AsyncIterator<ObsessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ObsessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateObsessionSubscription>() => T;
}

export interface LoyaltySubscriptionPayload {
  mutation: MutationType;
  node: Loyalty;
  updatedFields: String[];
  previousValues: LoyaltyPreviousValues;
}

export interface LoyaltySubscriptionPayloadPromise
  extends Promise<LoyaltySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoyaltyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoyaltyPreviousValuesPromise>() => T;
}

export interface LoyaltySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoyaltySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoyaltySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoyaltyPreviousValuesSubscription>() => T;
}

export interface AggregateInventory {
  count: Int;
}

export interface AggregateInventoryPromise
  extends Promise<AggregateInventory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventorySubscription
  extends Promise<AsyncIterator<AggregateInventory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoyaltyPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface LoyaltyPreviousValuesPromise
  extends Promise<LoyaltyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface LoyaltyPreviousValuesSubscription
  extends Promise<AsyncIterator<LoyaltyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HopeEdge {
  node: Hope;
  cursor: String;
}

export interface HopeEdgePromise extends Promise<HopeEdge>, Fragmentable {
  node: <T = HopePromise>() => T;
  cursor: () => Promise<String>;
}

export interface HopeEdgeSubscription
  extends Promise<AsyncIterator<HopeEdge>>,
    Fragmentable {
  node: <T = HopeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Anger {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface AngerPromise extends Promise<Anger>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface AngerSubscription
  extends Promise<AsyncIterator<Anger>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HonorConnection {
  pageInfo: PageInfo;
  edges: HonorEdge[];
}

export interface HonorConnectionPromise
  extends Promise<HonorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HonorEdge>>() => T;
  aggregate: <T = AggregateHonorPromise>() => T;
}

export interface HonorConnectionSubscription
  extends Promise<AsyncIterator<HonorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HonorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHonorSubscription>() => T;
}

export interface ObsessionSubscriptionPayload {
  mutation: MutationType;
  node: Obsession;
  updatedFields: String[];
}

export interface ObsessionSubscriptionPayloadPromise
  extends Promise<ObsessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ObsessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface ObsessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ObsessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ObsessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface Salvation {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SalvationPromise extends Promise<Salvation>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SalvationSubscription
  extends Promise<AsyncIterator<Salvation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateAcceptance {
  count: Int;
}

export interface AggregateAcceptancePromise
  extends Promise<AggregateAcceptance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAcceptanceSubscription
  extends Promise<AsyncIterator<AggregateAcceptance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Loyalty {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface LoyaltyPromise extends Promise<Loyalty>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface LoyaltySubscription
  extends Promise<AsyncIterator<Loyalty>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PrideSubscriptionPayload {
  mutation: MutationType;
  node: Pride;
  updatedFields: String[];
  previousValues: PridePreviousValues;
}

export interface PrideSubscriptionPayloadPromise
  extends Promise<PrideSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PridePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PridePreviousValuesPromise>() => T;
}

export interface PrideSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PrideSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PrideSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PridePreviousValuesSubscription>() => T;
}

export interface Resentment {}

export interface ResentmentPromise extends Promise<Resentment>, Fragmentable {
  anger: <T = FragmentableArray<Anger>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = FragmentableArray<SelfPity>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = FragmentableArray<Fear>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = FragmentableArray<Pride>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ResentmentSubscription
  extends Promise<AsyncIterator<Resentment>>,
    Fragmentable {
  anger: <T = Promise<AsyncIterator<AngerSubscription>>>(
    args?: {
      where?: AngerWhereInput;
      orderBy?: AngerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  selfPity: <T = Promise<AsyncIterator<SelfPitySubscription>>>(
    args?: {
      where?: SelfPityWhereInput;
      orderBy?: SelfPityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fear: <T = Promise<AsyncIterator<FearSubscription>>>(
    args?: {
      where?: FearWhereInput;
      orderBy?: FearOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  pride: <T = Promise<AsyncIterator<PrideSubscription>>>(
    args?: {
      where?: PrideWhereInput;
      orderBy?: PrideOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PridePreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface PridePreviousValuesPromise
  extends Promise<PridePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface PridePreviousValuesSubscription
  extends Promise<AsyncIterator<PridePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FearEdge {
  node: Fear;
  cursor: String;
}

export interface FearEdgePromise extends Promise<FearEdge>, Fragmentable {
  node: <T = FearPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FearEdgeSubscription
  extends Promise<AsyncIterator<FearEdge>>,
    Fragmentable {
  node: <T = FearSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AcceptanceEdge {
  node: Acceptance;
  cursor: String;
}

export interface AcceptanceEdgePromise
  extends Promise<AcceptanceEdge>,
    Fragmentable {
  node: <T = AcceptancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AcceptanceEdgeSubscription
  extends Promise<AsyncIterator<AcceptanceEdge>>,
    Fragmentable {
  node: <T = AcceptanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExperienceEdge {
  node: Experience;
  cursor: String;
}

export interface ExperienceEdgePromise
  extends Promise<ExperienceEdge>,
    Fragmentable {
  node: <T = ExperiencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ExperienceEdgeSubscription
  extends Promise<AsyncIterator<ExperienceEdge>>,
    Fragmentable {
  node: <T = ExperienceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ResentmentSubscriptionPayload {
  mutation: MutationType;
  node: Resentment;
  updatedFields: String[];
}

export interface ResentmentSubscriptionPayloadPromise
  extends Promise<ResentmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ResentmentPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface ResentmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ResentmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ResentmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface AggregateDefect {
  count: Int;
}

export interface AggregateDefectPromise
  extends Promise<AggregateDefect>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDefectSubscription
  extends Promise<AsyncIterator<AggregateDefect>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VulnerabilitySubscriptionPayload {
  mutation: MutationType;
  node: Vulnerability;
  updatedFields: String[];
  previousValues: VulnerabilityPreviousValues;
}

export interface VulnerabilitySubscriptionPayloadPromise
  extends Promise<VulnerabilitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VulnerabilityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VulnerabilityPreviousValuesPromise>() => T;
}

export interface VulnerabilitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VulnerabilitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VulnerabilitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VulnerabilityPreviousValuesSubscription>() => T;
}

export interface ToxicityEdge {
  node: Toxicity;
  cursor: String;
}

export interface ToxicityEdgePromise
  extends Promise<ToxicityEdge>,
    Fragmentable {
  node: <T = ToxicityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ToxicityEdgeSubscription
  extends Promise<AsyncIterator<ToxicityEdge>>,
    Fragmentable {
  node: <T = ToxicitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SalvationSubscriptionPayload {
  mutation: MutationType;
  node: Salvation;
  updatedFields: String[];
  previousValues: SalvationPreviousValues;
}

export interface SalvationSubscriptionPayloadPromise
  extends Promise<SalvationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SalvationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SalvationPreviousValuesPromise>() => T;
}

export interface SalvationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SalvationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SalvationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SalvationPreviousValuesSubscription>() => T;
}

export interface AggregateSelfPity {
  count: Int;
}

export interface AggregateSelfPityPromise
  extends Promise<AggregateSelfPity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSelfPitySubscription
  extends Promise<AsyncIterator<AggregateSelfPity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SalvationPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SalvationPreviousValuesPromise
  extends Promise<SalvationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SalvationPreviousValuesSubscription
  extends Promise<AsyncIterator<SalvationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ResentmentConnection {}

export interface ResentmentConnectionPromise
  extends Promise<ResentmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ResentmentEdge>>() => T;
  aggregate: <T = AggregateResentmentPromise>() => T;
}

export interface ResentmentConnectionSubscription
  extends Promise<AsyncIterator<ResentmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ResentmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateResentmentSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface LoyaltyEdge {
  node: Loyalty;
  cursor: String;
}

export interface LoyaltyEdgePromise extends Promise<LoyaltyEdge>, Fragmentable {
  node: <T = LoyaltyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoyaltyEdgeSubscription
  extends Promise<AsyncIterator<LoyaltyEdge>>,
    Fragmentable {
  node: <T = LoyaltySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SelfPitySubscriptionPayload {
  mutation: MutationType;
  node: SelfPity;
  updatedFields: String[];
  previousValues: SelfPityPreviousValues;
}

export interface SelfPitySubscriptionPayloadPromise
  extends Promise<SelfPitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SelfPityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SelfPityPreviousValuesPromise>() => T;
}

export interface SelfPitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SelfPitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SelfPitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SelfPityPreviousValuesSubscription>() => T;
}

export interface AggregateHonor {
  count: Int;
}

export interface AggregateHonorPromise
  extends Promise<AggregateHonor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHonorSubscription
  extends Promise<AsyncIterator<AggregateHonor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SelfPityPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SelfPityPreviousValuesPromise
  extends Promise<SelfPityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SelfPityPreviousValuesSubscription
  extends Promise<AsyncIterator<SelfPityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Strength {}

export interface StrengthPromise extends Promise<Strength>, Fragmentable {
  armor: <T = FragmentableArray<Armor>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  boundary: <T = FragmentableArray<Boundary>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loyalty: <T = FragmentableArray<Loyalty>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = FragmentableArray<Honor>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface StrengthSubscription
  extends Promise<AsyncIterator<Strength>>,
    Fragmentable {
  armor: <T = Promise<AsyncIterator<ArmorSubscription>>>(
    args?: {
      where?: ArmorWhereInput;
      orderBy?: ArmorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  boundary: <T = Promise<AsyncIterator<BoundarySubscription>>>(
    args?: {
      where?: BoundaryWhereInput;
      orderBy?: BoundaryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  loyalty: <T = Promise<AsyncIterator<LoyaltySubscription>>>(
    args?: {
      where?: LoyaltyWhereInput;
      orderBy?: LoyaltyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  honor: <T = Promise<AsyncIterator<HonorSubscription>>>(
    args?: {
      where?: HonorWhereInput;
      orderBy?: HonorOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AcceptanceConnection {
  pageInfo: PageInfo;
  edges: AcceptanceEdge[];
}

export interface AcceptanceConnectionPromise
  extends Promise<AcceptanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AcceptanceEdge>>() => T;
  aggregate: <T = AggregateAcceptancePromise>() => T;
}

export interface AcceptanceConnectionSubscription
  extends Promise<AsyncIterator<AcceptanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AcceptanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAcceptanceSubscription>() => T;
}

export interface HigherPower {
  id: ID_Output;
}

export interface HigherPowerPromise extends Promise<HigherPower>, Fragmentable {
  id: () => Promise<ID_Output>;
  inventory: <T = InventoryPromise>() => T;
}

export interface HigherPowerSubscription
  extends Promise<AsyncIterator<HigherPower>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  inventory: <T = InventorySubscription>() => T;
}

export interface StrengthSubscriptionPayload {
  mutation: MutationType;
  node: Strength;
  updatedFields: String[];
}

export interface StrengthSubscriptionPayloadPromise
  extends Promise<StrengthSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StrengthPromise>() => T;
  updatedFields: () => Promise<String[]>;
}

export interface StrengthSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StrengthSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StrengthSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
}

export interface Vulnerability {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface VulnerabilityPromise
  extends Promise<Vulnerability>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface VulnerabilitySubscription
  extends Promise<AsyncIterator<Vulnerability>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Acceptance {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface AcceptancePromise extends Promise<Acceptance>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface AcceptanceSubscription
  extends Promise<AsyncIterator<Acceptance>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SufferingConnection {
  pageInfo: PageInfo;
  edges: SufferingEdge[];
}

export interface SufferingConnectionPromise
  extends Promise<SufferingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SufferingEdge>>() => T;
  aggregate: <T = AggregateSufferingPromise>() => T;
}

export interface SufferingConnectionSubscription
  extends Promise<AsyncIterator<SufferingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SufferingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSufferingSubscription>() => T;
}

export interface SufferingSubscriptionPayload {
  mutation: MutationType;
  node: Suffering;
  updatedFields: String[];
  previousValues: SufferingPreviousValues;
}

export interface SufferingSubscriptionPayloadPromise
  extends Promise<SufferingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SufferingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SufferingPreviousValuesPromise>() => T;
}

export interface SufferingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SufferingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SufferingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SufferingPreviousValuesSubscription>() => T;
}

export interface AggregateObsession {
  count: Int;
}

export interface AggregateObsessionPromise
  extends Promise<AggregateObsession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateObsessionSubscription
  extends Promise<AsyncIterator<AggregateObsession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HigherPowerEdge {
  node: HigherPower;
  cursor: String;
}

export interface HigherPowerEdgePromise
  extends Promise<HigherPowerEdge>,
    Fragmentable {
  node: <T = HigherPowerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HigherPowerEdgeSubscription
  extends Promise<AsyncIterator<HigherPowerEdge>>,
    Fragmentable {
  node: <T = HigherPowerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ToxicityPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ToxicityPreviousValuesPromise
  extends Promise<ToxicityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ToxicityPreviousValuesSubscription
  extends Promise<AsyncIterator<ToxicityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ToxicitySubscriptionPayload {
  mutation: MutationType;
  node: Toxicity;
  updatedFields: String[];
  previousValues: ToxicityPreviousValues;
}

export interface ToxicitySubscriptionPayloadPromise
  extends Promise<ToxicitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ToxicityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ToxicityPreviousValuesPromise>() => T;
}

export interface ToxicitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ToxicitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ToxicitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ToxicityPreviousValuesSubscription>() => T;
}

export interface TraumaPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface TraumaPreviousValuesPromise
  extends Promise<TraumaPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface TraumaPreviousValuesSubscription
  extends Promise<AsyncIterator<TraumaPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SufferingPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface SufferingPreviousValuesPromise
  extends Promise<SufferingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface SufferingPreviousValuesSubscription
  extends Promise<AsyncIterator<SufferingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Pride {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface PridePromise extends Promise<Pride>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface PrideSubscription
  extends Promise<AsyncIterator<Pride>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryConnection {}

export interface InventoryConnectionPromise
  extends Promise<InventoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryEdge>>() => T;
  aggregate: <T = AggregateInventoryPromise>() => T;
}

export interface InventoryConnectionSubscription
  extends Promise<AsyncIterator<InventoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventorySubscription>() => T;
}

export interface SalvationEdge {
  node: Salvation;
  cursor: String;
}

export interface SalvationEdgePromise
  extends Promise<SalvationEdge>,
    Fragmentable {
  node: <T = SalvationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SalvationEdgeSubscription
  extends Promise<AsyncIterator<SalvationEdge>>,
    Fragmentable {
  node: <T = SalvationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DefectConnection {}

export interface DefectConnectionPromise
  extends Promise<DefectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DefectEdge>>() => T;
  aggregate: <T = AggregateDefectPromise>() => T;
}

export interface DefectConnectionSubscription
  extends Promise<AsyncIterator<DefectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DefectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDefectSubscription>() => T;
}

export interface Fear {
  id: ID_Output;
  name: String;
  description: String;
  attribute: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface FearPromise extends Promise<Fear>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  attribute: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface FearSubscription
  extends Promise<AsyncIterator<Fear>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  attribute: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Trauma",
    embedded: false
  },
  {
    name: "Toxicity",
    embedded: false
  },
  {
    name: "Suffering",
    embedded: false
  },
  {
    name: "Defect",
    embedded: false
  },
  {
    name: "Anger",
    embedded: false
  },
  {
    name: "SelfPity",
    embedded: false
  },
  {
    name: "Fear",
    embedded: false
  },
  {
    name: "Pride",
    embedded: false
  },
  {
    name: "Resentment",
    embedded: false
  },
  {
    name: "Obsession",
    embedded: false
  },
  {
    name: "Compassion",
    embedded: false
  },
  {
    name: "Courage",
    embedded: false
  },
  {
    name: "Acceptance",
    embedded: false
  },
  {
    name: "Vulnerability",
    embedded: false
  },
  {
    name: "Experience",
    embedded: false
  },
  {
    name: "Armor",
    embedded: false
  },
  {
    name: "Boundary",
    embedded: false
  },
  {
    name: "Loyalty",
    embedded: false
  },
  {
    name: "Honor",
    embedded: false
  },
  {
    name: "Strength",
    embedded: false
  },
  {
    name: "Salvation",
    embedded: false
  },
  {
    name: "Hope",
    embedded: false
  },
  {
    name: "Inventory",
    embedded: false
  },
  {
    name: "HigherPower",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
