// Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  cast: (where?: CastWhereInput) => Promise<boolean>;
  castCharacter: (where?: CastCharacterWhereInput) => Promise<boolean>;
  character: (where?: CharacterWhereInput) => Promise<boolean>;
  characterProcess: (where?: CharacterProcessWhereInput) => Promise<boolean>;
  feeling: (where?: FeelingWhereInput) => Promise<boolean>;
  higherPower: (where?: HigherPowerWhereInput) => Promise<boolean>;
  inventory: (where?: InventoryWhereInput) => Promise<boolean>;
  inventoryPath: (where?: InventoryPathWhereInput) => Promise<boolean>;
  path: (where?: PathWhereInput) => Promise<boolean>;
  pathFeeling: (where?: PathFeelingWhereInput) => Promise<boolean>;
  process: (where?: ProcessWhereInput) => Promise<boolean>;
  processSource: (where?: ProcessSourceWhereInput) => Promise<boolean>;
  source: (where?: SourceWhereInput) => Promise<boolean>;
  sourceFeeling: (where?: SourceFeelingWhereInput) => Promise<boolean>;
  thought: (where?: ThoughtWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  cast: (where: CastWhereUniqueInput) => CastPromise;
  casts: (
    args?: {
      where?: CastWhereInput;
      orderBy?: CastOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Cast>;
  castsConnection: (
    args?: {
      where?: CastWhereInput;
      orderBy?: CastOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CastConnectionPromise;
  castCharacter: (where: CastCharacterWhereUniqueInput) => CastCharacterPromise;
  castCharacters: (
    args?: {
      where?: CastCharacterWhereInput;
      orderBy?: CastCharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CastCharacter>;
  castCharactersConnection: (
    args?: {
      where?: CastCharacterWhereInput;
      orderBy?: CastCharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CastCharacterConnectionPromise;
  character: (where: CharacterWhereUniqueInput) => CharacterPromise;
  characters: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Character>;
  charactersConnection: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CharacterConnectionPromise;
  characterProcess: (
    where: CharacterProcessWhereUniqueInput
  ) => CharacterProcessPromise;
  characterProcesses: (
    args?: {
      where?: CharacterProcessWhereInput;
      orderBy?: CharacterProcessOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CharacterProcess>;
  characterProcessesConnection: (
    args?: {
      where?: CharacterProcessWhereInput;
      orderBy?: CharacterProcessOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CharacterProcessConnectionPromise;
  feeling: (where: FeelingWhereUniqueInput) => FeelingPromise;
  feelings: (
    args?: {
      where?: FeelingWhereInput;
      orderBy?: FeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Feeling>;
  feelingsConnection: (
    args?: {
      where?: FeelingWhereInput;
      orderBy?: FeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FeelingConnectionPromise;
  higherPower: (where: HigherPowerWhereUniqueInput) => HigherPowerPromise;
  higherPowers: (
    args?: {
      where?: HigherPowerWhereInput;
      orderBy?: HigherPowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HigherPower>;
  higherPowersConnection: (
    args?: {
      where?: HigherPowerWhereInput;
      orderBy?: HigherPowerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HigherPowerConnectionPromise;
  inventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  inventories: (
    args?: {
      where?: InventoryWhereInput;
      orderBy?: InventoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Inventory>;
  inventoriesConnection: (
    args?: {
      where?: InventoryWhereInput;
      orderBy?: InventoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InventoryConnectionPromise;
  inventoryPath: (where: InventoryPathWhereUniqueInput) => InventoryPathPromise;
  inventoryPaths: (
    args?: {
      where?: InventoryPathWhereInput;
      orderBy?: InventoryPathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<InventoryPath>;
  inventoryPathsConnection: (
    args?: {
      where?: InventoryPathWhereInput;
      orderBy?: InventoryPathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InventoryPathConnectionPromise;
  path: (where: PathWhereUniqueInput) => PathPromise;
  paths: (
    args?: {
      where?: PathWhereInput;
      orderBy?: PathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Path>;
  pathsConnection: (
    args?: {
      where?: PathWhereInput;
      orderBy?: PathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PathConnectionPromise;
  pathFeeling: (where: PathFeelingWhereUniqueInput) => PathFeelingPromise;
  pathFeelings: (
    args?: {
      where?: PathFeelingWhereInput;
      orderBy?: PathFeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PathFeeling>;
  pathFeelingsConnection: (
    args?: {
      where?: PathFeelingWhereInput;
      orderBy?: PathFeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PathFeelingConnectionPromise;
  process: (where: ProcessWhereUniqueInput) => ProcessPromise;
  processes: (
    args?: {
      where?: ProcessWhereInput;
      orderBy?: ProcessOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Process>;
  processesConnection: (
    args?: {
      where?: ProcessWhereInput;
      orderBy?: ProcessOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProcessConnectionPromise;
  processSource: (where: ProcessSourceWhereUniqueInput) => ProcessSourcePromise;
  processSources: (
    args?: {
      where?: ProcessSourceWhereInput;
      orderBy?: ProcessSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ProcessSource>;
  processSourcesConnection: (
    args?: {
      where?: ProcessSourceWhereInput;
      orderBy?: ProcessSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProcessSourceConnectionPromise;
  source: (where: SourceWhereUniqueInput) => SourcePromise;
  sources: (
    args?: {
      where?: SourceWhereInput;
      orderBy?: SourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Source>;
  sourcesConnection: (
    args?: {
      where?: SourceWhereInput;
      orderBy?: SourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SourceConnectionPromise;
  sourceFeeling: (where: SourceFeelingWhereUniqueInput) => SourceFeelingPromise;
  sourceFeelings: (
    args?: {
      where?: SourceFeelingWhereInput;
      orderBy?: SourceFeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SourceFeeling>;
  sourceFeelingsConnection: (
    args?: {
      where?: SourceFeelingWhereInput;
      orderBy?: SourceFeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SourceFeelingConnectionPromise;
  thought: (where: ThoughtWhereUniqueInput) => ThoughtPromise;
  thoughts: (
    args?: {
      where?: ThoughtWhereInput;
      orderBy?: ThoughtOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Thought>;
  thoughtsConnection: (
    args?: {
      where?: ThoughtWhereInput;
      orderBy?: ThoughtOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ThoughtConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCast: (data: CastCreateInput) => CastPromise;
  updateCast: (
    args: { data: CastUpdateInput; where: CastWhereUniqueInput }
  ) => CastPromise;
  upsertCast: (
    args: {
      where: CastWhereUniqueInput;
      create: CastCreateInput;
      update: CastUpdateInput;
    }
  ) => CastPromise;
  deleteCast: (where: CastWhereUniqueInput) => CastPromise;
  deleteManyCasts: (where?: CastWhereInput) => BatchPayloadPromise;
  createCastCharacter: (data: CastCharacterCreateInput) => CastCharacterPromise;
  updateCastCharacter: (
    args: {
      data: CastCharacterUpdateInput;
      where: CastCharacterWhereUniqueInput;
    }
  ) => CastCharacterPromise;
  updateManyCastCharacters: (
    args: {
      data: CastCharacterUpdateManyMutationInput;
      where?: CastCharacterWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCastCharacter: (
    args: {
      where: CastCharacterWhereUniqueInput;
      create: CastCharacterCreateInput;
      update: CastCharacterUpdateInput;
    }
  ) => CastCharacterPromise;
  deleteCastCharacter: (
    where: CastCharacterWhereUniqueInput
  ) => CastCharacterPromise;
  deleteManyCastCharacters: (
    where?: CastCharacterWhereInput
  ) => BatchPayloadPromise;
  createCharacter: (data: CharacterCreateInput) => CharacterPromise;
  updateCharacter: (
    args: { data: CharacterUpdateInput; where: CharacterWhereUniqueInput }
  ) => CharacterPromise;
  updateManyCharacters: (
    args: {
      data: CharacterUpdateManyMutationInput;
      where?: CharacterWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCharacter: (
    args: {
      where: CharacterWhereUniqueInput;
      create: CharacterCreateInput;
      update: CharacterUpdateInput;
    }
  ) => CharacterPromise;
  deleteCharacter: (where: CharacterWhereUniqueInput) => CharacterPromise;
  deleteManyCharacters: (where?: CharacterWhereInput) => BatchPayloadPromise;
  createCharacterProcess: (
    data: CharacterProcessCreateInput
  ) => CharacterProcessPromise;
  updateCharacterProcess: (
    args: {
      data: CharacterProcessUpdateInput;
      where: CharacterProcessWhereUniqueInput;
    }
  ) => CharacterProcessPromise;
  updateManyCharacterProcesses: (
    args: {
      data: CharacterProcessUpdateManyMutationInput;
      where?: CharacterProcessWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCharacterProcess: (
    args: {
      where: CharacterProcessWhereUniqueInput;
      create: CharacterProcessCreateInput;
      update: CharacterProcessUpdateInput;
    }
  ) => CharacterProcessPromise;
  deleteCharacterProcess: (
    where: CharacterProcessWhereUniqueInput
  ) => CharacterProcessPromise;
  deleteManyCharacterProcesses: (
    where?: CharacterProcessWhereInput
  ) => BatchPayloadPromise;
  createFeeling: (data: FeelingCreateInput) => FeelingPromise;
  updateFeeling: (
    args: { data: FeelingUpdateInput; where: FeelingWhereUniqueInput }
  ) => FeelingPromise;
  updateManyFeelings: (
    args: { data: FeelingUpdateManyMutationInput; where?: FeelingWhereInput }
  ) => BatchPayloadPromise;
  upsertFeeling: (
    args: {
      where: FeelingWhereUniqueInput;
      create: FeelingCreateInput;
      update: FeelingUpdateInput;
    }
  ) => FeelingPromise;
  deleteFeeling: (where: FeelingWhereUniqueInput) => FeelingPromise;
  deleteManyFeelings: (where?: FeelingWhereInput) => BatchPayloadPromise;
  createHigherPower: (data: HigherPowerCreateInput) => HigherPowerPromise;
  updateHigherPower: (
    args: { data: HigherPowerUpdateInput; where: HigherPowerWhereUniqueInput }
  ) => HigherPowerPromise;
  upsertHigherPower: (
    args: {
      where: HigherPowerWhereUniqueInput;
      create: HigherPowerCreateInput;
      update: HigherPowerUpdateInput;
    }
  ) => HigherPowerPromise;
  deleteHigherPower: (where: HigherPowerWhereUniqueInput) => HigherPowerPromise;
  deleteManyHigherPowers: (
    where?: HigherPowerWhereInput
  ) => BatchPayloadPromise;
  createInventory: (data: InventoryCreateInput) => InventoryPromise;
  updateInventory: (
    args: { data: InventoryUpdateInput; where: InventoryWhereUniqueInput }
  ) => InventoryPromise;
  upsertInventory: (
    args: {
      where: InventoryWhereUniqueInput;
      create: InventoryCreateInput;
      update: InventoryUpdateInput;
    }
  ) => InventoryPromise;
  deleteInventory: (where: InventoryWhereUniqueInput) => InventoryPromise;
  deleteManyInventories: (where?: InventoryWhereInput) => BatchPayloadPromise;
  createInventoryPath: (data: InventoryPathCreateInput) => InventoryPathPromise;
  updateInventoryPath: (
    args: {
      data: InventoryPathUpdateInput;
      where: InventoryPathWhereUniqueInput;
    }
  ) => InventoryPathPromise;
  updateManyInventoryPaths: (
    args: {
      data: InventoryPathUpdateManyMutationInput;
      where?: InventoryPathWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertInventoryPath: (
    args: {
      where: InventoryPathWhereUniqueInput;
      create: InventoryPathCreateInput;
      update: InventoryPathUpdateInput;
    }
  ) => InventoryPathPromise;
  deleteInventoryPath: (
    where: InventoryPathWhereUniqueInput
  ) => InventoryPathPromise;
  deleteManyInventoryPaths: (
    where?: InventoryPathWhereInput
  ) => BatchPayloadPromise;
  createPath: (data: PathCreateInput) => PathPromise;
  updatePath: (
    args: { data: PathUpdateInput; where: PathWhereUniqueInput }
  ) => PathPromise;
  updateManyPaths: (
    args: { data: PathUpdateManyMutationInput; where?: PathWhereInput }
  ) => BatchPayloadPromise;
  upsertPath: (
    args: {
      where: PathWhereUniqueInput;
      create: PathCreateInput;
      update: PathUpdateInput;
    }
  ) => PathPromise;
  deletePath: (where: PathWhereUniqueInput) => PathPromise;
  deleteManyPaths: (where?: PathWhereInput) => BatchPayloadPromise;
  createPathFeeling: (data: PathFeelingCreateInput) => PathFeelingPromise;
  updatePathFeeling: (
    args: { data: PathFeelingUpdateInput; where: PathFeelingWhereUniqueInput }
  ) => PathFeelingPromise;
  updateManyPathFeelings: (
    args: {
      data: PathFeelingUpdateManyMutationInput;
      where?: PathFeelingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPathFeeling: (
    args: {
      where: PathFeelingWhereUniqueInput;
      create: PathFeelingCreateInput;
      update: PathFeelingUpdateInput;
    }
  ) => PathFeelingPromise;
  deletePathFeeling: (where: PathFeelingWhereUniqueInput) => PathFeelingPromise;
  deleteManyPathFeelings: (
    where?: PathFeelingWhereInput
  ) => BatchPayloadPromise;
  createProcess: (data: ProcessCreateInput) => ProcessPromise;
  updateProcess: (
    args: { data: ProcessUpdateInput; where: ProcessWhereUniqueInput }
  ) => ProcessPromise;
  updateManyProcesses: (
    args: { data: ProcessUpdateManyMutationInput; where?: ProcessWhereInput }
  ) => BatchPayloadPromise;
  upsertProcess: (
    args: {
      where: ProcessWhereUniqueInput;
      create: ProcessCreateInput;
      update: ProcessUpdateInput;
    }
  ) => ProcessPromise;
  deleteProcess: (where: ProcessWhereUniqueInput) => ProcessPromise;
  deleteManyProcesses: (where?: ProcessWhereInput) => BatchPayloadPromise;
  createProcessSource: (data: ProcessSourceCreateInput) => ProcessSourcePromise;
  updateProcessSource: (
    args: {
      data: ProcessSourceUpdateInput;
      where: ProcessSourceWhereUniqueInput;
    }
  ) => ProcessSourcePromise;
  updateManyProcessSources: (
    args: {
      data: ProcessSourceUpdateManyMutationInput;
      where?: ProcessSourceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProcessSource: (
    args: {
      where: ProcessSourceWhereUniqueInput;
      create: ProcessSourceCreateInput;
      update: ProcessSourceUpdateInput;
    }
  ) => ProcessSourcePromise;
  deleteProcessSource: (
    where: ProcessSourceWhereUniqueInput
  ) => ProcessSourcePromise;
  deleteManyProcessSources: (
    where?: ProcessSourceWhereInput
  ) => BatchPayloadPromise;
  createSource: (data: SourceCreateInput) => SourcePromise;
  updateSource: (
    args: { data: SourceUpdateInput; where: SourceWhereUniqueInput }
  ) => SourcePromise;
  updateManySources: (
    args: { data: SourceUpdateManyMutationInput; where?: SourceWhereInput }
  ) => BatchPayloadPromise;
  upsertSource: (
    args: {
      where: SourceWhereUniqueInput;
      create: SourceCreateInput;
      update: SourceUpdateInput;
    }
  ) => SourcePromise;
  deleteSource: (where: SourceWhereUniqueInput) => SourcePromise;
  deleteManySources: (where?: SourceWhereInput) => BatchPayloadPromise;
  createSourceFeeling: (data: SourceFeelingCreateInput) => SourceFeelingPromise;
  updateSourceFeeling: (
    args: {
      data: SourceFeelingUpdateInput;
      where: SourceFeelingWhereUniqueInput;
    }
  ) => SourceFeelingPromise;
  updateManySourceFeelings: (
    args: {
      data: SourceFeelingUpdateManyMutationInput;
      where?: SourceFeelingWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSourceFeeling: (
    args: {
      where: SourceFeelingWhereUniqueInput;
      create: SourceFeelingCreateInput;
      update: SourceFeelingUpdateInput;
    }
  ) => SourceFeelingPromise;
  deleteSourceFeeling: (
    where: SourceFeelingWhereUniqueInput
  ) => SourceFeelingPromise;
  deleteManySourceFeelings: (
    where?: SourceFeelingWhereInput
  ) => BatchPayloadPromise;
  createThought: (data: ThoughtCreateInput) => ThoughtPromise;
  updateThought: (
    args: { data: ThoughtUpdateInput; where: ThoughtWhereUniqueInput }
  ) => ThoughtPromise;
  updateManyThoughts: (
    args: { data: ThoughtUpdateManyMutationInput; where?: ThoughtWhereInput }
  ) => BatchPayloadPromise;
  upsertThought: (
    args: {
      where: ThoughtWhereUniqueInput;
      create: ThoughtCreateInput;
      update: ThoughtUpdateInput;
    }
  ) => ThoughtPromise;
  deleteThought: (where: ThoughtWhereUniqueInput) => ThoughtPromise;
  deleteManyThoughts: (where?: ThoughtWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  cast: (
    where?: CastSubscriptionWhereInput
  ) => CastSubscriptionPayloadSubscription;
  castCharacter: (
    where?: CastCharacterSubscriptionWhereInput
  ) => CastCharacterSubscriptionPayloadSubscription;
  character: (
    where?: CharacterSubscriptionWhereInput
  ) => CharacterSubscriptionPayloadSubscription;
  characterProcess: (
    where?: CharacterProcessSubscriptionWhereInput
  ) => CharacterProcessSubscriptionPayloadSubscription;
  feeling: (
    where?: FeelingSubscriptionWhereInput
  ) => FeelingSubscriptionPayloadSubscription;
  higherPower: (
    where?: HigherPowerSubscriptionWhereInput
  ) => HigherPowerSubscriptionPayloadSubscription;
  inventory: (
    where?: InventorySubscriptionWhereInput
  ) => InventorySubscriptionPayloadSubscription;
  inventoryPath: (
    where?: InventoryPathSubscriptionWhereInput
  ) => InventoryPathSubscriptionPayloadSubscription;
  path: (
    where?: PathSubscriptionWhereInput
  ) => PathSubscriptionPayloadSubscription;
  pathFeeling: (
    where?: PathFeelingSubscriptionWhereInput
  ) => PathFeelingSubscriptionPayloadSubscription;
  process: (
    where?: ProcessSubscriptionWhereInput
  ) => ProcessSubscriptionPayloadSubscription;
  processSource: (
    where?: ProcessSourceSubscriptionWhereInput
  ) => ProcessSourceSubscriptionPayloadSubscription;
  source: (
    where?: SourceSubscriptionWhereInput
  ) => SourceSubscriptionPayloadSubscription;
  sourceFeeling: (
    where?: SourceFeelingSubscriptionWhereInput
  ) => SourceFeelingSubscriptionPayloadSubscription;
  thought: (
    where?: ThoughtSubscriptionWhereInput
  ) => ThoughtSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type InventoryPathOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SourceFeelingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FeelingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CastCharacterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PathOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CharacterProcessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HigherPowerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ThoughtOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "quality_ASC"
  | "quality_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "prayedAt_ASC"
  | "prayedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC";

export type ProcessSourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CastOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CharacterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "process_ASC"
  | "process_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PathFeelingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InventoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProcessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface ThoughtUpdateManyInput {
  create?: ThoughtCreateInput[] | ThoughtCreateInput;
  update?:
    | ThoughtUpdateWithWhereUniqueNestedInput[]
    | ThoughtUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ThoughtUpsertWithWhereUniqueNestedInput[]
    | ThoughtUpsertWithWhereUniqueNestedInput;
  delete?: ThoughtWhereUniqueInput[] | ThoughtWhereUniqueInput;
  connect?: ThoughtWhereUniqueInput[] | ThoughtWhereUniqueInput;
  set?: ThoughtWhereUniqueInput[] | ThoughtWhereUniqueInput;
  disconnect?: ThoughtWhereUniqueInput[] | ThoughtWhereUniqueInput;
  deleteMany?: ThoughtScalarWhereInput[] | ThoughtScalarWhereInput;
  updateMany?:
    | ThoughtUpdateManyWithWhereNestedInput[]
    | ThoughtUpdateManyWithWhereNestedInput;
}

export type CastWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SourceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface InventoryPathCreateManyInput {
  create?: InventoryPathCreateInput[] | InventoryPathCreateInput;
  connect?: InventoryPathWhereUniqueInput[] | InventoryPathWhereUniqueInput;
}

export interface PathFeelingUpsertWithWhereUniqueNestedInput {
  where: PathFeelingWhereUniqueInput;
  update: PathFeelingUpdateDataInput;
  create: PathFeelingCreateInput;
}

export interface SourceFeelingUpdateManyWithWhereNestedInput {
  where: SourceFeelingScalarWhereInput;
  data: SourceFeelingUpdateManyDataInput;
}

export interface SourceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: SourceWhereInput[] | SourceWhereInput;
  OR?: SourceWhereInput[] | SourceWhereInput;
  NOT?: SourceWhereInput[] | SourceWhereInput;
}

export interface CastWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  characters_every?: CastCharacterWhereInput;
  characters_some?: CastCharacterWhereInput;
  characters_none?: CastCharacterWhereInput;
  AND?: CastWhereInput[] | CastWhereInput;
  OR?: CastWhereInput[] | CastWhereInput;
  NOT?: CastWhereInput[] | CastWhereInput;
}

export interface CastCharacterWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  process?: CharacterProcessWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CastCharacterWhereInput[] | CastCharacterWhereInput;
  OR?: CastCharacterWhereInput[] | CastCharacterWhereInput;
  NOT?: CastCharacterWhereInput[] | CastCharacterWhereInput;
}

export interface SourceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SourceWhereInput;
  AND?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
  OR?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
  NOT?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
}

export interface PathFeelingUpdateDataInput {
  title?: String;
  thoughts?: ThoughtUpdateManyInput;
}

export interface ProcessSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProcessWhereInput;
  AND?: ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput;
  OR?: ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput;
  NOT?: ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput;
}

export interface PathFeelingUpdateWithWhereUniqueNestedInput {
  where: PathFeelingWhereUniqueInput;
  data: PathFeelingUpdateDataInput;
}

export type CastCharacterWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PathFeelingUpdateManyInput {
  create?: PathFeelingCreateInput[] | PathFeelingCreateInput;
  update?:
    | PathFeelingUpdateWithWhereUniqueNestedInput[]
    | PathFeelingUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PathFeelingUpsertWithWhereUniqueNestedInput[]
    | PathFeelingUpsertWithWhereUniqueNestedInput;
  delete?: PathFeelingWhereUniqueInput[] | PathFeelingWhereUniqueInput;
  connect?: PathFeelingWhereUniqueInput[] | PathFeelingWhereUniqueInput;
  set?: PathFeelingWhereUniqueInput[] | PathFeelingWhereUniqueInput;
  disconnect?: PathFeelingWhereUniqueInput[] | PathFeelingWhereUniqueInput;
  deleteMany?: PathFeelingScalarWhereInput[] | PathFeelingScalarWhereInput;
  updateMany?:
    | PathFeelingUpdateManyWithWhereNestedInput[]
    | PathFeelingUpdateManyWithWhereNestedInput;
}

export interface InventoryPathSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InventoryPathWhereInput;
  AND?:
    | InventoryPathSubscriptionWhereInput[]
    | InventoryPathSubscriptionWhereInput;
  OR?:
    | InventoryPathSubscriptionWhereInput[]
    | InventoryPathSubscriptionWhereInput;
  NOT?:
    | InventoryPathSubscriptionWhereInput[]
    | InventoryPathSubscriptionWhereInput;
}

export type SourceFeelingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type CharacterWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface InventoryPathUpdateDataInput {
  title?: String;
  feelings?: PathFeelingUpdateManyInput;
}

export interface CharacterWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  process?: ID_Input;
  process_not?: ID_Input;
  process_in?: ID_Input[] | ID_Input;
  process_not_in?: ID_Input[] | ID_Input;
  process_lt?: ID_Input;
  process_lte?: ID_Input;
  process_gt?: ID_Input;
  process_gte?: ID_Input;
  process_contains?: ID_Input;
  process_not_contains?: ID_Input;
  process_starts_with?: ID_Input;
  process_not_starts_with?: ID_Input;
  process_ends_with?: ID_Input;
  process_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CharacterWhereInput[] | CharacterWhereInput;
  OR?: CharacterWhereInput[] | CharacterWhereInput;
  NOT?: CharacterWhereInput[] | CharacterWhereInput;
}

export interface InventoryPathUpdateWithWhereUniqueNestedInput {
  where: InventoryPathWhereUniqueInput;
  data: InventoryPathUpdateDataInput;
}

export interface CharacterProcessSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CharacterProcessWhereInput;
  AND?:
    | CharacterProcessSubscriptionWhereInput[]
    | CharacterProcessSubscriptionWhereInput;
  OR?:
    | CharacterProcessSubscriptionWhereInput[]
    | CharacterProcessSubscriptionWhereInput;
  NOT?:
    | CharacterProcessSubscriptionWhereInput[]
    | CharacterProcessSubscriptionWhereInput;
}

export interface InventoryPathUpdateManyInput {
  create?: InventoryPathCreateInput[] | InventoryPathCreateInput;
  update?:
    | InventoryPathUpdateWithWhereUniqueNestedInput[]
    | InventoryPathUpdateWithWhereUniqueNestedInput;
  upsert?:
    | InventoryPathUpsertWithWhereUniqueNestedInput[]
    | InventoryPathUpsertWithWhereUniqueNestedInput;
  delete?: InventoryPathWhereUniqueInput[] | InventoryPathWhereUniqueInput;
  connect?: InventoryPathWhereUniqueInput[] | InventoryPathWhereUniqueInput;
  set?: InventoryPathWhereUniqueInput[] | InventoryPathWhereUniqueInput;
  disconnect?: InventoryPathWhereUniqueInput[] | InventoryPathWhereUniqueInput;
  deleteMany?: InventoryPathScalarWhereInput[] | InventoryPathScalarWhereInput;
  updateMany?:
    | InventoryPathUpdateManyWithWhereNestedInput[]
    | InventoryPathUpdateManyWithWhereNestedInput;
}

export interface CastCharacterSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CastCharacterWhereInput;
  AND?:
    | CastCharacterSubscriptionWhereInput[]
    | CastCharacterSubscriptionWhereInput;
  OR?:
    | CastCharacterSubscriptionWhereInput[]
    | CastCharacterSubscriptionWhereInput;
  NOT?:
    | CastCharacterSubscriptionWhereInput[]
    | CastCharacterSubscriptionWhereInput;
}

export type ThoughtWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CastSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CastWhereInput;
  AND?: CastSubscriptionWhereInput[] | CastSubscriptionWhereInput;
  OR?: CastSubscriptionWhereInput[] | CastSubscriptionWhereInput;
  NOT?: CastSubscriptionWhereInput[] | CastSubscriptionWhereInput;
}

export interface InventoryUpdateDataInput {
  paths?: InventoryPathUpdateManyInput;
}

export interface ThoughtUpdateInput {
  character?: ID_Input;
  thought?: String;
  quality?: Boolean;
  source?: ID_Input;
  process?: ID_Input;
  path?: ID_Input;
  feeling?: ID_Input;
  prayedAt?: DateTimeInput;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface InventoryUpdateOneInput {
  create?: InventoryCreateInput;
  update?: InventoryUpdateDataInput;
  upsert?: InventoryUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: InventoryWhereUniqueInput;
}

export type FeelingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HigherPowerUpdateInput {
  inventory?: InventoryUpdateOneInput;
  cast?: CastUpdateOneInput;
}

export interface FeelingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: FeelingWhereInput[] | FeelingWhereInput;
  OR?: FeelingWhereInput[] | FeelingWhereInput;
  NOT?: FeelingWhereInput[] | FeelingWhereInput;
}

export interface SourceUpdatefeelingsInput {
  set?: ID_Input[] | ID_Input;
}

export interface SourceCreatefeelingsInput {
  set?: ID_Input[] | ID_Input;
}

export interface CastCreateInput {
  id?: ID_Input;
  characters?: CastCharacterCreateManyInput;
}

export interface SourceCreateInput {
  id?: ID_Input;
  title: String;
  feelings?: SourceCreatefeelingsInput;
}

export interface CastCharacterCreateManyInput {
  create?: CastCharacterCreateInput[] | CastCharacterCreateInput;
  connect?: CastCharacterWhereUniqueInput[] | CastCharacterWhereUniqueInput;
}

export interface InventoryPathWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  feelings_every?: PathFeelingWhereInput;
  feelings_some?: PathFeelingWhereInput;
  feelings_none?: PathFeelingWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: InventoryPathWhereInput[] | InventoryPathWhereInput;
  OR?: InventoryPathWhereInput[] | InventoryPathWhereInput;
  NOT?: InventoryPathWhereInput[] | InventoryPathWhereInput;
}

export interface CastCharacterCreateInput {
  id?: ID_Input;
  title: String;
  description?: String;
  process: CharacterProcessCreateOneInput;
}

export interface ProcessSourceUpdateInput {
  title?: String;
  feelings?: SourceFeelingUpdateManyInput;
}

export interface CharacterProcessCreateOneInput {
  create?: CharacterProcessCreateInput;
  connect?: CharacterProcessWhereUniqueInput;
}

export interface ThoughtWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: ID_Input;
  character_not?: ID_Input;
  character_in?: ID_Input[] | ID_Input;
  character_not_in?: ID_Input[] | ID_Input;
  character_lt?: ID_Input;
  character_lte?: ID_Input;
  character_gt?: ID_Input;
  character_gte?: ID_Input;
  character_contains?: ID_Input;
  character_not_contains?: ID_Input;
  character_starts_with?: ID_Input;
  character_not_starts_with?: ID_Input;
  character_ends_with?: ID_Input;
  character_not_ends_with?: ID_Input;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  quality?: Boolean;
  quality_not?: Boolean;
  source?: ID_Input;
  source_not?: ID_Input;
  source_in?: ID_Input[] | ID_Input;
  source_not_in?: ID_Input[] | ID_Input;
  source_lt?: ID_Input;
  source_lte?: ID_Input;
  source_gt?: ID_Input;
  source_gte?: ID_Input;
  source_contains?: ID_Input;
  source_not_contains?: ID_Input;
  source_starts_with?: ID_Input;
  source_not_starts_with?: ID_Input;
  source_ends_with?: ID_Input;
  source_not_ends_with?: ID_Input;
  process?: ID_Input;
  process_not?: ID_Input;
  process_in?: ID_Input[] | ID_Input;
  process_not_in?: ID_Input[] | ID_Input;
  process_lt?: ID_Input;
  process_lte?: ID_Input;
  process_gt?: ID_Input;
  process_gte?: ID_Input;
  process_contains?: ID_Input;
  process_not_contains?: ID_Input;
  process_starts_with?: ID_Input;
  process_not_starts_with?: ID_Input;
  process_ends_with?: ID_Input;
  process_not_ends_with?: ID_Input;
  path?: ID_Input;
  path_not?: ID_Input;
  path_in?: ID_Input[] | ID_Input;
  path_not_in?: ID_Input[] | ID_Input;
  path_lt?: ID_Input;
  path_lte?: ID_Input;
  path_gt?: ID_Input;
  path_gte?: ID_Input;
  path_contains?: ID_Input;
  path_not_contains?: ID_Input;
  path_starts_with?: ID_Input;
  path_not_starts_with?: ID_Input;
  path_ends_with?: ID_Input;
  path_not_ends_with?: ID_Input;
  feeling?: ID_Input;
  feeling_not?: ID_Input;
  feeling_in?: ID_Input[] | ID_Input;
  feeling_not_in?: ID_Input[] | ID_Input;
  feeling_lt?: ID_Input;
  feeling_lte?: ID_Input;
  feeling_gt?: ID_Input;
  feeling_gte?: ID_Input;
  feeling_contains?: ID_Input;
  feeling_not_contains?: ID_Input;
  feeling_starts_with?: ID_Input;
  feeling_not_starts_with?: ID_Input;
  feeling_ends_with?: ID_Input;
  feeling_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  prayedAt?: DateTimeInput;
  prayedAt_not?: DateTimeInput;
  prayedAt_in?: DateTimeInput[] | DateTimeInput;
  prayedAt_not_in?: DateTimeInput[] | DateTimeInput;
  prayedAt_lt?: DateTimeInput;
  prayedAt_lte?: DateTimeInput;
  prayedAt_gt?: DateTimeInput;
  prayedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: ThoughtWhereInput[] | ThoughtWhereInput;
  OR?: ThoughtWhereInput[] | ThoughtWhereInput;
  NOT?: ThoughtWhereInput[] | ThoughtWhereInput;
}

export interface CharacterProcessCreateInput {
  id?: ID_Input;
  title: String;
  sources?: ProcessSourceCreateManyInput;
}

export interface HigherPowerWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  inventory?: InventoryWhereInput;
  cast?: CastWhereInput;
  AND?: HigherPowerWhereInput[] | HigherPowerWhereInput;
  OR?: HigherPowerWhereInput[] | HigherPowerWhereInput;
  NOT?: HigherPowerWhereInput[] | HigherPowerWhereInput;
}

export interface ProcessSourceCreateManyInput {
  create?: ProcessSourceCreateInput[] | ProcessSourceCreateInput;
  connect?: ProcessSourceWhereUniqueInput[] | ProcessSourceWhereUniqueInput;
}

export interface SourceFeelingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  thoughts_every?: ThoughtWhereInput;
  thoughts_some?: ThoughtWhereInput;
  thoughts_none?: ThoughtWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: SourceFeelingWhereInput[] | SourceFeelingWhereInput;
  OR?: SourceFeelingWhereInput[] | SourceFeelingWhereInput;
  NOT?: SourceFeelingWhereInput[] | SourceFeelingWhereInput;
}

export interface ProcessSourceCreateInput {
  id?: ID_Input;
  title: String;
  feelings?: SourceFeelingCreateManyInput;
}

export interface ProcessCreatesourcesInput {
  set?: ID_Input[] | ID_Input;
}

export interface SourceFeelingCreateManyInput {
  create?: SourceFeelingCreateInput[] | SourceFeelingCreateInput;
  connect?: SourceFeelingWhereUniqueInput[] | SourceFeelingWhereUniqueInput;
}

export type InventoryWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SourceFeelingCreateInput {
  id?: ID_Input;
  title: String;
  thoughts?: ThoughtCreateManyInput;
}

export interface PathFeelingUpdateManyMutationInput {
  title?: String;
}

export interface ThoughtCreateManyInput {
  create?: ThoughtCreateInput[] | ThoughtCreateInput;
  connect?: ThoughtWhereUniqueInput[] | ThoughtWhereUniqueInput;
}

export interface PathUpdateManyMutationInput {
  title?: String;
  feelings?: PathUpdatefeelingsInput;
}

export interface ThoughtCreateInput {
  id?: ID_Input;
  character?: ID_Input;
  thought: String;
  quality?: Boolean;
  source?: ID_Input;
  process?: ID_Input;
  path?: ID_Input;
  feeling: ID_Input;
  prayedAt?: DateTimeInput;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface PathUpdatefeelingsInput {
  set?: ID_Input[] | ID_Input;
}

export interface CastUpdateInput {
  characters?: CastCharacterUpdateManyInput;
}

export interface PathCreatefeelingsInput {
  set?: ID_Input[] | ID_Input;
}

export interface CastCharacterUpdateManyInput {
  create?: CastCharacterCreateInput[] | CastCharacterCreateInput;
  update?:
    | CastCharacterUpdateWithWhereUniqueNestedInput[]
    | CastCharacterUpdateWithWhereUniqueNestedInput;
  upsert?:
    | CastCharacterUpsertWithWhereUniqueNestedInput[]
    | CastCharacterUpsertWithWhereUniqueNestedInput;
  delete?: CastCharacterWhereUniqueInput[] | CastCharacterWhereUniqueInput;
  connect?: CastCharacterWhereUniqueInput[] | CastCharacterWhereUniqueInput;
  set?: CastCharacterWhereUniqueInput[] | CastCharacterWhereUniqueInput;
  disconnect?: CastCharacterWhereUniqueInput[] | CastCharacterWhereUniqueInput;
  deleteMany?: CastCharacterScalarWhereInput[] | CastCharacterScalarWhereInput;
  updateMany?:
    | CastCharacterUpdateManyWithWhereNestedInput[]
    | CastCharacterUpdateManyWithWhereNestedInput;
}

export interface PathCreateInput {
  id?: ID_Input;
  title: String;
  feelings?: PathCreatefeelingsInput;
}

export interface CastCharacterUpdateWithWhereUniqueNestedInput {
  where: CastCharacterWhereUniqueInput;
  data: CastCharacterUpdateDataInput;
}

export interface CharacterProcessWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  sources_every?: ProcessSourceWhereInput;
  sources_some?: ProcessSourceWhereInput;
  sources_none?: ProcessSourceWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CharacterProcessWhereInput[] | CharacterProcessWhereInput;
  OR?: CharacterProcessWhereInput[] | CharacterProcessWhereInput;
  NOT?: CharacterProcessWhereInput[] | CharacterProcessWhereInput;
}

export interface CastCharacterUpdateDataInput {
  title?: String;
  description?: String;
  process?: CharacterProcessUpdateOneRequiredInput;
}

export interface InventoryPathUpdateInput {
  title?: String;
  feelings?: PathFeelingUpdateManyInput;
}

export interface CharacterProcessUpdateOneRequiredInput {
  create?: CharacterProcessCreateInput;
  update?: CharacterProcessUpdateDataInput;
  upsert?: CharacterProcessUpsertNestedInput;
  connect?: CharacterProcessWhereUniqueInput;
}

export type PathFeelingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CharacterProcessUpdateDataInput {
  title?: String;
  sources?: ProcessSourceUpdateManyInput;
}

export interface CastUpdateDataInput {
  characters?: CastCharacterUpdateManyInput;
}

export interface ProcessSourceUpdateManyInput {
  create?: ProcessSourceCreateInput[] | ProcessSourceCreateInput;
  update?:
    | ProcessSourceUpdateWithWhereUniqueNestedInput[]
    | ProcessSourceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ProcessSourceUpsertWithWhereUniqueNestedInput[]
    | ProcessSourceUpsertWithWhereUniqueNestedInput;
  delete?: ProcessSourceWhereUniqueInput[] | ProcessSourceWhereUniqueInput;
  connect?: ProcessSourceWhereUniqueInput[] | ProcessSourceWhereUniqueInput;
  set?: ProcessSourceWhereUniqueInput[] | ProcessSourceWhereUniqueInput;
  disconnect?: ProcessSourceWhereUniqueInput[] | ProcessSourceWhereUniqueInput;
  deleteMany?: ProcessSourceScalarWhereInput[] | ProcessSourceScalarWhereInput;
  updateMany?:
    | ProcessSourceUpdateManyWithWhereNestedInput[]
    | ProcessSourceUpdateManyWithWhereNestedInput;
}

export type ProcessWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProcessSourceUpdateWithWhereUniqueNestedInput {
  where: ProcessSourceWhereUniqueInput;
  data: ProcessSourceUpdateDataInput;
}

export interface ProcessWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProcessWhereInput[] | ProcessWhereInput;
  OR?: ProcessWhereInput[] | ProcessWhereInput;
  NOT?: ProcessWhereInput[] | ProcessWhereInput;
}

export interface ProcessSourceUpdateDataInput {
  title?: String;
  feelings?: SourceFeelingUpdateManyInput;
}

export interface InventoryPathUpdateManyWithWhereNestedInput {
  where: InventoryPathScalarWhereInput;
  data: InventoryPathUpdateManyDataInput;
}

export interface SourceFeelingUpdateManyInput {
  create?: SourceFeelingCreateInput[] | SourceFeelingCreateInput;
  update?:
    | SourceFeelingUpdateWithWhereUniqueNestedInput[]
    | SourceFeelingUpdateWithWhereUniqueNestedInput;
  upsert?:
    | SourceFeelingUpsertWithWhereUniqueNestedInput[]
    | SourceFeelingUpsertWithWhereUniqueNestedInput;
  delete?: SourceFeelingWhereUniqueInput[] | SourceFeelingWhereUniqueInput;
  connect?: SourceFeelingWhereUniqueInput[] | SourceFeelingWhereUniqueInput;
  set?: SourceFeelingWhereUniqueInput[] | SourceFeelingWhereUniqueInput;
  disconnect?: SourceFeelingWhereUniqueInput[] | SourceFeelingWhereUniqueInput;
  deleteMany?: SourceFeelingScalarWhereInput[] | SourceFeelingScalarWhereInput;
  updateMany?:
    | SourceFeelingUpdateManyWithWhereNestedInput[]
    | SourceFeelingUpdateManyWithWhereNestedInput;
}

export interface InventoryPathUpsertWithWhereUniqueNestedInput {
  where: InventoryPathWhereUniqueInput;
  update: InventoryPathUpdateDataInput;
  create: InventoryPathCreateInput;
}

export interface SourceFeelingUpdateWithWhereUniqueNestedInput {
  where: SourceFeelingWhereUniqueInput;
  data: SourceFeelingUpdateDataInput;
}

export interface PathFeelingUpdateManyDataInput {
  title?: String;
}

export interface SourceFeelingUpdateDataInput {
  title?: String;
  thoughts?: ThoughtUpdateManyInput;
}

export interface PathFeelingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PathFeelingScalarWhereInput[] | PathFeelingScalarWhereInput;
  OR?: PathFeelingScalarWhereInput[] | PathFeelingScalarWhereInput;
  NOT?: PathFeelingScalarWhereInput[] | PathFeelingScalarWhereInput;
}

export interface CastCreateOneInput {
  create?: CastCreateInput;
  connect?: CastWhereUniqueInput;
}

export interface SourceFeelingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SourceFeelingWhereInput;
  AND?:
    | SourceFeelingSubscriptionWhereInput[]
    | SourceFeelingSubscriptionWhereInput;
  OR?:
    | SourceFeelingSubscriptionWhereInput[]
    | SourceFeelingSubscriptionWhereInput;
  NOT?:
    | SourceFeelingSubscriptionWhereInput[]
    | SourceFeelingSubscriptionWhereInput;
}

export interface ThoughtUpdateWithWhereUniqueNestedInput {
  where: ThoughtWhereUniqueInput;
  data: ThoughtUpdateDataInput;
}

export interface PathFeelingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PathFeelingWhereInput;
  AND?: PathFeelingSubscriptionWhereInput[] | PathFeelingSubscriptionWhereInput;
  OR?: PathFeelingSubscriptionWhereInput[] | PathFeelingSubscriptionWhereInput;
  NOT?: PathFeelingSubscriptionWhereInput[] | PathFeelingSubscriptionWhereInput;
}

export interface ThoughtUpdateDataInput {
  character?: ID_Input;
  thought?: String;
  quality?: Boolean;
  source?: ID_Input;
  process?: ID_Input;
  path?: ID_Input;
  feeling?: ID_Input;
  prayedAt?: DateTimeInput;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface InventorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InventoryWhereInput;
  AND?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
  OR?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
  NOT?: InventorySubscriptionWhereInput[] | InventorySubscriptionWhereInput;
}

export interface ThoughtUpsertWithWhereUniqueNestedInput {
  where: ThoughtWhereUniqueInput;
  update: ThoughtUpdateDataInput;
  create: ThoughtCreateInput;
}

export interface FeelingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FeelingWhereInput;
  AND?: FeelingSubscriptionWhereInput[] | FeelingSubscriptionWhereInput;
  OR?: FeelingSubscriptionWhereInput[] | FeelingSubscriptionWhereInput;
  NOT?: FeelingSubscriptionWhereInput[] | FeelingSubscriptionWhereInput;
}

export interface ThoughtScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: ID_Input;
  character_not?: ID_Input;
  character_in?: ID_Input[] | ID_Input;
  character_not_in?: ID_Input[] | ID_Input;
  character_lt?: ID_Input;
  character_lte?: ID_Input;
  character_gt?: ID_Input;
  character_gte?: ID_Input;
  character_contains?: ID_Input;
  character_not_contains?: ID_Input;
  character_starts_with?: ID_Input;
  character_not_starts_with?: ID_Input;
  character_ends_with?: ID_Input;
  character_not_ends_with?: ID_Input;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  quality?: Boolean;
  quality_not?: Boolean;
  source?: ID_Input;
  source_not?: ID_Input;
  source_in?: ID_Input[] | ID_Input;
  source_not_in?: ID_Input[] | ID_Input;
  source_lt?: ID_Input;
  source_lte?: ID_Input;
  source_gt?: ID_Input;
  source_gte?: ID_Input;
  source_contains?: ID_Input;
  source_not_contains?: ID_Input;
  source_starts_with?: ID_Input;
  source_not_starts_with?: ID_Input;
  source_ends_with?: ID_Input;
  source_not_ends_with?: ID_Input;
  process?: ID_Input;
  process_not?: ID_Input;
  process_in?: ID_Input[] | ID_Input;
  process_not_in?: ID_Input[] | ID_Input;
  process_lt?: ID_Input;
  process_lte?: ID_Input;
  process_gt?: ID_Input;
  process_gte?: ID_Input;
  process_contains?: ID_Input;
  process_not_contains?: ID_Input;
  process_starts_with?: ID_Input;
  process_not_starts_with?: ID_Input;
  process_ends_with?: ID_Input;
  process_not_ends_with?: ID_Input;
  path?: ID_Input;
  path_not?: ID_Input;
  path_in?: ID_Input[] | ID_Input;
  path_not_in?: ID_Input[] | ID_Input;
  path_lt?: ID_Input;
  path_lte?: ID_Input;
  path_gt?: ID_Input;
  path_gte?: ID_Input;
  path_contains?: ID_Input;
  path_not_contains?: ID_Input;
  path_starts_with?: ID_Input;
  path_not_starts_with?: ID_Input;
  path_ends_with?: ID_Input;
  path_not_ends_with?: ID_Input;
  feeling?: ID_Input;
  feeling_not?: ID_Input;
  feeling_in?: ID_Input[] | ID_Input;
  feeling_not_in?: ID_Input[] | ID_Input;
  feeling_lt?: ID_Input;
  feeling_lte?: ID_Input;
  feeling_gt?: ID_Input;
  feeling_gte?: ID_Input;
  feeling_contains?: ID_Input;
  feeling_not_contains?: ID_Input;
  feeling_starts_with?: ID_Input;
  feeling_not_starts_with?: ID_Input;
  feeling_ends_with?: ID_Input;
  feeling_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  prayedAt?: DateTimeInput;
  prayedAt_not?: DateTimeInput;
  prayedAt_in?: DateTimeInput[] | DateTimeInput;
  prayedAt_not_in?: DateTimeInput[] | DateTimeInput;
  prayedAt_lt?: DateTimeInput;
  prayedAt_lte?: DateTimeInput;
  prayedAt_gt?: DateTimeInput;
  prayedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  AND?: ThoughtScalarWhereInput[] | ThoughtScalarWhereInput;
  OR?: ThoughtScalarWhereInput[] | ThoughtScalarWhereInput;
  NOT?: ThoughtScalarWhereInput[] | ThoughtScalarWhereInput;
}

export type CharacterProcessWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ThoughtUpdateManyWithWhereNestedInput {
  where: ThoughtScalarWhereInput;
  data: ThoughtUpdateManyDataInput;
}

export interface SourceFeelingUpdateManyMutationInput {
  title?: String;
}

export interface ThoughtUpdateManyDataInput {
  character?: ID_Input;
  thought?: String;
  quality?: Boolean;
  source?: ID_Input;
  process?: ID_Input;
  path?: ID_Input;
  feeling?: ID_Input;
  prayedAt?: DateTimeInput;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface SourceUpdateManyMutationInput {
  title?: String;
  feelings?: SourceUpdatefeelingsInput;
}

export interface SourceFeelingUpsertWithWhereUniqueNestedInput {
  where: SourceFeelingWhereUniqueInput;
  update: SourceFeelingUpdateDataInput;
  create: SourceFeelingCreateInput;
}

export type HigherPowerWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SourceFeelingScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: SourceFeelingScalarWhereInput[] | SourceFeelingScalarWhereInput;
  OR?: SourceFeelingScalarWhereInput[] | SourceFeelingScalarWhereInput;
  NOT?: SourceFeelingScalarWhereInput[] | SourceFeelingScalarWhereInput;
}

export interface PathFeelingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  thoughts_every?: ThoughtWhereInput;
  thoughts_some?: ThoughtWhereInput;
  thoughts_none?: ThoughtWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PathFeelingWhereInput[] | PathFeelingWhereInput;
  OR?: PathFeelingWhereInput[] | PathFeelingWhereInput;
  NOT?: PathFeelingWhereInput[] | PathFeelingWhereInput;
}

export interface PathFeelingCreateInput {
  id?: ID_Input;
  title: String;
  thoughts?: ThoughtCreateManyInput;
}

export interface ProcessUpdatesourcesInput {
  set?: ID_Input[] | ID_Input;
}

export interface SourceFeelingUpdateManyDataInput {
  title?: String;
}

export interface ProcessUpdateInput {
  title?: String;
  sources?: ProcessUpdatesourcesInput;
}

export interface ProcessSourceUpsertWithWhereUniqueNestedInput {
  where: ProcessSourceWhereUniqueInput;
  update: ProcessSourceUpdateDataInput;
  create: ProcessSourceCreateInput;
}

export interface ProcessSourceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  feelings_every?: SourceFeelingWhereInput;
  feelings_some?: SourceFeelingWhereInput;
  feelings_none?: SourceFeelingWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProcessSourceWhereInput[] | ProcessSourceWhereInput;
  OR?: ProcessSourceWhereInput[] | ProcessSourceWhereInput;
  NOT?: ProcessSourceWhereInput[] | ProcessSourceWhereInput;
}

export interface ProcessSourceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: ProcessSourceScalarWhereInput[] | ProcessSourceScalarWhereInput;
  OR?: ProcessSourceScalarWhereInput[] | ProcessSourceScalarWhereInput;
  NOT?: ProcessSourceScalarWhereInput[] | ProcessSourceScalarWhereInput;
}

export type InventoryPathWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProcessSourceUpdateManyWithWhereNestedInput {
  where: ProcessSourceScalarWhereInput;
  data: ProcessSourceUpdateManyDataInput;
}

export type PathWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProcessSourceUpdateManyDataInput {
  title?: String;
}

export interface InventoryPathUpdateManyMutationInput {
  title?: String;
}

export interface CharacterProcessUpsertNestedInput {
  update: CharacterProcessUpdateDataInput;
  create: CharacterProcessCreateInput;
}

export interface CastUpsertNestedInput {
  update: CastUpdateDataInput;
  create: CastCreateInput;
}

export interface CastCharacterUpsertWithWhereUniqueNestedInput {
  where: CastCharacterWhereUniqueInput;
  update: CastCharacterUpdateDataInput;
  create: CastCharacterCreateInput;
}

export interface InventoryUpsertNestedInput {
  update: InventoryUpdateDataInput;
  create: InventoryCreateInput;
}

export interface CastCharacterScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CastCharacterScalarWhereInput[] | CastCharacterScalarWhereInput;
  OR?: CastCharacterScalarWhereInput[] | CastCharacterScalarWhereInput;
  NOT?: CastCharacterScalarWhereInput[] | CastCharacterScalarWhereInput;
}

export interface InventoryPathScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: InventoryPathScalarWhereInput[] | InventoryPathScalarWhereInput;
  OR?: InventoryPathScalarWhereInput[] | InventoryPathScalarWhereInput;
  NOT?: InventoryPathScalarWhereInput[] | InventoryPathScalarWhereInput;
}

export interface CastCharacterUpdateManyWithWhereNestedInput {
  where: CastCharacterScalarWhereInput;
  data: CastCharacterUpdateManyDataInput;
}

export interface PathFeelingUpdateManyWithWhereNestedInput {
  where: PathFeelingScalarWhereInput;
  data: PathFeelingUpdateManyDataInput;
}

export interface CastCharacterUpdateManyDataInput {
  title?: String;
  description?: String;
}

export interface ProcessSourceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProcessSourceWhereInput;
  AND?:
    | ProcessSourceSubscriptionWhereInput[]
    | ProcessSourceSubscriptionWhereInput;
  OR?:
    | ProcessSourceSubscriptionWhereInput[]
    | ProcessSourceSubscriptionWhereInput;
  NOT?:
    | ProcessSourceSubscriptionWhereInput[]
    | ProcessSourceSubscriptionWhereInput;
}

export interface PathFeelingCreateManyInput {
  create?: PathFeelingCreateInput[] | PathFeelingCreateInput;
  connect?: PathFeelingWhereUniqueInput[] | PathFeelingWhereUniqueInput;
}

export interface HigherPowerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HigherPowerWhereInput;
  AND?: HigherPowerSubscriptionWhereInput[] | HigherPowerSubscriptionWhereInput;
  OR?: HigherPowerSubscriptionWhereInput[] | HigherPowerSubscriptionWhereInput;
  NOT?: HigherPowerSubscriptionWhereInput[] | HigherPowerSubscriptionWhereInput;
}

export interface InventoryPathCreateInput {
  id?: ID_Input;
  title: String;
  feelings?: PathFeelingCreateManyInput;
}

export interface ThoughtUpdateManyMutationInput {
  character?: ID_Input;
  thought?: String;
  quality?: Boolean;
  source?: ID_Input;
  process?: ID_Input;
  path?: ID_Input;
  feeling?: ID_Input;
  prayedAt?: DateTimeInput;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
}

export interface CastCharacterUpdateInput {
  title?: String;
  description?: String;
  process?: CharacterProcessUpdateOneRequiredInput;
}

export interface SourceUpdateInput {
  title?: String;
  feelings?: SourceUpdatefeelingsInput;
}

export interface CastCharacterUpdateManyMutationInput {
  title?: String;
  description?: String;
}

export interface ProcessUpdateManyMutationInput {
  title?: String;
  sources?: ProcessUpdatesourcesInput;
}

export interface CharacterCreateInput {
  id?: ID_Input;
  title: String;
  description?: String;
  process: ID_Input;
}

export interface ProcessCreateInput {
  id?: ID_Input;
  title: String;
  sources?: ProcessCreatesourcesInput;
}

export interface CharacterUpdateInput {
  title?: String;
  description?: String;
  process?: ID_Input;
}

export interface PathUpdateInput {
  title?: String;
  feelings?: PathUpdatefeelingsInput;
}

export interface CharacterUpdateManyMutationInput {
  title?: String;
  description?: String;
  process?: ID_Input;
}

export interface InventoryUpdateInput {
  paths?: InventoryPathUpdateManyInput;
}

export interface CharacterProcessUpdateInput {
  title?: String;
  sources?: ProcessSourceUpdateManyInput;
}

export interface InventoryPathUpdateManyDataInput {
  title?: String;
}

export interface CharacterProcessUpdateManyMutationInput {
  title?: String;
}

export interface ThoughtSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ThoughtWhereInput;
  AND?: ThoughtSubscriptionWhereInput[] | ThoughtSubscriptionWhereInput;
  OR?: ThoughtSubscriptionWhereInput[] | ThoughtSubscriptionWhereInput;
  NOT?: ThoughtSubscriptionWhereInput[] | ThoughtSubscriptionWhereInput;
}

export interface FeelingCreateInput {
  id?: ID_Input;
  title: String;
  thoughts?: FeelingCreatethoughtsInput;
}

export interface CharacterSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CharacterWhereInput;
  AND?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  OR?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  NOT?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
}

export interface FeelingCreatethoughtsInput {
  set?: ID_Input[] | ID_Input;
}

export interface ProcessSourceUpdateManyMutationInput {
  title?: String;
}

export interface FeelingUpdateInput {
  title?: String;
  thoughts?: FeelingUpdatethoughtsInput;
}

export interface PathFeelingUpdateInput {
  title?: String;
  thoughts?: ThoughtUpdateManyInput;
}

export interface FeelingUpdatethoughtsInput {
  set?: ID_Input[] | ID_Input;
}

export interface CastUpdateOneInput {
  create?: CastCreateInput;
  update?: CastUpdateDataInput;
  upsert?: CastUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CastWhereUniqueInput;
}

export interface InventoryCreateInput {
  id?: ID_Input;
  paths?: InventoryPathCreateManyInput;
}

export interface InventoryCreateOneInput {
  create?: InventoryCreateInput;
  connect?: InventoryWhereUniqueInput;
}

export interface HigherPowerCreateInput {
  id?: ID_Input;
  inventory?: InventoryCreateOneInput;
  cast?: CastCreateOneInput;
}

export interface FeelingUpdateManyMutationInput {
  title?: String;
  thoughts?: FeelingUpdatethoughtsInput;
}

export type ProcessSourceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PathWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PathWhereInput[] | PathWhereInput;
  OR?: PathWhereInput[] | PathWhereInput;
  NOT?: PathWhereInput[] | PathWhereInput;
}

export interface InventoryWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  paths_every?: InventoryPathWhereInput;
  paths_some?: InventoryPathWhereInput;
  paths_none?: InventoryPathWhereInput;
  AND?: InventoryWhereInput[] | InventoryWhereInput;
  OR?: InventoryWhereInput[] | InventoryWhereInput;
  NOT?: InventoryWhereInput[] | InventoryWhereInput;
}

export interface SourceFeelingUpdateInput {
  title?: String;
  thoughts?: ThoughtUpdateManyInput;
}

export interface PathSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PathWhereInput;
  AND?: PathSubscriptionWhereInput[] | PathSubscriptionWhereInput;
  OR?: PathSubscriptionWhereInput[] | PathSubscriptionWhereInput;
  NOT?: PathSubscriptionWhereInput[] | PathSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface ThoughtPreviousValues {
  id: ID_Output;
  character?: ID_Output;
  thought: String;
  quality?: Boolean;
  source?: ID_Output;
  process?: ID_Output;
  path?: ID_Output;
  feeling: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  prayedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ThoughtPreviousValuesPromise
  extends Promise<ThoughtPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<ID_Output>;
  thought: () => Promise<String>;
  quality: () => Promise<Boolean>;
  source: () => Promise<ID_Output>;
  process: () => Promise<ID_Output>;
  path: () => Promise<ID_Output>;
  feeling: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  prayedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ThoughtPreviousValuesSubscription
  extends Promise<AsyncIterator<ThoughtPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<ID_Output>>;
  thought: () => Promise<AsyncIterator<String>>;
  quality: () => Promise<AsyncIterator<Boolean>>;
  source: () => Promise<AsyncIterator<ID_Output>>;
  process: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<ID_Output>>;
  feeling: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  prayedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCharacterProcess {
  count: Int;
}

export interface AggregateCharacterProcessPromise
  extends Promise<AggregateCharacterProcess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharacterProcessSubscription
  extends Promise<AsyncIterator<AggregateCharacterProcess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SourceFeeling {
  id: ID_Output;
  title: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface SourceFeelingPromise
  extends Promise<SourceFeeling>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  thoughts: <T = FragmentableArray<Thought>>(
    args?: {
      where?: ThoughtWhereInput;
      orderBy?: ThoughtOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SourceFeelingSubscription
  extends Promise<AsyncIterator<SourceFeeling>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  thoughts: <T = Promise<AsyncIterator<ThoughtSubscription>>>(
    args?: {
      where?: ThoughtWhereInput;
      orderBy?: ThoughtOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CharacterProcessEdge {
  node: CharacterProcess;
  cursor: String;
}

export interface CharacterProcessEdgePromise
  extends Promise<CharacterProcessEdge>,
    Fragmentable {
  node: <T = CharacterProcessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharacterProcessEdgeSubscription
  extends Promise<AsyncIterator<CharacterProcessEdge>>,
    Fragmentable {
  node: <T = CharacterProcessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProcessSource {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProcessSourcePromise
  extends Promise<ProcessSource>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  feelings: <T = FragmentableArray<SourceFeeling>>(
    args?: {
      where?: SourceFeelingWhereInput;
      orderBy?: SourceFeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProcessSourceSubscription
  extends Promise<AsyncIterator<ProcessSource>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: <T = Promise<AsyncIterator<SourceFeelingSubscription>>>(
    args?: {
      where?: SourceFeelingWhereInput;
      orderBy?: SourceFeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CharacterProcessConnection {
  pageInfo: PageInfo;
  edges: CharacterProcessEdge[];
}

export interface CharacterProcessConnectionPromise
  extends Promise<CharacterProcessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharacterProcessEdge>>() => T;
  aggregate: <T = AggregateCharacterProcessPromise>() => T;
}

export interface CharacterProcessConnectionSubscription
  extends Promise<AsyncIterator<CharacterProcessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharacterProcessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharacterProcessSubscription>() => T;
}

export interface AggregateThought {
  count: Int;
}

export interface AggregateThoughtPromise
  extends Promise<AggregateThought>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateThoughtSubscription
  extends Promise<AsyncIterator<AggregateThought>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SourceFeelingSubscriptionPayload {
  mutation: MutationType;
  node: SourceFeeling;
  updatedFields: String[];
  previousValues: SourceFeelingPreviousValues;
}

export interface SourceFeelingSubscriptionPayloadPromise
  extends Promise<SourceFeelingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SourceFeelingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SourceFeelingPreviousValuesPromise>() => T;
}

export interface SourceFeelingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SourceFeelingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SourceFeelingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SourceFeelingPreviousValuesSubscription>() => T;
}

export interface CharacterProcess {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CharacterProcessPromise
  extends Promise<CharacterProcess>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  sources: <T = FragmentableArray<ProcessSource>>(
    args?: {
      where?: ProcessSourceWhereInput;
      orderBy?: ProcessSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CharacterProcessSubscription
  extends Promise<AsyncIterator<CharacterProcess>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  sources: <T = Promise<AsyncIterator<ProcessSourceSubscription>>>(
    args?: {
      where?: ProcessSourceWhereInput;
      orderBy?: ProcessSourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ThoughtEdge {
  node: Thought;
  cursor: String;
}

export interface ThoughtEdgePromise extends Promise<ThoughtEdge>, Fragmentable {
  node: <T = ThoughtPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ThoughtEdgeSubscription
  extends Promise<AsyncIterator<ThoughtEdge>>,
    Fragmentable {
  node: <T = ThoughtSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ThoughtConnection {
  pageInfo: PageInfo;
  edges: ThoughtEdge[];
}

export interface ThoughtConnectionPromise
  extends Promise<ThoughtConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ThoughtEdge>>() => T;
  aggregate: <T = AggregateThoughtPromise>() => T;
}

export interface ThoughtConnectionSubscription
  extends Promise<AsyncIterator<ThoughtConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ThoughtEdgeSubscription>>>() => T;
  aggregate: <T = AggregateThoughtSubscription>() => T;
}

export interface AggregateSourceFeeling {
  count: Int;
}

export interface AggregateSourceFeelingPromise
  extends Promise<AggregateSourceFeeling>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSourceFeelingSubscription
  extends Promise<AsyncIterator<AggregateSourceFeeling>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SourceFeelingConnection {
  pageInfo: PageInfo;
  edges: SourceFeelingEdge[];
}

export interface SourceFeelingConnectionPromise
  extends Promise<SourceFeelingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SourceFeelingEdge>>() => T;
  aggregate: <T = AggregateSourceFeelingPromise>() => T;
}

export interface SourceFeelingConnectionSubscription
  extends Promise<AsyncIterator<SourceFeelingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SourceFeelingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSourceFeelingSubscription>() => T;
}

export interface Cast {
  id: ID_Output;
}

export interface CastPromise extends Promise<Cast>, Fragmentable {
  id: () => Promise<ID_Output>;
  characters: <T = FragmentableArray<CastCharacter>>(
    args?: {
      where?: CastCharacterWhereInput;
      orderBy?: CastCharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CastSubscription
  extends Promise<AsyncIterator<Cast>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  characters: <T = Promise<AsyncIterator<CastCharacterSubscription>>>(
    args?: {
      where?: CastCharacterWhereInput;
      orderBy?: CastCharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface SourceEdge {
  node: Source;
  cursor: String;
}

export interface SourceEdgePromise extends Promise<SourceEdge>, Fragmentable {
  node: <T = SourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SourceEdgeSubscription
  extends Promise<AsyncIterator<SourceEdge>>,
    Fragmentable {
  node: <T = SourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CastSubscriptionPayload {
  mutation: MutationType;
  node: Cast;
  updatedFields: String[];
  previousValues: CastPreviousValues;
}

export interface CastSubscriptionPayloadPromise
  extends Promise<CastSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CastPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CastPreviousValuesPromise>() => T;
}

export interface CastSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CastSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CastSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CastPreviousValuesSubscription>() => T;
}

export interface Source {
  id: ID_Output;
  title: String;
  feelings: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SourcePromise extends Promise<Source>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  feelings: () => Promise<ID_Output[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SourceSubscription
  extends Promise<AsyncIterator<Source>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: () => Promise<AsyncIterator<ID_Output[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CastPreviousValues {
  id: ID_Output;
}

export interface CastPreviousValuesPromise
  extends Promise<CastPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CastPreviousValuesSubscription
  extends Promise<AsyncIterator<CastPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ProcessSourceEdge {
  node: ProcessSource;
  cursor: String;
}

export interface ProcessSourceEdgePromise
  extends Promise<ProcessSourceEdge>,
    Fragmentable {
  node: <T = ProcessSourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProcessSourceEdgeSubscription
  extends Promise<AsyncIterator<ProcessSourceEdge>>,
    Fragmentable {
  node: <T = ProcessSourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCharacter {
  count: Int;
}

export interface AggregateCharacterPromise
  extends Promise<AggregateCharacter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharacterSubscription
  extends Promise<AsyncIterator<AggregateCharacter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateProcess {
  count: Int;
}

export interface AggregateProcessPromise
  extends Promise<AggregateProcess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProcessSubscription
  extends Promise<AsyncIterator<AggregateProcess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CastCharacterSubscriptionPayload {
  mutation: MutationType;
  node: CastCharacter;
  updatedFields: String[];
  previousValues: CastCharacterPreviousValues;
}

export interface CastCharacterSubscriptionPayloadPromise
  extends Promise<CastCharacterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CastCharacterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CastCharacterPreviousValuesPromise>() => T;
}

export interface CastCharacterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CastCharacterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CastCharacterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CastCharacterPreviousValuesSubscription>() => T;
}

export interface ProcessConnection {
  pageInfo: PageInfo;
  edges: ProcessEdge[];
}

export interface ProcessConnectionPromise
  extends Promise<ProcessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProcessEdge>>() => T;
  aggregate: <T = AggregateProcessPromise>() => T;
}

export interface ProcessConnectionSubscription
  extends Promise<AsyncIterator<ProcessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProcessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProcessSubscription>() => T;
}

export interface CastCharacterPreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CastCharacterPreviousValuesPromise
  extends Promise<CastCharacterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CastCharacterPreviousValuesSubscription
  extends Promise<AsyncIterator<CastCharacterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Process {
  id: ID_Output;
  title: String;
  sources: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProcessPromise extends Promise<Process>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  sources: () => Promise<ID_Output[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProcessSubscription
  extends Promise<AsyncIterator<Process>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  sources: () => Promise<AsyncIterator<ID_Output[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CharacterEdge {
  node: Character;
  cursor: String;
}

export interface CharacterEdgePromise
  extends Promise<CharacterEdge>,
    Fragmentable {
  node: <T = CharacterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharacterEdgeSubscription
  extends Promise<AsyncIterator<CharacterEdge>>,
    Fragmentable {
  node: <T = CharacterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PathFeelingEdge {
  node: PathFeeling;
  cursor: String;
}

export interface PathFeelingEdgePromise
  extends Promise<PathFeelingEdge>,
    Fragmentable {
  node: <T = PathFeelingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PathFeelingEdgeSubscription
  extends Promise<AsyncIterator<PathFeelingEdge>>,
    Fragmentable {
  node: <T = PathFeelingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharacterSubscriptionPayload {
  mutation: MutationType;
  node: Character;
  updatedFields: String[];
  previousValues: CharacterPreviousValues;
}

export interface CharacterSubscriptionPayloadPromise
  extends Promise<CharacterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharacterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharacterPreviousValuesPromise>() => T;
}

export interface CharacterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharacterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharacterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharacterPreviousValuesSubscription>() => T;
}

export interface AggregatePath {
  count: Int;
}

export interface AggregatePathPromise
  extends Promise<AggregatePath>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePathSubscription
  extends Promise<AsyncIterator<AggregatePath>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CharacterPreviousValues {
  id: ID_Output;
  title: String;
  description?: String;
  process: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CharacterPreviousValuesPromise
  extends Promise<CharacterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  process: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CharacterPreviousValuesSubscription
  extends Promise<AsyncIterator<CharacterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PathConnection {
  pageInfo: PageInfo;
  edges: PathEdge[];
}

export interface PathConnectionPromise
  extends Promise<PathConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PathEdge>>() => T;
  aggregate: <T = AggregatePathPromise>() => T;
}

export interface PathConnectionSubscription
  extends Promise<AsyncIterator<PathConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PathEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePathSubscription>() => T;
}

export interface CharacterConnection {
  pageInfo: PageInfo;
  edges: CharacterEdge[];
}

export interface CharacterConnectionPromise
  extends Promise<CharacterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharacterEdge>>() => T;
  aggregate: <T = AggregateCharacterPromise>() => T;
}

export interface CharacterConnectionSubscription
  extends Promise<AsyncIterator<CharacterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharacterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharacterSubscription>() => T;
}

export interface AggregateInventoryPath {
  count: Int;
}

export interface AggregateInventoryPathPromise
  extends Promise<AggregateInventoryPath>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventoryPathSubscription
  extends Promise<AsyncIterator<AggregateInventoryPath>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CharacterProcessSubscriptionPayload {
  mutation: MutationType;
  node: CharacterProcess;
  updatedFields: String[];
  previousValues: CharacterProcessPreviousValues;
}

export interface CharacterProcessSubscriptionPayloadPromise
  extends Promise<CharacterProcessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharacterProcessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharacterProcessPreviousValuesPromise>() => T;
}

export interface CharacterProcessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharacterProcessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharacterProcessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharacterProcessPreviousValuesSubscription>() => T;
}

export interface InventoryPathConnection {
  pageInfo: PageInfo;
  edges: InventoryPathEdge[];
}

export interface InventoryPathConnectionPromise
  extends Promise<InventoryPathConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryPathEdge>>() => T;
  aggregate: <T = AggregateInventoryPathPromise>() => T;
}

export interface InventoryPathConnectionSubscription
  extends Promise<AsyncIterator<InventoryPathConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryPathEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventoryPathSubscription>() => T;
}

export interface CharacterProcessPreviousValues {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CharacterProcessPreviousValuesPromise
  extends Promise<CharacterProcessPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CharacterProcessPreviousValuesSubscription
  extends Promise<AsyncIterator<CharacterProcessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryEdge {
  node: Inventory;
  cursor: String;
}

export interface InventoryEdgePromise
  extends Promise<InventoryEdge>,
    Fragmentable {
  node: <T = InventoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryEdgeSubscription
  extends Promise<AsyncIterator<InventoryEdge>>,
    Fragmentable {
  node: <T = InventorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CastCharacter {
  id: ID_Output;
  title: String;
  description?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CastCharacterPromise
  extends Promise<CastCharacter>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  process: <T = CharacterProcessPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CastCharacterSubscription
  extends Promise<AsyncIterator<CastCharacter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  process: <T = CharacterProcessSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateHigherPower {
  count: Int;
}

export interface AggregateHigherPowerPromise
  extends Promise<AggregateHigherPower>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHigherPowerSubscription
  extends Promise<AsyncIterator<AggregateHigherPower>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FeelingSubscriptionPayload {
  mutation: MutationType;
  node: Feeling;
  updatedFields: String[];
  previousValues: FeelingPreviousValues;
}

export interface FeelingSubscriptionPayloadPromise
  extends Promise<FeelingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FeelingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FeelingPreviousValuesPromise>() => T;
}

export interface FeelingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FeelingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FeelingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FeelingPreviousValuesSubscription>() => T;
}

export interface HigherPowerConnection {
  pageInfo: PageInfo;
  edges: HigherPowerEdge[];
}

export interface HigherPowerConnectionPromise
  extends Promise<HigherPowerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HigherPowerEdge>>() => T;
  aggregate: <T = AggregateHigherPowerPromise>() => T;
}

export interface HigherPowerConnectionSubscription
  extends Promise<AsyncIterator<HigherPowerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HigherPowerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHigherPowerSubscription>() => T;
}

export interface FeelingPreviousValues {
  id: ID_Output;
  title: String;
  thoughts: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FeelingPreviousValuesPromise
  extends Promise<FeelingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  thoughts: () => Promise<ID_Output[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FeelingPreviousValuesSubscription
  extends Promise<AsyncIterator<FeelingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  thoughts: () => Promise<AsyncIterator<ID_Output[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryPath {
  id: ID_Output;
  title: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface InventoryPathPromise
  extends Promise<InventoryPath>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  feelings: <T = FragmentableArray<PathFeeling>>(
    args?: {
      where?: PathFeelingWhereInput;
      orderBy?: PathFeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryPathSubscription
  extends Promise<AsyncIterator<InventoryPath>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: <T = Promise<AsyncIterator<PathFeelingSubscription>>>(
    args?: {
      where?: PathFeelingWhereInput;
      orderBy?: PathFeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Character {
  id: ID_Output;
  title: String;
  description?: String;
  process: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CharacterPromise extends Promise<Character>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  process: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CharacterSubscription
  extends Promise<AsyncIterator<Character>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Inventory {
  id: ID_Output;
}

export interface InventoryPromise extends Promise<Inventory>, Fragmentable {
  id: () => Promise<ID_Output>;
  paths: <T = FragmentableArray<InventoryPath>>(
    args?: {
      where?: InventoryPathWhereInput;
      orderBy?: InventoryPathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface InventorySubscription
  extends Promise<AsyncIterator<Inventory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  paths: <T = Promise<AsyncIterator<InventoryPathSubscription>>>(
    args?: {
      where?: InventoryPathWhereInput;
      orderBy?: InventoryPathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface HigherPowerSubscriptionPayload {
  mutation: MutationType;
  node: HigherPower;
  updatedFields: String[];
  previousValues: HigherPowerPreviousValues;
}

export interface HigherPowerSubscriptionPayloadPromise
  extends Promise<HigherPowerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HigherPowerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HigherPowerPreviousValuesPromise>() => T;
}

export interface HigherPowerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HigherPowerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HigherPowerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HigherPowerPreviousValuesSubscription>() => T;
}

export interface AggregateFeeling {
  count: Int;
}

export interface AggregateFeelingPromise
  extends Promise<AggregateFeeling>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFeelingSubscription
  extends Promise<AsyncIterator<AggregateFeeling>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HigherPowerPreviousValues {
  id: ID_Output;
}

export interface HigherPowerPreviousValuesPromise
  extends Promise<HigherPowerPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface HigherPowerPreviousValuesSubscription
  extends Promise<AsyncIterator<HigherPowerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface FeelingConnection {
  pageInfo: PageInfo;
  edges: FeelingEdge[];
}

export interface FeelingConnectionPromise
  extends Promise<FeelingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FeelingEdge>>() => T;
  aggregate: <T = AggregateFeelingPromise>() => T;
}

export interface FeelingConnectionSubscription
  extends Promise<AsyncIterator<FeelingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FeelingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFeelingSubscription>() => T;
}

export interface AggregateCastCharacter {
  count: Int;
}

export interface AggregateCastCharacterPromise
  extends Promise<AggregateCastCharacter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCastCharacterSubscription
  extends Promise<AsyncIterator<AggregateCastCharacter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Feeling {
  id: ID_Output;
  title: String;
  thoughts: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface FeelingPromise extends Promise<Feeling>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  thoughts: () => Promise<ID_Output[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface FeelingSubscription
  extends Promise<AsyncIterator<Feeling>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  thoughts: () => Promise<AsyncIterator<ID_Output[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventorySubscriptionPayload {
  mutation: MutationType;
  node: Inventory;
  updatedFields: String[];
  previousValues: InventoryPreviousValues;
}

export interface InventorySubscriptionPayloadPromise
  extends Promise<InventorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryPreviousValuesPromise>() => T;
}

export interface InventorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryPreviousValuesSubscription>() => T;
}

export interface SourceFeelingEdge {
  node: SourceFeeling;
  cursor: String;
}

export interface SourceFeelingEdgePromise
  extends Promise<SourceFeelingEdge>,
    Fragmentable {
  node: <T = SourceFeelingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SourceFeelingEdgeSubscription
  extends Promise<AsyncIterator<SourceFeelingEdge>>,
    Fragmentable {
  node: <T = SourceFeelingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface InventoryPreviousValues {
  id: ID_Output;
}

export interface InventoryPreviousValuesPromise
  extends Promise<InventoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface InventoryPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SourceConnection {
  pageInfo: PageInfo;
  edges: SourceEdge[];
}

export interface SourceConnectionPromise
  extends Promise<SourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SourceEdge>>() => T;
  aggregate: <T = AggregateSourcePromise>() => T;
}

export interface SourceConnectionSubscription
  extends Promise<AsyncIterator<SourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSourceSubscription>() => T;
}

export interface CastCharacterEdge {
  node: CastCharacter;
  cursor: String;
}

export interface CastCharacterEdgePromise
  extends Promise<CastCharacterEdge>,
    Fragmentable {
  node: <T = CastCharacterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CastCharacterEdgeSubscription
  extends Promise<AsyncIterator<CastCharacterEdge>>,
    Fragmentable {
  node: <T = CastCharacterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProcessSourceConnection {
  pageInfo: PageInfo;
  edges: ProcessSourceEdge[];
}

export interface ProcessSourceConnectionPromise
  extends Promise<ProcessSourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProcessSourceEdge>>() => T;
  aggregate: <T = AggregateProcessSourcePromise>() => T;
}

export interface ProcessSourceConnectionSubscription
  extends Promise<AsyncIterator<ProcessSourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProcessSourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProcessSourceSubscription>() => T;
}

export interface InventoryPathSubscriptionPayload {
  mutation: MutationType;
  node: InventoryPath;
  updatedFields: String[];
  previousValues: InventoryPathPreviousValues;
}

export interface InventoryPathSubscriptionPayloadPromise
  extends Promise<InventoryPathSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InventoryPathPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InventoryPathPreviousValuesPromise>() => T;
}

export interface InventoryPathSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InventoryPathSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InventoryPathSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InventoryPathPreviousValuesSubscription>() => T;
}

export interface ThoughtSubscriptionPayload {
  mutation: MutationType;
  node: Thought;
  updatedFields: String[];
  previousValues: ThoughtPreviousValues;
}

export interface ThoughtSubscriptionPayloadPromise
  extends Promise<ThoughtSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ThoughtPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ThoughtPreviousValuesPromise>() => T;
}

export interface ThoughtSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ThoughtSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ThoughtSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ThoughtPreviousValuesSubscription>() => T;
}

export interface InventoryPathPreviousValues {
  id: ID_Output;
  title: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface InventoryPathPreviousValuesPromise
  extends Promise<InventoryPathPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface InventoryPathPreviousValuesSubscription
  extends Promise<AsyncIterator<InventoryPathPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PathFeelingConnection {
  pageInfo: PageInfo;
  edges: PathFeelingEdge[];
}

export interface PathFeelingConnectionPromise
  extends Promise<PathFeelingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PathFeelingEdge>>() => T;
  aggregate: <T = AggregatePathFeelingPromise>() => T;
}

export interface PathFeelingConnectionSubscription
  extends Promise<AsyncIterator<PathFeelingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PathFeelingEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePathFeelingSubscription>() => T;
}

export interface CastCharacterConnection {
  pageInfo: PageInfo;
  edges: CastCharacterEdge[];
}

export interface CastCharacterConnectionPromise
  extends Promise<CastCharacterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CastCharacterEdge>>() => T;
  aggregate: <T = AggregateCastCharacterPromise>() => T;
}

export interface CastCharacterConnectionSubscription
  extends Promise<AsyncIterator<CastCharacterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CastCharacterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCastCharacterSubscription>() => T;
}

export interface Path {
  id: ID_Output;
  title: String;
  feelings: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PathPromise extends Promise<Path>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  feelings: () => Promise<ID_Output[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PathSubscription
  extends Promise<AsyncIterator<Path>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: () => Promise<AsyncIterator<ID_Output[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PathSubscriptionPayload {
  mutation: MutationType;
  node: Path;
  updatedFields: String[];
  previousValues: PathPreviousValues;
}

export interface PathSubscriptionPayloadPromise
  extends Promise<PathSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PathPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PathPreviousValuesPromise>() => T;
}

export interface PathSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PathSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PathSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PathPreviousValuesSubscription>() => T;
}

export interface AggregateInventory {
  count: Int;
}

export interface AggregateInventoryPromise
  extends Promise<AggregateInventory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInventorySubscription
  extends Promise<AsyncIterator<AggregateInventory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PathPreviousValues {
  id: ID_Output;
  title: String;
  feelings: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PathPreviousValuesPromise
  extends Promise<PathPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  feelings: () => Promise<ID_Output[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PathPreviousValuesSubscription
  extends Promise<AsyncIterator<PathPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: () => Promise<AsyncIterator<ID_Output[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HigherPowerEdge {
  node: HigherPower;
  cursor: String;
}

export interface HigherPowerEdgePromise
  extends Promise<HigherPowerEdge>,
    Fragmentable {
  node: <T = HigherPowerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HigherPowerEdgeSubscription
  extends Promise<AsyncIterator<HigherPowerEdge>>,
    Fragmentable {
  node: <T = HigherPowerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCast {
  count: Int;
}

export interface AggregateCastPromise
  extends Promise<AggregateCast>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCastSubscription
  extends Promise<AsyncIterator<AggregateCast>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Thought {
  id: ID_Output;
  character?: ID_Output;
  thought: String;
  quality?: Boolean;
  source?: ID_Output;
  process?: ID_Output;
  path?: ID_Output;
  feeling: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  prayedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
}

export interface ThoughtPromise extends Promise<Thought>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<ID_Output>;
  thought: () => Promise<String>;
  quality: () => Promise<Boolean>;
  source: () => Promise<ID_Output>;
  process: () => Promise<ID_Output>;
  path: () => Promise<ID_Output>;
  feeling: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  prayedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
}

export interface ThoughtSubscription
  extends Promise<AsyncIterator<Thought>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<ID_Output>>;
  thought: () => Promise<AsyncIterator<String>>;
  quality: () => Promise<AsyncIterator<Boolean>>;
  source: () => Promise<AsyncIterator<ID_Output>>;
  process: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<ID_Output>>;
  feeling: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  prayedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PathFeelingSubscriptionPayload {
  mutation: MutationType;
  node: PathFeeling;
  updatedFields: String[];
  previousValues: PathFeelingPreviousValues;
}

export interface PathFeelingSubscriptionPayloadPromise
  extends Promise<PathFeelingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PathFeelingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PathFeelingPreviousValuesPromise>() => T;
}

export interface PathFeelingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PathFeelingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PathFeelingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PathFeelingPreviousValuesSubscription>() => T;
}

export interface FeelingEdge {
  node: Feeling;
  cursor: String;
}

export interface FeelingEdgePromise extends Promise<FeelingEdge>, Fragmentable {
  node: <T = FeelingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FeelingEdgeSubscription
  extends Promise<AsyncIterator<FeelingEdge>>,
    Fragmentable {
  node: <T = FeelingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PathFeelingPreviousValues {
  id: ID_Output;
  title: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface PathFeelingPreviousValuesPromise
  extends Promise<PathFeelingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PathFeelingPreviousValuesSubscription
  extends Promise<AsyncIterator<PathFeelingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface CastEdge {
  node: Cast;
  cursor: String;
}

export interface CastEdgePromise extends Promise<CastEdge>, Fragmentable {
  node: <T = CastPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CastEdgeSubscription
  extends Promise<AsyncIterator<CastEdge>>,
    Fragmentable {
  node: <T = CastSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProcessSource {
  count: Int;
}

export interface AggregateProcessSourcePromise
  extends Promise<AggregateProcessSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProcessSourceSubscription
  extends Promise<AsyncIterator<AggregateProcessSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProcessSubscriptionPayload {
  mutation: MutationType;
  node: Process;
  updatedFields: String[];
  previousValues: ProcessPreviousValues;
}

export interface ProcessSubscriptionPayloadPromise
  extends Promise<ProcessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProcessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProcessPreviousValuesPromise>() => T;
}

export interface ProcessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProcessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProcessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProcessPreviousValuesSubscription>() => T;
}

export interface AggregatePathFeeling {
  count: Int;
}

export interface AggregatePathFeelingPromise
  extends Promise<AggregatePathFeeling>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePathFeelingSubscription
  extends Promise<AsyncIterator<AggregatePathFeeling>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProcessPreviousValues {
  id: ID_Output;
  title: String;
  sources: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProcessPreviousValuesPromise
  extends Promise<ProcessPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  sources: () => Promise<ID_Output[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProcessPreviousValuesSubscription
  extends Promise<AsyncIterator<ProcessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  sources: () => Promise<AsyncIterator<ID_Output[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InventoryPathEdge {
  node: InventoryPath;
  cursor: String;
}

export interface InventoryPathEdgePromise
  extends Promise<InventoryPathEdge>,
    Fragmentable {
  node: <T = InventoryPathPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InventoryPathEdgeSubscription
  extends Promise<AsyncIterator<InventoryPathEdge>>,
    Fragmentable {
  node: <T = InventoryPathSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PathFeeling {
  id: ID_Output;
  title: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface PathFeelingPromise extends Promise<PathFeeling>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  thoughts: <T = FragmentableArray<Thought>>(
    args?: {
      where?: ThoughtWhereInput;
      orderBy?: ThoughtOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PathFeelingSubscription
  extends Promise<AsyncIterator<PathFeeling>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  thoughts: <T = Promise<AsyncIterator<ThoughtSubscription>>>(
    args?: {
      where?: ThoughtWhereInput;
      orderBy?: ThoughtOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProcessSourceSubscriptionPayload {
  mutation: MutationType;
  node: ProcessSource;
  updatedFields: String[];
  previousValues: ProcessSourcePreviousValues;
}

export interface ProcessSourceSubscriptionPayloadPromise
  extends Promise<ProcessSourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProcessSourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProcessSourcePreviousValuesPromise>() => T;
}

export interface ProcessSourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProcessSourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProcessSourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProcessSourcePreviousValuesSubscription>() => T;
}

export interface SourceFeelingPreviousValues {
  id: ID_Output;
  title: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface SourceFeelingPreviousValuesPromise
  extends Promise<SourceFeelingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SourceFeelingPreviousValuesSubscription
  extends Promise<AsyncIterator<SourceFeelingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProcessEdge {
  node: Process;
  cursor: String;
}

export interface ProcessEdgePromise extends Promise<ProcessEdge>, Fragmentable {
  node: <T = ProcessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProcessEdgeSubscription
  extends Promise<AsyncIterator<ProcessEdge>>,
    Fragmentable {
  node: <T = ProcessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SourcePreviousValues {
  id: ID_Output;
  title: String;
  feelings: ID_Output[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface SourcePreviousValuesPromise
  extends Promise<SourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  feelings: () => Promise<ID_Output[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface SourcePreviousValuesSubscription
  extends Promise<AsyncIterator<SourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: () => Promise<AsyncIterator<ID_Output[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SourceSubscriptionPayload {
  mutation: MutationType;
  node: Source;
  updatedFields: String[];
  previousValues: SourcePreviousValues;
}

export interface SourceSubscriptionPayloadPromise
  extends Promise<SourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SourcePreviousValuesPromise>() => T;
}

export interface SourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SourcePreviousValuesSubscription>() => T;
}

export interface CastConnection {
  pageInfo: PageInfo;
  edges: CastEdge[];
}

export interface CastConnectionPromise
  extends Promise<CastConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CastEdge>>() => T;
  aggregate: <T = AggregateCastPromise>() => T;
}

export interface CastConnectionSubscription
  extends Promise<AsyncIterator<CastConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CastEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCastSubscription>() => T;
}

export interface ProcessSourcePreviousValues {
  id: ID_Output;
  title: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface ProcessSourcePreviousValuesPromise
  extends Promise<ProcessSourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProcessSourcePreviousValuesSubscription
  extends Promise<AsyncIterator<ProcessSourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PathEdge {
  node: Path;
  cursor: String;
}

export interface PathEdgePromise extends Promise<PathEdge>, Fragmentable {
  node: <T = PathPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PathEdgeSubscription
  extends Promise<AsyncIterator<PathEdge>>,
    Fragmentable {
  node: <T = PathSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSource {
  count: Int;
}

export interface AggregateSourcePromise
  extends Promise<AggregateSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSourceSubscription
  extends Promise<AsyncIterator<AggregateSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HigherPower {
  id: ID_Output;
}

export interface HigherPowerPromise extends Promise<HigherPower>, Fragmentable {
  id: () => Promise<ID_Output>;
  inventory: <T = InventoryPromise>() => T;
  cast: <T = CastPromise>() => T;
}

export interface HigherPowerSubscription
  extends Promise<AsyncIterator<HigherPower>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  inventory: <T = InventorySubscription>() => T;
  cast: <T = CastSubscription>() => T;
}

export interface InventoryConnection {
  pageInfo: PageInfo;
  edges: InventoryEdge[];
}

export interface InventoryConnectionPromise
  extends Promise<InventoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InventoryEdge>>() => T;
  aggregate: <T = AggregateInventoryPromise>() => T;
}

export interface InventoryConnectionSubscription
  extends Promise<AsyncIterator<InventoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InventoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInventorySubscription>() => T;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Character",
    embedded: false
  },
  {
    name: "Process",
    embedded: false
  },
  {
    name: "Source",
    embedded: false
  },
  {
    name: "Path",
    embedded: false
  },
  {
    name: "Feeling",
    embedded: false
  },
  {
    name: "Thought",
    embedded: false
  },
  {
    name: "Inventory",
    embedded: false
  },
  {
    name: "InventoryPath",
    embedded: false
  },
  {
    name: "PathFeeling",
    embedded: false
  },
  {
    name: "Cast",
    embedded: false
  },
  {
    name: "CastCharacter",
    embedded: false
  },
  {
    name: "CharacterProcess",
    embedded: false
  },
  {
    name: "ProcessSource",
    embedded: false
  },
  {
    name: "SourceFeeling",
    embedded: false
  },
  {
    name: "HigherPower",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
