// Code generated by Prisma (prisma@1.30.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  character: (where?: CharacterWhereInput) => Promise<boolean>;
  feeling: (where?: FeelingWhereInput) => Promise<boolean>;
  path: (where?: PathWhereInput) => Promise<boolean>;
  process: (where?: ProcessWhereInput) => Promise<boolean>;
  source: (where?: SourceWhereInput) => Promise<boolean>;
  thought: (where?: ThoughtWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  character: (where: CharacterWhereUniqueInput) => CharacterPromise;
  characters: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Character>;
  charactersConnection: (
    args?: {
      where?: CharacterWhereInput;
      orderBy?: CharacterOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CharacterConnectionPromise;
  feeling: (where: FeelingWhereUniqueInput) => FeelingPromise;
  feelings: (
    args?: {
      where?: FeelingWhereInput;
      orderBy?: FeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Feeling>;
  feelingsConnection: (
    args?: {
      where?: FeelingWhereInput;
      orderBy?: FeelingOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FeelingConnectionPromise;
  path: (where: PathWhereUniqueInput) => PathPromise;
  paths: (
    args?: {
      where?: PathWhereInput;
      orderBy?: PathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Path>;
  pathsConnection: (
    args?: {
      where?: PathWhereInput;
      orderBy?: PathOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PathConnectionPromise;
  process: (where: ProcessWhereUniqueInput) => ProcessPromise;
  processes: (
    args?: {
      where?: ProcessWhereInput;
      orderBy?: ProcessOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Process>;
  processesConnection: (
    args?: {
      where?: ProcessWhereInput;
      orderBy?: ProcessOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProcessConnectionPromise;
  source: (where: SourceWhereUniqueInput) => SourcePromise;
  sources: (
    args?: {
      where?: SourceWhereInput;
      orderBy?: SourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Source>;
  sourcesConnection: (
    args?: {
      where?: SourceWhereInput;
      orderBy?: SourceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SourceConnectionPromise;
  thought: (where: ThoughtWhereUniqueInput) => ThoughtPromise;
  thoughts: (
    args?: {
      where?: ThoughtWhereInput;
      orderBy?: ThoughtOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Thought>;
  thoughtsConnection: (
    args?: {
      where?: ThoughtWhereInput;
      orderBy?: ThoughtOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ThoughtConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCharacter: (data: CharacterCreateInput) => CharacterPromise;
  updateCharacter: (
    args: { data: CharacterUpdateInput; where: CharacterWhereUniqueInput }
  ) => CharacterPromise;
  updateManyCharacters: (
    args: {
      data: CharacterUpdateManyMutationInput;
      where?: CharacterWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCharacter: (
    args: {
      where: CharacterWhereUniqueInput;
      create: CharacterCreateInput;
      update: CharacterUpdateInput;
    }
  ) => CharacterPromise;
  deleteCharacter: (where: CharacterWhereUniqueInput) => CharacterPromise;
  deleteManyCharacters: (where?: CharacterWhereInput) => BatchPayloadPromise;
  createFeeling: (data: FeelingCreateInput) => FeelingPromise;
  updateFeeling: (
    args: { data: FeelingUpdateInput; where: FeelingWhereUniqueInput }
  ) => FeelingPromise;
  updateManyFeelings: (
    args: { data: FeelingUpdateManyMutationInput; where?: FeelingWhereInput }
  ) => BatchPayloadPromise;
  upsertFeeling: (
    args: {
      where: FeelingWhereUniqueInput;
      create: FeelingCreateInput;
      update: FeelingUpdateInput;
    }
  ) => FeelingPromise;
  deleteFeeling: (where: FeelingWhereUniqueInput) => FeelingPromise;
  deleteManyFeelings: (where?: FeelingWhereInput) => BatchPayloadPromise;
  createPath: (data: PathCreateInput) => PathPromise;
  updatePath: (
    args: { data: PathUpdateInput; where: PathWhereUniqueInput }
  ) => PathPromise;
  updateManyPaths: (
    args: { data: PathUpdateManyMutationInput; where?: PathWhereInput }
  ) => BatchPayloadPromise;
  upsertPath: (
    args: {
      where: PathWhereUniqueInput;
      create: PathCreateInput;
      update: PathUpdateInput;
    }
  ) => PathPromise;
  deletePath: (where: PathWhereUniqueInput) => PathPromise;
  deleteManyPaths: (where?: PathWhereInput) => BatchPayloadPromise;
  createProcess: (data: ProcessCreateInput) => ProcessPromise;
  updateProcess: (
    args: { data: ProcessUpdateInput; where: ProcessWhereUniqueInput }
  ) => ProcessPromise;
  updateManyProcesses: (
    args: { data: ProcessUpdateManyMutationInput; where?: ProcessWhereInput }
  ) => BatchPayloadPromise;
  upsertProcess: (
    args: {
      where: ProcessWhereUniqueInput;
      create: ProcessCreateInput;
      update: ProcessUpdateInput;
    }
  ) => ProcessPromise;
  deleteProcess: (where: ProcessWhereUniqueInput) => ProcessPromise;
  deleteManyProcesses: (where?: ProcessWhereInput) => BatchPayloadPromise;
  createSource: (data: SourceCreateInput) => SourcePromise;
  updateSource: (
    args: { data: SourceUpdateInput; where: SourceWhereUniqueInput }
  ) => SourcePromise;
  updateManySources: (
    args: { data: SourceUpdateManyMutationInput; where?: SourceWhereInput }
  ) => BatchPayloadPromise;
  upsertSource: (
    args: {
      where: SourceWhereUniqueInput;
      create: SourceCreateInput;
      update: SourceUpdateInput;
    }
  ) => SourcePromise;
  deleteSource: (where: SourceWhereUniqueInput) => SourcePromise;
  deleteManySources: (where?: SourceWhereInput) => BatchPayloadPromise;
  createThought: (data: ThoughtCreateInput) => ThoughtPromise;
  updateThought: (
    args: { data: ThoughtUpdateInput; where: ThoughtWhereUniqueInput }
  ) => ThoughtPromise;
  updateManyThoughts: (
    args: { data: ThoughtUpdateManyMutationInput; where?: ThoughtWhereInput }
  ) => BatchPayloadPromise;
  upsertThought: (
    args: {
      where: ThoughtWhereUniqueInput;
      create: ThoughtCreateInput;
      update: ThoughtUpdateInput;
    }
  ) => ThoughtPromise;
  deleteThought: (where: ThoughtWhereUniqueInput) => ThoughtPromise;
  deleteManyThoughts: (where?: ThoughtWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  character: (
    where?: CharacterSubscriptionWhereInput
  ) => CharacterSubscriptionPayloadSubscription;
  feeling: (
    where?: FeelingSubscriptionWhereInput
  ) => FeelingSubscriptionPayloadSubscription;
  path: (
    where?: PathSubscriptionWhereInput
  ) => PathSubscriptionPayloadSubscription;
  process: (
    where?: ProcessSubscriptionWhereInput
  ) => ProcessSubscriptionPayloadSubscription;
  source: (
    where?: SourceSubscriptionWhereInput
  ) => SourceSubscriptionPayloadSubscription;
  thought: (
    where?: ThoughtSubscriptionWhereInput
  ) => ThoughtSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type FeelingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type PathOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type CharacterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "process_ASC"
  | "process_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type SourceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type ThoughtOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "character_ASC"
  | "character_DESC"
  | "thought_ASC"
  | "thought_DESC"
  | "quality_ASC"
  | "quality_DESC"
  | "source_ASC"
  | "source_DESC"
  | "process_ASC"
  | "process_DESC"
  | "path_ASC"
  | "path_DESC"
  | "feeling_ASC"
  | "feeling_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "prayedAt_ASC"
  | "prayedAt_DESC"
  | "sharedAt_ASC"
  | "sharedAt_DESC"
  | "amendedAt_ASC"
  | "amendedAt_DESC"
  | "resolvedAt_ASC"
  | "resolvedAt_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProcessOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "userId_ASC"
  | "userId_DESC";

export interface FeelingCreateInput {
  id?: ID_Input;
  key: String;
  title: String;
  thoughts?: FeelingCreatethoughtsInput;
  userId: ID_Input;
}

export interface ProcessUpdateInput {
  key?: String;
  title?: String;
  sources?: ProcessUpdatesourcesInput;
  userId?: ID_Input;
}

export type CharacterWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  key?: String;
}>;

export interface SourceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  AND?: SourceWhereInput[] | SourceWhereInput;
  OR?: SourceWhereInput[] | SourceWhereInput;
  NOT?: SourceWhereInput[] | SourceWhereInput;
}

export interface FeelingSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FeelingWhereInput;
  AND?: FeelingSubscriptionWhereInput[] | FeelingSubscriptionWhereInput;
  OR?: FeelingSubscriptionWhereInput[] | FeelingSubscriptionWhereInput;
  NOT?: FeelingSubscriptionWhereInput[] | FeelingSubscriptionWhereInput;
}

export interface CharacterWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  process?: String;
  process_not?: String;
  process_in?: String[] | String;
  process_not_in?: String[] | String;
  process_lt?: String;
  process_lte?: String;
  process_gt?: String;
  process_gte?: String;
  process_contains?: String;
  process_not_contains?: String;
  process_starts_with?: String;
  process_not_starts_with?: String;
  process_ends_with?: String;
  process_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  AND?: CharacterWhereInput[] | CharacterWhereInput;
  OR?: CharacterWhereInput[] | CharacterWhereInput;
  NOT?: CharacterWhereInput[] | CharacterWhereInput;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  password?: String;
}

export interface ProcessCreatesourcesInput {
  set?: String[] | String;
}

export interface UserUpdateInput {
  email?: String;
  password?: String;
}

export interface ProcessCreateInput {
  id?: ID_Input;
  key: String;
  title: String;
  sources?: ProcessCreatesourcesInput;
  userId: ID_Input;
}

export interface PathSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PathWhereInput;
  AND?: PathSubscriptionWhereInput[] | PathSubscriptionWhereInput;
  OR?: PathSubscriptionWhereInput[] | PathSubscriptionWhereInput;
  NOT?: PathSubscriptionWhereInput[] | PathSubscriptionWhereInput;
}

export interface PathUpdateManyMutationInput {
  key?: String;
  title?: String;
  feelings?: PathUpdatefeelingsInput;
  userId?: ID_Input;
}

export interface ThoughtUpdateManyMutationInput {
  character?: ID_Input;
  thought?: String;
  quality?: Boolean;
  source?: ID_Input;
  process?: ID_Input;
  path?: ID_Input;
  feeling?: ID_Input;
  prayedAt?: DateTimeInput;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  userId?: ID_Input;
}

export type ThoughtWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PathWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  key?: String;
}>;

export interface PathUpdatefeelingsInput {
  set?: String[] | String;
}

export interface PathWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  AND?: PathWhereInput[] | PathWhereInput;
  OR?: PathWhereInput[] | PathWhereInput;
  NOT?: PathWhereInput[] | PathWhereInput;
}

export interface ThoughtWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  character?: ID_Input;
  character_not?: ID_Input;
  character_in?: ID_Input[] | ID_Input;
  character_not_in?: ID_Input[] | ID_Input;
  character_lt?: ID_Input;
  character_lte?: ID_Input;
  character_gt?: ID_Input;
  character_gte?: ID_Input;
  character_contains?: ID_Input;
  character_not_contains?: ID_Input;
  character_starts_with?: ID_Input;
  character_not_starts_with?: ID_Input;
  character_ends_with?: ID_Input;
  character_not_ends_with?: ID_Input;
  thought?: String;
  thought_not?: String;
  thought_in?: String[] | String;
  thought_not_in?: String[] | String;
  thought_lt?: String;
  thought_lte?: String;
  thought_gt?: String;
  thought_gte?: String;
  thought_contains?: String;
  thought_not_contains?: String;
  thought_starts_with?: String;
  thought_not_starts_with?: String;
  thought_ends_with?: String;
  thought_not_ends_with?: String;
  quality?: Boolean;
  quality_not?: Boolean;
  source?: ID_Input;
  source_not?: ID_Input;
  source_in?: ID_Input[] | ID_Input;
  source_not_in?: ID_Input[] | ID_Input;
  source_lt?: ID_Input;
  source_lte?: ID_Input;
  source_gt?: ID_Input;
  source_gte?: ID_Input;
  source_contains?: ID_Input;
  source_not_contains?: ID_Input;
  source_starts_with?: ID_Input;
  source_not_starts_with?: ID_Input;
  source_ends_with?: ID_Input;
  source_not_ends_with?: ID_Input;
  process?: ID_Input;
  process_not?: ID_Input;
  process_in?: ID_Input[] | ID_Input;
  process_not_in?: ID_Input[] | ID_Input;
  process_lt?: ID_Input;
  process_lte?: ID_Input;
  process_gt?: ID_Input;
  process_gte?: ID_Input;
  process_contains?: ID_Input;
  process_not_contains?: ID_Input;
  process_starts_with?: ID_Input;
  process_not_starts_with?: ID_Input;
  process_ends_with?: ID_Input;
  process_not_ends_with?: ID_Input;
  path?: ID_Input;
  path_not?: ID_Input;
  path_in?: ID_Input[] | ID_Input;
  path_not_in?: ID_Input[] | ID_Input;
  path_lt?: ID_Input;
  path_lte?: ID_Input;
  path_gt?: ID_Input;
  path_gte?: ID_Input;
  path_contains?: ID_Input;
  path_not_contains?: ID_Input;
  path_starts_with?: ID_Input;
  path_not_starts_with?: ID_Input;
  path_ends_with?: ID_Input;
  path_not_ends_with?: ID_Input;
  feeling?: ID_Input;
  feeling_not?: ID_Input;
  feeling_in?: ID_Input[] | ID_Input;
  feeling_not_in?: ID_Input[] | ID_Input;
  feeling_lt?: ID_Input;
  feeling_lte?: ID_Input;
  feeling_gt?: ID_Input;
  feeling_gte?: ID_Input;
  feeling_contains?: ID_Input;
  feeling_not_contains?: ID_Input;
  feeling_starts_with?: ID_Input;
  feeling_not_starts_with?: ID_Input;
  feeling_ends_with?: ID_Input;
  feeling_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  prayedAt?: DateTimeInput;
  prayedAt_not?: DateTimeInput;
  prayedAt_in?: DateTimeInput[] | DateTimeInput;
  prayedAt_not_in?: DateTimeInput[] | DateTimeInput;
  prayedAt_lt?: DateTimeInput;
  prayedAt_lte?: DateTimeInput;
  prayedAt_gt?: DateTimeInput;
  prayedAt_gte?: DateTimeInput;
  sharedAt?: DateTimeInput;
  sharedAt_not?: DateTimeInput;
  sharedAt_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_not_in?: DateTimeInput[] | DateTimeInput;
  sharedAt_lt?: DateTimeInput;
  sharedAt_lte?: DateTimeInput;
  sharedAt_gt?: DateTimeInput;
  sharedAt_gte?: DateTimeInput;
  amendedAt?: DateTimeInput;
  amendedAt_not?: DateTimeInput;
  amendedAt_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_not_in?: DateTimeInput[] | DateTimeInput;
  amendedAt_lt?: DateTimeInput;
  amendedAt_lte?: DateTimeInput;
  amendedAt_gt?: DateTimeInput;
  amendedAt_gte?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  resolvedAt_not?: DateTimeInput;
  resolvedAt_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_not_in?: DateTimeInput[] | DateTimeInput;
  resolvedAt_lt?: DateTimeInput;
  resolvedAt_lte?: DateTimeInput;
  resolvedAt_gt?: DateTimeInput;
  resolvedAt_gte?: DateTimeInput;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  AND?: ThoughtWhereInput[] | ThoughtWhereInput;
  OR?: ThoughtWhereInput[] | ThoughtWhereInput;
  NOT?: ThoughtWhereInput[] | ThoughtWhereInput;
}

export interface SourceUpdateManyMutationInput {
  key?: String;
  title?: String;
  feelings?: SourceUpdatefeelingsInput;
  userId?: ID_Input;
}

export interface SourceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SourceWhereInput;
  AND?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
  OR?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
  NOT?: SourceSubscriptionWhereInput[] | SourceSubscriptionWhereInput;
}

export interface SourceUpdateInput {
  key?: String;
  title?: String;
  feelings?: SourceUpdatefeelingsInput;
  userId?: ID_Input;
}

export interface PathUpdateInput {
  key?: String;
  title?: String;
  feelings?: PathUpdatefeelingsInput;
  userId?: ID_Input;
}

export interface SourceCreatefeelingsInput {
  set?: String[] | String;
}

export interface PathCreatefeelingsInput {
  set?: String[] | String;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface PathCreateInput {
  id?: ID_Input;
  key: String;
  title: String;
  feelings?: PathCreatefeelingsInput;
  userId: ID_Input;
}

export interface ProcessUpdateManyMutationInput {
  key?: String;
  title?: String;
  sources?: ProcessUpdatesourcesInput;
  userId?: ID_Input;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export type SourceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  key?: String;
}>;

export interface FeelingUpdateManyMutationInput {
  key?: String;
  title?: String;
  thoughts?: FeelingUpdatethoughtsInput;
  userId?: ID_Input;
}

export type FeelingWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  key?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface UserCreateInput {
  id?: ID_Input;
  email: String;
  password: String;
}

export interface ThoughtSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ThoughtWhereInput;
  AND?: ThoughtSubscriptionWhereInput[] | ThoughtSubscriptionWhereInput;
  OR?: ThoughtSubscriptionWhereInput[] | ThoughtSubscriptionWhereInput;
  NOT?: ThoughtSubscriptionWhereInput[] | ThoughtSubscriptionWhereInput;
}

export interface ThoughtCreateInput {
  id?: ID_Input;
  character?: ID_Input;
  thought: String;
  quality?: Boolean;
  source?: ID_Input;
  process?: ID_Input;
  path?: ID_Input;
  feeling: ID_Input;
  prayedAt?: DateTimeInput;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  userId: ID_Input;
}

export interface FeelingUpdatethoughtsInput {
  set?: String[] | String;
}

export interface SourceUpdatefeelingsInput {
  set?: String[] | String;
}

export interface FeelingUpdateInput {
  key?: String;
  title?: String;
  thoughts?: FeelingUpdatethoughtsInput;
  userId?: ID_Input;
}

export interface ProcessWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  AND?: ProcessWhereInput[] | ProcessWhereInput;
  OR?: ProcessWhereInput[] | ProcessWhereInput;
  NOT?: ProcessWhereInput[] | ProcessWhereInput;
}

export interface FeelingCreatethoughtsInput {
  set?: String[] | String;
}

export interface ProcessUpdatesourcesInput {
  set?: String[] | String;
}

export interface FeelingWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  userId?: ID_Input;
  userId_not?: ID_Input;
  userId_in?: ID_Input[] | ID_Input;
  userId_not_in?: ID_Input[] | ID_Input;
  userId_lt?: ID_Input;
  userId_lte?: ID_Input;
  userId_gt?: ID_Input;
  userId_gte?: ID_Input;
  userId_contains?: ID_Input;
  userId_not_contains?: ID_Input;
  userId_starts_with?: ID_Input;
  userId_not_starts_with?: ID_Input;
  userId_ends_with?: ID_Input;
  userId_not_ends_with?: ID_Input;
  AND?: FeelingWhereInput[] | FeelingWhereInput;
  OR?: FeelingWhereInput[] | FeelingWhereInput;
  NOT?: FeelingWhereInput[] | FeelingWhereInput;
}

export interface CharacterUpdateManyMutationInput {
  key?: String;
  title?: String;
  description?: String;
  process?: String;
  userId?: ID_Input;
}

export interface CharacterUpdateInput {
  key?: String;
  title?: String;
  description?: String;
  process?: String;
  userId?: ID_Input;
}

export interface CharacterCreateInput {
  id?: ID_Input;
  key: String;
  title: String;
  description?: String;
  process: String;
  userId: ID_Input;
}

export interface ThoughtUpdateInput {
  character?: ID_Input;
  thought?: String;
  quality?: Boolean;
  source?: ID_Input;
  process?: ID_Input;
  path?: ID_Input;
  feeling?: ID_Input;
  prayedAt?: DateTimeInput;
  sharedAt?: DateTimeInput;
  amendedAt?: DateTimeInput;
  resolvedAt?: DateTimeInput;
  userId?: ID_Input;
}

export interface CharacterSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CharacterWhereInput;
  AND?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  OR?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
  NOT?: CharacterSubscriptionWhereInput[] | CharacterSubscriptionWhereInput;
}

export interface SourceCreateInput {
  id?: ID_Input;
  key: String;
  title: String;
  feelings?: SourceCreatefeelingsInput;
  userId: ID_Input;
}

export type ProcessWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  key?: String;
}>;

export interface ProcessSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProcessWhereInput;
  AND?: ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput;
  OR?: ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput;
  NOT?: ProcessSubscriptionWhereInput[] | ProcessSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FeelingConnection {
  pageInfo: PageInfo;
  edges: FeelingEdge[];
}

export interface FeelingConnectionPromise
  extends Promise<FeelingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FeelingEdge>>() => T;
  aggregate: <T = AggregateFeelingPromise>() => T;
}

export interface FeelingConnectionSubscription
  extends Promise<AsyncIterator<FeelingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FeelingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFeelingSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface FeelingEdge {
  node: Feeling;
  cursor: String;
}

export interface FeelingEdgePromise extends Promise<FeelingEdge>, Fragmentable {
  node: <T = FeelingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FeelingEdgeSubscription
  extends Promise<AsyncIterator<FeelingEdge>>,
    Fragmentable {
  node: <T = FeelingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Character {
  id: ID_Output;
  key: String;
  title: String;
  description?: String;
  process: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface CharacterPromise extends Promise<Character>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  process: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface CharacterSubscription
  extends Promise<AsyncIterator<Character>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Feeling {
  id: ID_Output;
  key: String;
  title: String;
  thoughts: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface FeelingPromise extends Promise<Feeling>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  thoughts: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface FeelingSubscription
  extends Promise<AsyncIterator<Feeling>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  thoughts: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCharacter {
  count: Int;
}

export interface AggregateCharacterPromise
  extends Promise<AggregateCharacter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharacterSubscription
  extends Promise<AsyncIterator<AggregateCharacter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ThoughtEdge {
  node: Thought;
  cursor: String;
}

export interface ThoughtEdgePromise extends Promise<ThoughtEdge>, Fragmentable {
  node: <T = ThoughtPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ThoughtEdgeSubscription
  extends Promise<AsyncIterator<ThoughtEdge>>,
    Fragmentable {
  node: <T = ThoughtSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharacterEdge {
  node: Character;
  cursor: String;
}

export interface CharacterEdgePromise
  extends Promise<CharacterEdge>,
    Fragmentable {
  node: <T = CharacterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharacterEdgeSubscription
  extends Promise<AsyncIterator<CharacterEdge>>,
    Fragmentable {
  node: <T = CharacterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Thought {
  id: ID_Output;
  character?: ID_Output;
  thought: String;
  quality?: Boolean;
  source?: ID_Output;
  process?: ID_Output;
  path?: ID_Output;
  feeling: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  prayedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
  userId: ID_Output;
}

export interface ThoughtPromise extends Promise<Thought>, Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<ID_Output>;
  thought: () => Promise<String>;
  quality: () => Promise<Boolean>;
  source: () => Promise<ID_Output>;
  process: () => Promise<ID_Output>;
  path: () => Promise<ID_Output>;
  feeling: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  prayedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface ThoughtSubscription
  extends Promise<AsyncIterator<Thought>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<ID_Output>>;
  thought: () => Promise<AsyncIterator<String>>;
  quality: () => Promise<AsyncIterator<Boolean>>;
  source: () => Promise<AsyncIterator<ID_Output>>;
  process: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<ID_Output>>;
  feeling: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  prayedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface SourceEdge {
  node: Source;
  cursor: String;
}

export interface SourceEdgePromise extends Promise<SourceEdge>, Fragmentable {
  node: <T = SourcePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SourceEdgeSubscription
  extends Promise<AsyncIterator<SourceEdge>>,
    Fragmentable {
  node: <T = SourceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharacterSubscriptionPayload {
  mutation: MutationType;
  node: Character;
  updatedFields: String[];
  previousValues: CharacterPreviousValues;
}

export interface CharacterSubscriptionPayloadPromise
  extends Promise<CharacterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharacterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharacterPreviousValuesPromise>() => T;
}

export interface CharacterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharacterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharacterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharacterPreviousValuesSubscription>() => T;
}

export interface Source {
  id: ID_Output;
  key: String;
  title: String;
  feelings: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface SourcePromise extends Promise<Source>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  feelings: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface SourceSubscription
  extends Promise<AsyncIterator<Source>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface CharacterPreviousValues {
  id: ID_Output;
  key: String;
  title: String;
  description?: String;
  process: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface CharacterPreviousValuesPromise
  extends Promise<CharacterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  process: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface CharacterPreviousValuesSubscription
  extends Promise<AsyncIterator<CharacterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  process: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ProcessEdge {
  node: Process;
  cursor: String;
}

export interface ProcessEdgePromise extends Promise<ProcessEdge>, Fragmentable {
  node: <T = ProcessPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProcessEdgeSubscription
  extends Promise<AsyncIterator<ProcessEdge>>,
    Fragmentable {
  node: <T = ProcessSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Process {
  id: ID_Output;
  key: String;
  title: String;
  sources: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface ProcessPromise extends Promise<Process>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  sources: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface ProcessSubscription
  extends Promise<AsyncIterator<Process>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  sources: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface FeelingSubscriptionPayload {
  mutation: MutationType;
  node: Feeling;
  updatedFields: String[];
  previousValues: FeelingPreviousValues;
}

export interface FeelingSubscriptionPayloadPromise
  extends Promise<FeelingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FeelingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FeelingPreviousValuesPromise>() => T;
}

export interface FeelingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FeelingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FeelingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FeelingPreviousValuesSubscription>() => T;
}

export interface PathEdge {
  node: Path;
  cursor: String;
}

export interface PathEdgePromise extends Promise<PathEdge>, Fragmentable {
  node: <T = PathPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PathEdgeSubscription
  extends Promise<AsyncIterator<PathEdge>>,
    Fragmentable {
  node: <T = PathSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FeelingPreviousValues {
  id: ID_Output;
  key: String;
  title: String;
  thoughts: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface FeelingPreviousValuesPromise
  extends Promise<FeelingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  thoughts: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface FeelingPreviousValuesSubscription
  extends Promise<AsyncIterator<FeelingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  thoughts: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface Path {
  id: ID_Output;
  key: String;
  title: String;
  feelings: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface PathPromise extends Promise<Path>, Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  feelings: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface PathSubscription
  extends Promise<AsyncIterator<Path>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface CharacterConnection {
  pageInfo: PageInfo;
  edges: CharacterEdge[];
}

export interface CharacterConnectionPromise
  extends Promise<CharacterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharacterEdge>>() => T;
  aggregate: <T = AggregateCharacterPromise>() => T;
}

export interface CharacterConnectionSubscription
  extends Promise<AsyncIterator<CharacterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharacterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharacterSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PathSubscriptionPayload {
  mutation: MutationType;
  node: Path;
  updatedFields: String[];
  previousValues: PathPreviousValues;
}

export interface PathSubscriptionPayloadPromise
  extends Promise<PathSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PathPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PathPreviousValuesPromise>() => T;
}

export interface PathSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PathSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PathSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PathPreviousValuesSubscription>() => T;
}

export interface ThoughtConnection {
  pageInfo: PageInfo;
  edges: ThoughtEdge[];
}

export interface ThoughtConnectionPromise
  extends Promise<ThoughtConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ThoughtEdge>>() => T;
  aggregate: <T = AggregateThoughtPromise>() => T;
}

export interface ThoughtConnectionSubscription
  extends Promise<AsyncIterator<ThoughtConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ThoughtEdgeSubscription>>>() => T;
  aggregate: <T = AggregateThoughtSubscription>() => T;
}

export interface PathPreviousValues {
  id: ID_Output;
  key: String;
  title: String;
  feelings: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface PathPreviousValuesPromise
  extends Promise<PathPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  feelings: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface PathPreviousValuesSubscription
  extends Promise<AsyncIterator<PathPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SourceConnection {
  pageInfo: PageInfo;
  edges: SourceEdge[];
}

export interface SourceConnectionPromise
  extends Promise<SourceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SourceEdge>>() => T;
  aggregate: <T = AggregateSourcePromise>() => T;
}

export interface SourceConnectionSubscription
  extends Promise<AsyncIterator<SourceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SourceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSourceSubscription>() => T;
}

export interface ThoughtPreviousValues {
  id: ID_Output;
  character?: ID_Output;
  thought: String;
  quality?: Boolean;
  source?: ID_Output;
  process?: ID_Output;
  path?: ID_Output;
  feeling: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  prayedAt?: DateTimeOutput;
  sharedAt?: DateTimeOutput;
  amendedAt?: DateTimeOutput;
  resolvedAt?: DateTimeOutput;
  userId: ID_Output;
}

export interface ThoughtPreviousValuesPromise
  extends Promise<ThoughtPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  character: () => Promise<ID_Output>;
  thought: () => Promise<String>;
  quality: () => Promise<Boolean>;
  source: () => Promise<ID_Output>;
  process: () => Promise<ID_Output>;
  path: () => Promise<ID_Output>;
  feeling: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  prayedAt: () => Promise<DateTimeOutput>;
  sharedAt: () => Promise<DateTimeOutput>;
  amendedAt: () => Promise<DateTimeOutput>;
  resolvedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface ThoughtPreviousValuesSubscription
  extends Promise<AsyncIterator<ThoughtPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  character: () => Promise<AsyncIterator<ID_Output>>;
  thought: () => Promise<AsyncIterator<String>>;
  quality: () => Promise<AsyncIterator<Boolean>>;
  source: () => Promise<AsyncIterator<ID_Output>>;
  process: () => Promise<AsyncIterator<ID_Output>>;
  path: () => Promise<AsyncIterator<ID_Output>>;
  feeling: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  prayedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  sharedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amendedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  resolvedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface ProcessConnection {
  pageInfo: PageInfo;
  edges: ProcessEdge[];
}

export interface ProcessConnectionPromise
  extends Promise<ProcessConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProcessEdge>>() => T;
  aggregate: <T = AggregateProcessPromise>() => T;
}

export interface ProcessConnectionSubscription
  extends Promise<AsyncIterator<ProcessConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProcessEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProcessSubscription>() => T;
}

export interface ProcessSubscriptionPayload {
  mutation: MutationType;
  node: Process;
  updatedFields: String[];
  previousValues: ProcessPreviousValues;
}

export interface ProcessSubscriptionPayloadPromise
  extends Promise<ProcessSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProcessPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProcessPreviousValuesPromise>() => T;
}

export interface ProcessSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProcessSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProcessSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProcessPreviousValuesSubscription>() => T;
}

export interface PathConnection {
  pageInfo: PageInfo;
  edges: PathEdge[];
}

export interface PathConnectionPromise
  extends Promise<PathConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PathEdge>>() => T;
  aggregate: <T = AggregatePathPromise>() => T;
}

export interface PathConnectionSubscription
  extends Promise<AsyncIterator<PathConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PathEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePathSubscription>() => T;
}

export interface AggregateThought {
  count: Int;
}

export interface AggregateThoughtPromise
  extends Promise<AggregateThought>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateThoughtSubscription
  extends Promise<AsyncIterator<AggregateThought>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SourcePreviousValues {
  id: ID_Output;
  key: String;
  title: String;
  feelings: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface SourcePreviousValuesPromise
  extends Promise<SourcePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  feelings: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface SourcePreviousValuesSubscription
  extends Promise<AsyncIterator<SourcePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  feelings: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface SourceSubscriptionPayload {
  mutation: MutationType;
  node: Source;
  updatedFields: String[];
  previousValues: SourcePreviousValues;
}

export interface SourceSubscriptionPayloadPromise
  extends Promise<SourceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SourcePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SourcePreviousValuesPromise>() => T;
}

export interface SourceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SourceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SourceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SourcePreviousValuesSubscription>() => T;
}

export interface ThoughtSubscriptionPayload {
  mutation: MutationType;
  node: Thought;
  updatedFields: String[];
  previousValues: ThoughtPreviousValues;
}

export interface ThoughtSubscriptionPayloadPromise
  extends Promise<ThoughtSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ThoughtPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ThoughtPreviousValuesPromise>() => T;
}

export interface ThoughtSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ThoughtSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ThoughtSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ThoughtPreviousValuesSubscription>() => T;
}

export interface ProcessPreviousValues {
  id: ID_Output;
  key: String;
  title: String;
  sources: String[];
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  userId: ID_Output;
}

export interface ProcessPreviousValuesPromise
  extends Promise<ProcessPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  title: () => Promise<String>;
  sources: () => Promise<String[]>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  userId: () => Promise<ID_Output>;
}

export interface ProcessPreviousValuesSubscription
  extends Promise<AsyncIterator<ProcessPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  sources: () => Promise<AsyncIterator<String[]>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateSource {
  count: Int;
}

export interface AggregateSourcePromise
  extends Promise<AggregateSource>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSourceSubscription
  extends Promise<AsyncIterator<AggregateSource>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateFeeling {
  count: Int;
}

export interface AggregateFeelingPromise
  extends Promise<AggregateFeeling>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFeelingSubscription
  extends Promise<AsyncIterator<AggregateFeeling>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePath {
  count: Int;
}

export interface AggregatePathPromise
  extends Promise<AggregatePath>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePathSubscription
  extends Promise<AsyncIterator<AggregatePath>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateProcess {
  count: Int;
}

export interface AggregateProcessPromise
  extends Promise<AggregateProcess>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProcessSubscription
  extends Promise<AsyncIterator<AggregateProcess>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Character",
    embedded: false
  },
  {
    name: "Process",
    embedded: false
  },
  {
    name: "Source",
    embedded: false
  },
  {
    name: "Path",
    embedded: false
  },
  {
    name: "Feeling",
    embedded: false
  },
  {
    name: "Thought",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
